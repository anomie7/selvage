[
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 46}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"line_number\\\": 152}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\nfrom .token_utils import TokenUtils\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"CLI 도구에서 `--diff-file` 옵션 및 관련 로직이 제거되었고, `reviewer.src.utils.token.__init__.py` 파일에서 `TokenUtils`에 대한 지연 임포트 래퍼가 제거되고 직접 임포트로 변경되었습니다. 전반적으로 코드 구조가 단순화되었습니다.\", \"score\": 8.0, \"recommendations\": [\"`--diff-file` 옵션 제거는 기능 변경이므로, 사용자 문서나 도움말에 해당 변경 사항을 명확히 반영하는 것이 좋습니다.\", \"`TokenUtils`의 지연 임포트 제거는 코드 가독성을 높이지만, 만약 초기 로딩 성능이 중요한 경우 변경 전의 지연 임포트 방식이 유리할 수도 있습니다. 현재 변경이 성능에 미치는 영향이 미미하다면 현재 코드가 더 간결하여 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport abc\\\\nfrom typing import Any, Union\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n        raise NotImplementedError\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> Union[\\\\\\\"BaseGateway\\\\\\\", Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        raise NotImplementedError\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"line_number\\\": 101, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"LLM 게이트웨이 기본 클래스에서 타입 힌트 처리를 개선했습니다. `from __future__ import annotations`를 도입하여 타입 힌트 구문을 단순화하고, `create` 메서드의 반환 타입 힌트를 더 명확하게 변경했습니다.\", \"score\": 9.0, \"recommendations\": [\"`from __future__ import annotations` 사용은 현대적인 Python 타입 힌트 작성에 권장되는 좋은 방법입니다. 파일 내 다른 부분에서도 타입 힌트를 단순화할 수 있는지 검토해 보세요.\", \"`Union` 대신 파이프 연산자(`|`)를 사용하여 타입 힌트를 더 간결하게 표현할 수 있습니다. (예: `Union[int, str]` 대신 `int | str`) 단, 이는 Python 3.10 이상에서만 가능합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\n```\\\", \\\"line_number\\\": 4}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 119}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"line_number\\\": 262}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"line_number\\\": 321}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n```\\\", \\\"line_number\\\": 132}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef _validate_api_key(api_key: str, provider: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키의 유효성을 검증합니다.\\\\n\\\\n    Args:\\\\n        api_key: 검증할 API 키\\\\n        provider: API 제공자 이름\\\\n\\\\n    Raises:\\\\n        InvalidAPIKeyError: API 키가 빈 값이거나 너무 짧은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not api_key or api_key.strip() == \\\\\\\"\\\\\\\":\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키가 비어 있습니다.\\\\\\\")\\\\n        raise InvalidAPIKeyError(provider, \\\\\\\"API 키가 비어 있습니다\\\\\\\")\\\\n\\\\n    if len(api_key) < 8:\\\\n        logger.error(\\\\n            f\\\\\\\"{provider.upper()} API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다.\\\\\\\"\\\\n        )\\\\n        raise InvalidAPIKeyError(\\\\n            provider, \\\\\\\"API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키\\\\n\\\\n    Raises:\\\\n        APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        InvalidAPIKeyError: API 키가 유효하지 않은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        api_key = config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n        _validate_api_key(api_key, provider)\\\\n        return api_key\\\\n\\\\n    logger.error(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n    raise APIKeyNotFoundError(provider)\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # API 키 유효성 검증\\\\n        _validate_api_key(api_key, provider)\\\\n\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except InvalidAPIKeyError:\\\\n        # 이미 로그는 _validate_api_key에서 기록됨\\\\n        return False\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"]\\\\n    except KeyError:\\\\n        logger.warning(\\\\n            \\\\\\\"기본 모델이 설정되지 않았습니다. 임시로 'o4-mini'로 리뷰를 처리합니다.\\\\\\\"\\\\n        )\\\\n        logger.info(\\\\n            \\\\\\\"다음 명령어로 기본 모델을 설정해주세요: reviewer config model <model_name>\\\\\\\"\\\\n        )\\\\n        return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\\n\\\\ndef set_default_model(model_name: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"model\\\\\\\" not in config:\\\\n            config[\\\\\\\"model\\\\\\\"] = {}\\\\n        config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"] = model_name\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"]\\\\n    except KeyError:\\\\n        logger.warning(\\\\n            \\\\\\\"기본 모델이 설정되지 않았습니다. 임시로 'o4-mini'로 리뷰를 처리합니다.\\\\\\\"\\\\n        )\\\\n        logger.info(\\\\n            \\\\\\\"다음 명령어로 기본 모델을 설정해주세요: reviewer config model <model_name>\\\\\\\"\\\\n        )\\\\n        return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\\n\\\\ndef set_default_model(model_name: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"model\\\\\\\" not in config:\\\\n            config[\\\\\\\"model\\\\\\\"] = {}\\\\n        config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"] = model_name\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n```\\\", \\\"line_number\\\": 216}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\nfrom .openai_gateway import OpenAIGateway\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"BaseGateway\\\\\\\",\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n    \\\\\\\"get_default_model\\\\\\\",\\\\n]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 13}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"기본 모델 설정 로직을 `config.py`로 이동하고, CLI에 모델 설정 명령어를 추가했습니다. `available_models.py`에서 기본 모델 관련 함수를 제거하고, `llm_gateway` 패키지 및 `GatewayFactory`에서 기본 모델 폴백 로직을 제거하여 책임 분리를 명확히 했습니다. 전반적으로 코드 구조가 개선되었습니다.\", \"score\": 9.0, \"recommendations\": [\"기본 모델 설정 로직이 `config.py`로 이동하여 설정 관리가 일관성 있게 되었습니다. 좋은 리팩토링입니다.\", \"`GatewayFactory.create` 메서드가 이제 명시적으로 모델 이름을 받도록 변경되어 팩토리의 역할이 더 명확해졌습니다. 모델 선택 책임은 호출자(CLI)에게 위임되었습니다. 이는 설계 개선으로 볼 수 있습니다.\", \"새로 추가된 `config model` 명령어 및 관련 설정 함수(`get_default_model`, `set_default_model`)에 대한 단위 테스트를 추가하여 설정 로직의 안정성을 확보하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"build.gradle.kts\\\", \\\"before_code\\\": \\\"```kotlin\\\\n}\\\\n\\\\ndependencies {\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-data-jpa\\\\\\\")\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-web\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin\\\\\\\")\\\\n    implementation(\\\\\\\"org.jetbrains.kotlin:kotlin-reflect\\\\\\\")\\\\n    runtimeOnly(\\\\\\\"com.h2database:h2\\\\\\\")\\\\n    testImplementation(\\\\\\\"org.springframework.boot:spring-boot-starter-test\\\\\\\")\\\\n    testRuntimeOnly(\\\\\\\"org.junit.platform:junit-platform-launcher\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.2\\\\\\\")\\\\n}\\\\n\\\\ntasks.withType<KotlinCompile> {\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n}\\\\n\\\\ndependencies {\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-web\\\\\\\")\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-data-jpa\\\\\\\")\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-security\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin\\\\\\\")\\\\n    implementation(\\\\\\\"org.jetbrains.kotlin:kotlin-reflect\\\\\\\")\\\\n    implementation(\\\\\\\"io.jsonwebtoken:jjwt-api:0.12.6\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.2\\\\\\\")\\\\n\\\\n    runtimeOnly(\\\\\\\"com.h2database:h2\\\\\\\")\\\\n    runtimeOnly(\\\\\\\"io.jsonwebtoken:jjwt-impl:0.12.6\\\\\\\")\\\\n    runtimeOnly(\\\\\\\"io.jsonwebtoken:jjwt-jackson:0.12.6\\\\\\\")\\\\n\\\\n    testRuntimeOnly(\\\\\\\"org.junit.platform:junit-platform-launcher\\\\\\\")\\\\n    testImplementation(\\\\\\\"org.springframework.boot:spring-boot-starter-test\\\\\\\")\\\\n    testImplementation(\\\\\\\"io.kotest:kotest-runner-junit5:5.9.1\\\\\\\")\\\\n    testImplementation(\\\\\\\"org.springframework.security:spring-security-test\\\\\\\")\\\\n}\\\\n\\\\ntasks.withType<KotlinCompile> {\\\\n```\\\", \\\"line_number\\\": 20, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/application/JwtProvider.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.UserId\\\\nimport io.jsonwebtoken.Jwts\\\\nimport io.jsonwebtoken.io.Decoders\\\\nimport io.jsonwebtoken.security.Keys\\\\nimport org.springframework.stereotype.Component\\\\nimport java.time.LocalDateTime\\\\nimport java.time.ZoneOffset\\\\nimport java.util.*\\\\n\\\\n@Component\\\\nclass JwtProvider {\\\\n    /**\\\\n     * Creates a JWT token for the given user ID.\\\\n     *\\\\n     * @param userId the ID of the user for whom the JWT token is being created\\\\n     * @return the generated JWT token as a string\\\\n     */\\\\n    fun create(userId: UserId): String {\\\\n        val now = LocalDateTime.now()\\\\n        val expirationTime = now.plusMinutes(EXPIRATION_MINUTES)\\\\n\\\\n        return Jwts.builder()\\\\n            .signWith(SECRET_KEY)\\\\n            .header()\\\\n            .add(\\\\\\\"typ\\\\\\\", \\\\\\\"JWT\\\\\\\")\\\\n            .add(\\\\\\\"alg\\\\\\\", \\\\\\\"HS256\\\\\\\")\\\\n            .and()\\\\n            .claims()\\\\n            .add(USER_ID_PAYLOAD_PARAMETER, userId.value)\\\\n            .and()\\\\n            .issuer(ISSUER)\\\\n            .issuedAt(Date.from(now.toInstant(ZoneOffset.UTC)))\\\\n            .expiration(Date.from(expirationTime.toInstant(ZoneOffset.UTC)))\\\\n            .compact()\\\\n    }\\\\n\\\\n    /**\\\\n     * Parses a JSON Web Signature (JWS) and retrieves the user ID from its payload.\\\\n     *\\\\n     * @param jws the JWS string to parse\\\\n     * @return the user ID extracted from the JWS payload as a Long\\\\n     */\\\\n    fun parse(jws: String) = Jwts.parser()\\\\n        .verifyWith(SECRET_KEY)\\\\n        .build()\\\\n        .parseSignedClaims(jws)\\\\n        .payload[USER_ID_PAYLOAD_PARAMETER].toString().toLong()\\\\n\\\\n    companion object {\\\\n        //TODO: It seems better to separate all the key signature information here as properties.\\\\n        private const val SECRET_KEY_STRING = \\\\\\\"s7tT5+Z/jfY47K3JqKDl8xhAyqTDynkxNoB/qBcIZd8=\\\\\\\"\\\\n        private val SECRET_KEY = Keys.hmacShaKeyFor(Decoders.BASE64.decode(SECRET_KEY_STRING))\\\\n        private const val ISSUER = \\\\\\\"짱구\\\\\\\"\\\\n        private const val USER_ID_PAYLOAD_PARAMETER = \\\\\\\"userId\\\\\\\"\\\\n\\\\n        private const val EXPIRATION_MINUTES = 30L\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/application/UserRegistrationService.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application\\\\n\\\\nimport io.github.gunkim.realworld.domain.entity.User\\\\nimport io.github.gunkim.realworld.domain.repository.UserRepository\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport org.springframework.stereotype.Service\\\\nimport org.springframework.transaction.annotation.Transactional\\\\n\\\\n@Service\\\\nclass UserRegistrationService(\\\\n    private val userRepository: UserRepository,\\\\n) {\\\\n    @Transactional\\\\n    fun registerUser(\\\\n        username: UserName,\\\\n        email: Email,\\\\n        password: String,\\\\n    ) {\\\\n        userRepository.save(User.create(username, email, password))\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/application/UserService.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.Email\\\\nimport io.github.gunkim.realworld.domain.user.User\\\\nimport io.github.gunkim.realworld.domain.user.UserRepository\\\\nimport io.github.gunkim.realworld.web.request.UserRegistrationRequest\\\\nimport org.springframework.security.crypto.password.PasswordEncoder\\\\nimport org.springframework.stereotype.Service\\\\nimport org.springframework.transaction.annotation.Transactional\\\\n\\\\n@Service\\\\nclass UserService(\\\\n    private val userRepository: UserRepository,\\\\n    private val passwordEncoder: PasswordEncoder,\\\\n) {\\\\n    @Transactional(readOnly = true)\\\\n    fun findUserByEmail(email: Email): User? {\\\\n        return userRepository.findByEmail(email)\\\\n    }\\\\n\\\\n    @Transactional\\\\n    fun registerUser(request: UserRegistrationRequest): User = request.run {\\\\n        require(userRepository.findByEmail(email) == null) { \\\\\\\"User already exists\\\\\\\" }\\\\n\\\\n        val encodedPassword = passwordEncoder.encode(password)\\\\n        return userRepository.save(User.create(username, email, encodedPassword))\\\\n    }\\\\n\\\\n    fun authenticate(user: User, password: String) {\\\\n        require(passwordEncoder.matches(password, user.password)) { \\\\\\\"Password does not match\\\\\\\" }\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/config/PasswordEncoderConfig.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.config\\\\n\\\\nimport org.springframework.context.annotation.Bean\\\\nimport org.springframework.context.annotation.Configuration\\\\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\\\\n\\\\n@Configuration\\\\nclass PasswordEncoderConfig {\\\\n    @Bean\\\\n    fun passwordEncoder() = BCryptPasswordEncoder()\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/config/SecurityConfig.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.config\\\\n\\\\nimport org.springframework.boot.autoconfigure.security.servlet.PathRequest\\\\nimport org.springframework.context.annotation.Bean\\\\nimport org.springframework.context.annotation.Configuration\\\\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity\\\\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\\\\nimport org.springframework.security.web.SecurityFilterChain\\\\n\\\\n@Configuration\\\\n@EnableWebSecurity\\\\nclass SecurityConfig {\\\\n    @Bean\\\\n    fun filterChain(http: HttpSecurity): SecurityFilterChain {\\\\n        return http\\\\n            .csrf { it.disable() }\\\\n            .cors { it.disable() }\\\\n            .sessionManagement { it.disable() }\\\\n            .headers { it.frameOptions { it.sameOrigin() } }\\\\n            .authorizeHttpRequests {\\\\n                it.requestMatchers(\\\\\\\"/api/users/**\\\\\\\").permitAll()\\\\n                it.requestMatchers(PathRequest.toH2Console()).permitAll()\\\\n                it.anyRequest().authenticated()\\\\n            }\\\\n            .build()\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/Article.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.AggregateRoot\\\\nimport io.github.gunkim.realworld.domain.vo.ArticleId\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.AggregateRoot\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/ArticleId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/Comment.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.DomainEntity\\\\nimport io.github.gunkim.realworld.domain.vo.CommentId\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.DomainEntity\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/CommentId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/Tag.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.DomainEntity\\\\nimport io.github.gunkim.realworld.domain.vo.TagId\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.FetchType\\\\nimport jakarta.persistence.Id\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.DomainEntity\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.FetchType\\\\nimport jakarta.persistence.Id\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/TagId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/common/AggregateRoot.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.base\\\\n\\\\nimport org.springframework.data.domain.AfterDomainEventPublication\\\\nimport org.springframework.data.domain.DomainEvents\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.common\\\\n\\\\nimport org.springframework.data.domain.AfterDomainEventPublication\\\\nimport org.springframework.data.domain.DomainEvents\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/common/DomainEntity.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.base\\\\n\\\\nabstract class DomainEntity<T : DomainEntity<T, TID>?, TID> {\\\\n    override fun equals(other: Any?): Boolean {\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.common\\\\n\\\\nabstract class DomainEntity<T : DomainEntity<T, TID>?, TID> {\\\\n    override fun equals(other: Any?): Boolean {\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/common/ValueObject.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.base\\\\n\\\\nimport java.lang.reflect.Field\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.common\\\\n\\\\nimport java.lang.reflect.Field\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/repository/UserRepository.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.repository\\\\n\\\\nimport io.github.gunkim.realworld.domain.entity.User\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport org.springframework.data.jpa.repository.JpaRepository\\\\n\\\\ninterface UserRepository : JpaRepository<User, UserId>\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/Email.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport io.github.gunkim.realworld.domain.article.ArticleId\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/User.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.AggregateRoot\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.AggregateRoot\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/User.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n    @Id\\\\n    override val id: UserId?,\\\\n    @Embedded\\\\n    val email: Email,\\\\n    password: String,\\\\n    @OneToOne(fetch = FetchType.LAZY, cascade = [CascadeType.ALL])\\\\n    val profile: UserProfile,\\\\n    val createdAt: LocalDateTime = LocalDateTime.now(),\\\\n) : AggregateRoot<User, UserId>() {\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n    @Id\\\\n    override val id: UserId?,\\\\n    @Embedded\\\\n    @Column(unique = true)\\\\n    val email: Email,\\\\n    password: String,\\\\n    @OneToOne(cascade = [CascadeType.ALL])\\\\n    val profile: UserProfile,\\\\n    val createdAt: LocalDateTime = LocalDateTime.now(),\\\\n) : AggregateRoot<User, UserId>() {\\\\n```\\\", \\\"line_number\\\": 9, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport io.github.gunkim.realworld.domain.article.ArticleId\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserName.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport io.github.gunkim.realworld.domain.article.ArticleId\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserProfile.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.DomainEntity\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.Id\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.DomainEntity\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.Id\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserRepository.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\ninterface UserRepository {\\\\n    fun save(user: User): User\\\\n    fun findByEmail(email: Email): User?\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/persistence/UserJpaRepository.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.persistence\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.User\\\\nimport io.github.gunkim.realworld.domain.user.UserId\\\\nimport io.github.gunkim.realworld.domain.user.UserRepository\\\\nimport org.springframework.data.jpa.repository.JpaRepository\\\\n\\\\ninterface UserJpaRepository : JpaRepository<User, UserId>, UserRepository {\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/UserController.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web\\\\n\\\\nimport io.github.gunkim.realworld.application.UserRegistrationService\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport org.springframework.web.bind.annotation.PostMapping\\\\nimport org.springframework.web.bind.annotation.RequestBody\\\\nimport org.springframework.web.bind.annotation.RequestMapping\\\\nimport org.springframework.web.bind.annotation.RestController\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"/api/users\\\\\\\")\\\\nclass UserController(\\\\n    private val userRegistrationService: UserRegistrationService,\\\\n) {\\\\n    @PostMapping\\\\n    fun registration(\\\\n        @RequestBody\\\\n        request: UserRegistrationRequest,\\\\n    ) {\\\\n        request.user.apply { run() }\\\\n    }\\\\n\\\\n    private fun UserRegistrationRequest.UserDetailRequest.run() {\\\\n        userRegistrationService.registerUser(\\\\n            UserName(username),\\\\n            Email(email),\\\\n            password\\\\n        )\\\\n    }\\\\n}\\\\n\\\\ndata class UserRegistrationRequest(\\\\n    val user: UserDetailRequest,\\\\n) {\\\\n    data class UserDetailRequest(\\\\n        val username: String,\\\\n        val email: String,\\\\n        val password: String,\\\\n    )\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/api/UserController.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.api\\\\n\\\\nimport io.github.gunkim.realworld.application.JwtProvider\\\\nimport io.github.gunkim.realworld.application.UserService\\\\nimport io.github.gunkim.realworld.domain.user.Email\\\\nimport io.github.gunkim.realworld.web.request.UserAuthenticateRequest\\\\nimport io.github.gunkim.realworld.web.request.UserRegistrationRequest\\\\nimport io.github.gunkim.realworld.web.response.UserResponse\\\\nimport org.springframework.web.bind.annotation.PostMapping\\\\nimport org.springframework.web.bind.annotation.RequestBody\\\\nimport org.springframework.web.bind.annotation.RequestMapping\\\\nimport org.springframework.web.bind.annotation.RestController\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"/api/users\\\\\\\")\\\\nclass UserController(\\\\n    private val userService: UserService,\\\\n    private val jwtProvider: JwtProvider,\\\\n) {\\\\n    @PostMapping\\\\n    fun registration(\\\\n        @RequestBody\\\\n        request: UserRegistrationRequest,\\\\n    ): UserResponse {\\\\n        val registeredUser = userService.registerUser(request)\\\\n        return UserResponse.from(registeredUser, jwtProvider.create(registeredUser.id!!))\\\\n    }\\\\n\\\\n    @PostMapping(\\\\\\\"/login\\\\\\\")\\\\n    fun authenticate(\\\\n        @RequestBody\\\\n        request: UserAuthenticateRequest,\\\\n    ): UserResponse {\\\\n        val user = userService.findUserByEmail(Email(request.email))\\\\n            ?: throw IllegalArgumentException(\\\\\\\"User not found\\\\\\\")\\\\n\\\\n        userService.authenticate(user, request.password)\\\\n\\\\n        return UserResponse.from(user, jwtProvider.create(user.id!!))\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/request/UserAuthenticateRequest.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.request\\\\n\\\\ndata class UserAuthenticateRequest(\\\\n    val email: String,\\\\n    val password: String,\\\\n)\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/request/UserRegistrationRequest.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.request\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.Email\\\\nimport io.github.gunkim.realworld.domain.user.UserName\\\\n\\\\nclass UserRegistrationRequest(\\\\n    username: String,\\\\n    email: String,\\\\n    val password: String,\\\\n) {\\\\n    val username = UserName(username)\\\\n    val email = Email(email)\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/response/UserResponse.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.response\\\\n\\\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo\\\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As.WRAPPER_OBJECT\\\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.Id.NAME\\\\nimport com.fasterxml.jackson.annotation.JsonTypeName\\\\nimport io.github.gunkim.realworld.domain.user.User\\\\n\\\\n@JsonTypeName(\\\\\\\"user\\\\\\\")\\\\n@JsonTypeInfo(include = WRAPPER_OBJECT, use = NAME)\\\\ndata class UserResponse(\\\\n    val email: String,\\\\n    val token: String,\\\\n    val username: String,\\\\n    val bio: String?,\\\\n    val image: String?,\\\\n) {\\\\n    companion object {\\\\n        fun from(user: User, token: String) = UserResponse(\\\\n            user.email.value,\\\\n            token,\\\\n            user.profile.name.value,\\\\n            user.profile.bio,\\\\n            user.profile.image\\\\n        )\\\\n    }\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/resources/application.yml\\\", \\\"before_code\\\": \\\"```yaml\\\\n  jpa:\\\\n    database-platform: org.hibernate.dialect.H2Dialect\\\\n    show-sql: true\\\\n  h2:\\\\n    console:\\\\n      enabled: true\\\\n      path: /h2-console\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```yaml\\\\n  jpa:\\\\n    database-platform: org.hibernate.dialect.H2Dialect\\\\n    show-sql: true\\\\n    open-in-view: false\\\\n  h2:\\\\n    console:\\\\n      enabled: true\\\\n      path: /h2-console\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 6, \\\"language\\\": \\\"yaml\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/test/kotlin/io/github/gunkim/realworld/application/user/JwtProviderTest.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application.user\\\\n\\\\nimport io.github.gunkim.realworld.application.JwtProvider\\\\nimport io.kotest.assertions.throwables.shouldNotThrow\\\\nimport io.kotest.core.annotation.DisplayName\\\\nimport io.kotest.core.spec.style.StringSpec\\\\nimport io.kotest.matchers.shouldBe\\\\n\\\\nprivate const val TEST_USER_ID = 1L\\\\n\\\\n@DisplayName(\\\\\\\"JwtProvider is\\\\\\\")\\\\nclass JwtProviderTest : StringSpec({\\\\n    val sut = JwtProvider()\\\\n\\\\n    \\\\\\\"should create JWT token successfully\\\\\\\" {\\\\n        shouldNotThrow<IllegalStateException> {\\\\n            sut.create(TEST_USER_ID)\\\\n        }\\\\n    }\\\\n\\\\n    \\\\\\\"should parse JWT token correctly\\\\\\\" {\\\\n        val jws = sut.create(TEST_USER_ID)\\\\n        sut.parse(jws) shouldBe TEST_USER_ID\\\\n    }\\\\n})\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"security\", \"line_number\": 55, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/application/JwtProvider.kt\", \"description\": \"JWT 서명에 사용되는 비밀 키가 소스 코드에 하드코딩되어 있습니다. 이는 보안상 매우 취약하며, 키가 노출될 경우 심각한 문제가 발생할 수 있습니다.\", \"suggestion\": \"비밀 키를 환경 변수, 외부 설정 파일 또는 Spring Cloud Config와 같은 중앙 집중식 설정 관리 시스템을 통해 관리하도록 변경해야 합니다. 하드코딩된 키는 즉시 제거하고 안전한 방식으로 로드하도록 수정하세요.\", \"severity\": \"error\", \"target_code\": \"private const val SECRET_KEY_STRING = \\\"s7tT5+Z/jfY47K3JqKDl8xhAyqTDynkxNoB/qBcIZd8=\\\"\", \"suggested_code\": null}, {\"type\": \"bug\", \"line_number\": 4, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/Email.kt\", \"description\": \"`io.github.gunkim.realworld.domain.article.ArticleId`가 `Email` 클래스에 불필요하게 임포트되었습니다. 이는 코드의 혼란을 야기하고 잠재적인 버그를 유발할 수 있습니다.\", \"suggestion\": \"사용되지 않는 임포트 문을 제거하세요.\", \"severity\": \"warning\", \"target_code\": \"import io.github.gunkim.realworld.domain.article.ArticleId\", \"suggested_code\": null}, {\"type\": \"bug\", \"line_number\": 4, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserId.kt\", \"description\": \"`io.github.gunkim.realworld.domain.article.ArticleId`가 `UserId` 클래스에 불필요하게 임포트되었습니다. 이는 코드의 혼란을 야기하고 잠재적인 버그를 유발할 수 있습니다.\", \"suggestion\": \"사용되지 않는 임포트 문을 제거하세요.\", \"severity\": \"warning\", \"target_code\": \"import io.github.gunkim.realworld.domain.article.ArticleId\", \"suggested_code\": null}, {\"type\": \"bug\", \"line_number\": 4, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserName.kt\", \"description\": \"`io.github.gunkim.realworld.domain.article.ArticleId`가 `UserName` 클래스에 불필요하게 임포트되었습니다. 이는 코드의 혼란을 야기하고 잠재적인 버그를 유발할 수 있습니다.\", \"suggestion\": \"사용되지 않는 임포트 문을 제거하세요.\", \"severity\": \"warning\", \"target_code\": \"import io.github.gunkim.realworld.domain.article.ArticleId\", \"suggested_code\": null}, {\"type\": \"performance\", \"line_number\": 15, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/User.kt\", \"description\": \"`profile` 관계에 대해 `fetch = FetchType.LAZY`가 제거되어 기본값인 `EAGER` 로딩이 적용됩니다. 이는 `User` 엔티티를 조회할 때마다 연관된 `UserProfile` 엔티티를 항상 함께 로딩하게 되어, 불필요한 데이터 로딩으로 인한 성능 저하를 유발할 수 있습니다.\", \"suggestion\": \"`profile` 관계에 `fetch = FetchType.LAZY`를 명시적으로 지정하여 필요한 경우에만 로딩되도록 변경하는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"@OneToOne(cascade = [CascadeType.ALL])\", \"suggested_code\": \"@OneToOne(fetch = FetchType.LAZY, cascade = [CascadeType.ALL])\"}, {\"type\": \"bug\", \"line_number\": 26, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/web/api/UserController.kt\", \"description\": \"`registeredUser.id!!`와 같이 널이 아님을 강제로 단언하는 연산자(`!!`)를 사용하고 있습니다. `user.id`가 실제로 널일 경우 `NullPointerException`이 발생할 수 있습니다. JPA 엔티티의 ID는 저장 후에는 널이 아니지만, 코드의 안정성을 높이기 위해 널 가능성을 명시적으로 처리하는 것이 좋습니다.\", \"suggestion\": \"널 가능성을 고려하여 안전 호출(`?.`) 또는 널 체크 후 사용하거나, 도메인 로직에서 ID가 항상 존재함을 보장하도록 설계하는 것을 고려하세요. 예를 들어, `let` 스코프 함수를 사용할 수 있습니다.\", \"severity\": \"warning\", \"target_code\": \"registeredUser.id!!\", \"suggested_code\": \"registeredUser.id?.let { jwtProvider.create(it) } ?: throw IllegalStateException(\\\"User ID cannot be null after registration\\\")\"}, {\"type\": \"bug\", \"line_number\": 39, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/web/api/UserController.kt\", \"description\": \"`user.id!!`와 같이 널이 아님을 강제로 단언하는 연산자(`!!`)를 사용하고 있습니다. `user.id`가 실제로 널일 경우 `NullPointerException`이 발생할 수 있습니다. JPA 엔티티의 ID는 저장 후에는 널이 아니지만, 코드의 안정성을 높이기 위해 널 가능성을 명시적으로 처리하는 것이 좋습니다.\", \"suggestion\": \"널 가능성을 고려하여 안전 호출(`?.`) 또는 널 체크 후 사용하거나, 도메인 로직에서 ID가 항상 존재함을 보장하도록 설계하는 것을 고려하세요. 예를 들어, `let` 스코프 함수를 사용할 수 있습니다.\", \"severity\": \"warning\", \"target_code\": \"user.id!!\", \"suggested_code\": \"user.id?.let { jwtProvider.create(it) } ?: throw IllegalStateException(\\\"User ID cannot be null after authentication\\\")\"}], \"summary\": \"사용자 등록 및 인증 기능에 Spring Security와 JWT가 도입되었습니다. 도메인 모델 패키지 구조가 재구성되었으며, JPA 관련 설정(Open Session In View 비활성화, Email Unique 제약조건 추가)이 개선되었습니다. 전반적으로 기능 구현 및 아키텍처 개선이 이루어졌으나, JWT 비밀 키 하드코딩, 불필요한 임포트, EAGER 로딩, 안전하지 않은 널 단언 등 몇 가지 중요한 보안, 버그, 성능 관련 이슈가 발견되었습니다.\", \"score\": 6.0, \"recommendations\": [\"JWT 비밀 키와 같은 민감 정보는 환경 변수나 외부 설정 파일을 통해 안전하게 관리해야 합니다.\", \"JWT 파싱 시 발생할 수 있는 예외(예: 토큰 만료, 잘못된 서명)에 대한 명확한 예외 처리 로직을 추가해야 합니다.\", \"웹 계층에서 발생하는 비즈니스 로직 예외(예: 사용자 없음, 비밀번호 불일치)를 Global Exception Handler를 통해 적절한 HTTP 상태 코드(예: 404 Not Found, 401 Unauthorized)로 매핑하여 반환하도록 개선해야 합니다.\", \"Spring Security 설정에서 CORS를 전역적으로 비활성화하는 대신, 필요한 오리진만 허용하도록 구체적으로 설정하는 것을 고려해야 합니다.\", \"새로 추가된 기능(인증, 등록) 및 발견된 이슈(JWT 파싱, 예외 처리)에 대한 단위 및 통합 테스트 케이스를 추가하여 코드의 안정성을 확보해야 합니다.\", \"파일 끝에 개행 문자를 추가하여 파일 형식을 일관되게 유지하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/hunk.py\\\", \\\"before_code\\\": \\\"```python\\\\nclass Hunk:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff의 hunk를 나타내는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    header: str\\\\n    content: str\\\\n    start_line_original: int\\\\n    line_count_original: int\\\\n    start_line_modified: int\\\\n    line_count_modified: int\\\\n\\\\n    @staticmethod\\\\n    def from_hunk_text(hunk_text: str) -> \\\\\\\"Hunk\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"hunk 텍스트로부터 Hunk 객체를 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        lines = hunk_text.split(\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n        header = lines[0]\\\\n        content = \\\\\\\"\\\\\\\\n\\\\\\\".join(lines[1:])\\\\n\\\\n        # @@ -73,7 +73,7 @@ 형식에서 라인 정보 추출\\\\n        header_match = re.match(r\\\\\\\"@@ -(\\\\\\\\d+),(\\\\\\\\d+) \\\\\\\\+(\\\\\\\\d+),(\\\\\\\\d+) @@\\\\\\\", header)\\\\n        if header_match:\\\\n            start_line_original = int(header_match.group(1))\\\\n            line_count_original = int(header_match.group(2))\\\\n            start_line_modified = int(header_match.group(3))\\\\n            line_count_modified = int(header_match.group(4))\\\\n        else:\\\\n            # 헤더 형식이 예상과 다른 경우 기본값 사용\\\\n            start_line_original = 0\\\\n            line_count_original = 0\\\\n            start_line_modified = 0\\\\n            line_count_modified = 0\\\\n\\\\n        return Hunk(\\\\n            header=header,\\\\n            content=content,\\\\n            start_line_original=start_line_original,\\\\n            line_count_original=line_count_original,\\\\n            start_line_modified=start_line_modified,\\\\n            line_count_modified=line_count_modified,\\\\n        )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nclass Hunk:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff의 hunk를 나타내는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    header: str\\\\n    content: str\\\\n    original_code: str\\\\n    modified_code: str\\\\n    start_line_original: int\\\\n    line_count_original: int\\\\n    start_line_modified: int\\\\n    line_count_modified: int\\\\n\\\\n    @staticmethod\\\\n    def from_hunk_text(hunk_text: str) -> \\\\\\\"Hunk\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"hunk 텍스트로부터 Hunk 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            hunk_text: git diff의 hunk 텍스트\\\\n\\\\n        Returns:\\\\n            Hunk: Hunk 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        lines = hunk_text.split(\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n        header = lines[0]\\\\n        content = \\\\\\\"\\\\\\\\n\\\\\\\".join(lines[1:])\\\\n\\\\n        header_match = re.match(r\\\\\\\"@@ -(\\\\\\\\d+),(\\\\\\\\d+) \\\\\\\\+(\\\\\\\\d+),(\\\\\\\\d+) @@\\\\\\\", header)\\\\n        if header_match:\\\\n            start_line_original = int(header_match.group(1))\\\\n            line_count_original = int(header_match.group(2))\\\\n            start_line_modified = int(header_match.group(3))\\\\n            line_count_modified = int(header_match.group(4))\\\\n        else:\\\\n            start_line_original = 0\\\\n            line_count_original = 0\\\\n            start_line_modified = 0\\\\n            line_count_modified = 0\\\\n\\\\n        original_code, modified_code = Hunk._parse_content_to_code(content)\\\\n\\\\n        return Hunk(\\\\n            header=header,\\\\n            content=content,\\\\n            original_code=original_code,\\\\n            modified_code=modified_code,\\\\n            start_line_original=start_line_original,\\\\n            line_count_original=line_count_original,\\\\n            start_line_modified=start_line_modified,\\\\n            line_count_modified=line_count_modified,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def _parse_content_to_code(content: str) -> tuple[str, str]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"content를 파싱하여 original_code와 modified_code를 생성합니다.\\\\n\\\\n        Args:\\\\n            content: diff 내용\\\\n\\\\n        Returns:\\\\n            tuple[str, str]: (original_code, modified_code) 튜플\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        original_lines = []\\\\n        modified_lines = []\\\\n\\\\n        for line in content.splitlines():\\\\n            if not line:\\\\n                continue\\\\n\\\\n            prefix = line[0] if line else \\\\\\\"\\\\\\\"\\\\n            code_part = line[1:] if line else \\\\\\\"\\\\\\\"\\\\n\\\\n            if prefix == \\\\\\\"-\\\\\\\":  # 제거된 라인\\\\n                original_lines.append(code_part)\\\\n            elif prefix == \\\\\\\"+\\\\\\\":  # 추가된 라인\\\\n                modified_lines.append(code_part)\\\\n            elif prefix == \\\\\\\" \\\\\\\":  # 변경되지 않은 컨텍스트 라인\\\\n                original_lines.append(code_part)\\\\n                modified_lines.append(code_part)\\\\n            else:\\\\n                # 표준 diff 형식이 아닌 경우 (방어적 코딩)\\\\n                original_lines.append(line)\\\\n                modified_lines.append(line)\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(original_lines), \\\\\\\"\\\\\\\\n\\\\\\\".join(modified_lines)\\\\n```\\\", \\\"line_number\\\": 6, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"before_code\\\": \\\"```python\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n```\\\", \\\"line_number\\\": 60, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                hunk_content = hunk.content\\\\n                hunk_msg = {\\\\n                    \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                    \\\\\\\"content\\\\\\\": json.dumps(\\\\n                        obj={\\\\n                            \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                            \\\\\\\"file_name\\\\\\\": file_name,\\\\n                            \\\\\\\"content\\\\\\\": f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\",\\\\n                            \\\\\\\"line_number\\\\\\\": hunk.start_line_modified,\\\\n                            \\\\\\\"language\\\\\\\": file.language,\\\\n                        },\\\\n                        ensure_ascii=False,\\\\n                    ),\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.original_code.replace(\\\\\\\"`​``\\\\\\\", \\\\\\\"`\\\\\\\\u200b``\\\\\\\")\\\\n                safe_modified = hunk.modified_code.replace(\\\\\\\"`​``\\\\\\\", \\\\\\\"`\\\\\\\\u200b``\\\\\\\")\\\\n                hunk_msg = {\\\\n                    \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                    \\\\\\\"content\\\\\\\": json.dumps(\\\\n                        obj={\\\\n                            \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                            \\\\\\\"file_name\\\\\\\": file_name,\\\\n                            \\\\\\\"original_code\\\\\\\": f\\\\\\\"`​``{file.language}\\\\\\\\n{safe_original}\\\\\\\\n`​``\\\\\\\",\\\\n                            \\\\\\\"modified_code\\\\\\\": f\\\\\\\"`​``{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n`​``\\\\\\\",\\\\n                            \\\\\\\"line_number\\\\\\\": hunk.start_line_modified,\\\\n                            \\\\\\\"language\\\\\\\": file.language,\\\\n                        },\\\\n                        ensure_ascii=False,\\\\n                    ),\\\\n```\\\", \\\"line_number\\\": 117, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"Git diff 파싱 로직 개선 및 리뷰 프롬프트 생성 방식 변경: Hunk 객체에 원본/수정 코드 필드를 추가하고, diff 파싱 시 컨텍스트 라인을 늘렸으며, 프롬프트 생성 시 코드 블록 구문 충돌을 방지하는 처리를 추가했습니다.\", \"score\": 8.0, \"recommendations\": [\"새로 추가된 `_parse_content_to_code` 메서드에 대한 단위 테스트를 작성하여 다양한 diff 형식(특히 비표준 형식)에 대한 견고성을 확보하는 것이 좋습니다.\", \"`_parse_content_to_code`의 `else` 블록에서 비표준 라인을 처리하는 방식에 대해 더 구체적인 로깅이나 예외 처리를 고려할 수 있습니다. 현재는 단순히 라인을 그대로 추가하고 있어 예상치 못한 결과가 발생할 수 있습니다.\", \"`--unified=5` 옵션 추가는 리뷰에 더 많은 컨텍스트를 제공하여 유용하지만, 매우 큰 diff의 경우 출력 크기가 증가할 수 있습니다. 이 점을 인지하고 필요에 따라 조정할 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"인메모리 테스트 데이터베이스의 타입 안전성을 개선하고, 이에 따라 관련 Mock Repository 코드에서 불필요한 타입 캐스팅 및 필터링 로직을 제거하여 코드를 간결화했습니다. MockUserRepository에서는 사용되지 않는 람다 파라미터를 `_`로 변경하여 가독성을 높였습니다.\", \"score\": 9.0, \"recommendations\": [\"전반적으로 코드가 명확하고 타입 안전성이 향상되었습니다. 현재 변경 사항에 기반한 추가적인 주요 권장 사항은 없습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 46}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"line_number\\\": 152}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\nfrom .token_utils import TokenUtils\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다. `--diff-file` 옵션과 관련된 기능이 제거되었고, `TokenUtils`의 지연 임포트 방식이 일반 임포트로 변경되어 코드 구조가 단순화되었습니다.\", \"score\": 9.0, \"recommendations\": [\"`--diff-file` 옵션 제거에 대한 사용자 문서를 업데이트하세요.\", \"변경 사항이 기존 기능에 영향을 미치지 않는지 확인하기 위해 관련 테스트 케이스를 검토하거나 추가하는 것을 고려하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"코드 변경 사항은 `review_focus` 기능과 관련된 코드(모델 필드, 프롬프트 생성 로직)를 제거합니다. 변경 사항은 관련 파일들에서 일관되게 적용되었으며, 이로 인해 새로운 버그나 문제는 발생하지 않았습니다.\", \"score\": 10.0, \"recommendations\": [\"제거된 기능(`review_focus`)과 관련된 문서나 사용자 가이드가 있다면 함께 업데이트하여 최신 상태를 유지하는 것이 좋습니다.\", \"만약 이 기능이 사용 중이었다면, 제거 결정에 대한 배경이나 대체 방안을 코드 주석이나 커밋 메시지에 명확히 남겨두면 향후 코드 이해에 도움이 될 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/entity/User.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n@Entity\\\\nclass User(\\\\n    @Id\\\\n    val id: UserId,\\\\n    @Embedded\\\\n    val email: Email,\\\\n    name: UserName,\\\\n    password: String,\\\\n    @OneToOne(fetch = FetchType.LAZY)\\\\n    val profile: UserProfile,\\\\n    val createdAt: LocalDateTime = LocalDateTime.now(),\\\\n) {\\\\n    var password = password\\\\n        protected set\\\\n    var updatedAt: LocalDateTime? = null\\\\n\\\\n    @PreUpdate\\\\n    fun preUpdate() {\\\\n        this.updatedAt = LocalDateTime.now()\\\\n    }\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/entity/UserProfile.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.Id\\\\n\\\\n@Entity\\\\nclass UserProfile(\\\\n    @Id\\\\n    val userId: UserId,\\\\n    name: String,\\\\n    bio: String,\\\\n    image: String,\\\\n) {\\\\n    var name = name\\\\n        protected set\\\\n    var bio = bio\\\\n        protected set\\\\n    var image = image\\\\n        protected set\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/vo/UserId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n\\\\n@Embeddable\\\\ndata class UserId(\\\\n    @Column(name = \\\\\\\"id\\\\\\\")\\\\n    val value: UUID = UUID.randomUUID(),\\\\n)\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/vo/UserName.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n@Embeddable\\\\ndata class UserName(\\\\n    val value: String,\\\\n)\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 15, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/entity/User.kt\", \"description\": \"User 클래스의 생성자 매개변수 `name: UserName`이 클래스 내에서 사용되지 않고 버려집니다. 이 매개변수는 어떤 프로퍼티에도 할당되지 않습니다.\", \"suggestion\": \"`name` 매개변수를 클래스 프로퍼티로 할당하거나, 필요 없다면 제거해야 합니다. `UserName`은 `User` 엔티티의 프로퍼티로 사용되는 것이 일반적입니다.\", \"severity\": \"error\", \"target_code\": \"name: UserName,\", \"suggested_code\": \"val name: UserName,\"}, {\"type\": \"security\", \"line_number\": 16, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/entity/User.kt\", \"description\": \"생성자 매개변수로 받은 비밀번호(`password: String`)가 해싱되지 않은 상태로 클래스 프로퍼티에 직접 할당됩니다. 비밀번호는 데이터베이스에 저장하기 전에 반드시 안전하게 해싱되어야 합니다.\", \"suggestion\": \"사용자 생성 또는 비밀번호 변경 시점에 비밀번호를 해싱하는 로직을 추가해야 합니다. 생성자에서는 해싱된 비밀번호를 받거나, 팩토리 메서드 등을 통해 해싱을 처리하는 것이 좋습니다.\", \"severity\": \"error\", \"target_code\": \"password: String,\", \"suggested_code\": null}, {\"type\": \"design\", \"line_number\": 15, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/entity/User.kt\", \"description\": \"`UserName` 값 객체가 정의되어 있지만 `User` 엔티티에서는 사용되지 않고, `UserProfile` 엔티티에서는 이름이 `String` 타입으로 저장됩니다. 도메인 모델 전반에 걸쳐 이름 표현 방식이 일관되지 않습니다.\", \"suggestion\": \"`User` 엔티티에 `UserName` 타입의 프로퍼티를 추가하고, `UserProfile`에서도 이름 필드를 `UserName` 타입으로 변경하여 도메인 모델의 일관성을 유지해야 합니다.\", \"severity\": \"warning\", \"target_code\": \"name: UserName,\", \"suggested_code\": \"val name: UserName,\"}, {\"type\": \"style\", \"line_number\": 67, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/vo/UserName.kt\", \"description\": \"`UserName` 값 객체 생성 시 입력 값(`value: String`)에 대한 유효성 검사(예: 빈 문자열 체크)가 누락되어 있습니다. 값 객체는 스스로 유효한 상태를 보장해야 합니다.\", \"suggestion\": \"생성자 내에서 입력 문자열에 대한 유효성 검사 로직을 추가하여 유효하지 않은 `UserName` 객체가 생성되지 않도록 해야 합니다.\", \"severity\": \"warning\", \"target_code\": \"val value: String,\", \"suggested_code\": \"val value: String,\\n) {\\n    init {\\n        require(value.isNotBlank()) { \\\"User name cannot be blank\\\" }\\n    }\"}, {\"type\": \"design\", \"line_number\": 40, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/entity/UserProfile.kt\", \"description\": \"`UserProfile` 엔티티에서 사용자 이름을 `String` 타입으로 저장하고 있습니다. 이미 `UserName` 값 객체가 정의되어 있으므로 이를 사용하는 것이 도메인 모델의 일관성을 높입니다.\", \"suggestion\": \"`UserProfile`의 `name` 필드 타입을 `String`에서 `UserName`으로 변경해야 합니다.\", \"severity\": \"warning\", \"target_code\": \"name: String,\", \"suggested_code\": \"name: UserName,\"}], \"summary\": \"사용자 및 프로필 엔티티, 값 객체의 초기 정의입니다. 생성자 매개변수 미사용 버그, 비밀번호 평문 저장 보안 문제, 이름 표현의 도메인 모델 불일치, 값 객체의 유효성 검사 누락 등의 개선이 필요합니다.\", \"score\": 4.0, \"recommendations\": [\"사용자 비밀번호는 저장 전에 반드시 안전한 해싱 알고리즘(예: BCrypt)을 사용하여 해싱해야 합니다.\", \"`User` 엔티티와 `UserProfile` 엔티티 모두 사용자 이름을 나타낼 때 `UserName` 값 객체를 일관되게 사용하도록 리팩토링하세요.\", \"`UserName`과 같은 값 객체에는 생성 시점에 유효성을 검사하는 로직을 추가하여 항상 유효한 상태를 유지하도록 해야 합니다.\", \"엔티티 생성 시 복잡한 초기화 로직(예: 비밀번호 해싱)이 필요한 경우, 생성자 대신 팩토리 메서드나 빌더 패턴을 사용하는 것을 고려해 볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/hunk.py\\\", \\\"before_code\\\": \\\"```python\\\\nclass Hunk:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff의 hunk를 나타내는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    header: str\\\\n    content: str\\\\n    start_line_original: int\\\\n    line_count_original: int\\\\n    start_line_modified: int\\\\n    line_count_modified: int\\\\n\\\\n    @staticmethod\\\\n    def from_hunk_text(hunk_text: str) -> \\\\\\\"Hunk\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"hunk 텍스트로부터 Hunk 객체를 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        lines = hunk_text.split(\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n        header = lines[0]\\\\n        content = \\\\\\\"\\\\\\\\n\\\\\\\".join(lines[1:])\\\\n\\\\n        # @@ -73,7 +73,7 @@ 형식에서 라인 정보 추출\\\\n        header_match = re.match(r\\\\\\\"@@ -(\\\\\\\\d+),(\\\\\\\\d+) \\\\\\\\+(\\\\\\\\d+),(\\\\\\\\d+) @@\\\\\\\", header)\\\\n        if header_match:\\\\n            start_line_original = int(header_match.group(1))\\\\n            line_count_original = int(header_match.group(2))\\\\n            start_line_modified = int(header_match.group(3))\\\\n            line_count_modified = int(header_match.group(4))\\\\n        else:\\\\n            # 헤더 형식이 예상과 다른 경우 기본값 사용\\\\n            start_line_original = 0\\\\n            line_count_original = 0\\\\n            start_line_modified = 0\\\\n            line_count_modified = 0\\\\n\\\\n        return Hunk(\\\\n            header=header,\\\\n            content=content,\\\\n            start_line_original=start_line_original,\\\\n            line_count_original=line_count_original,\\\\n            start_line_modified=start_line_modified,\\\\n            line_count_modified=line_count_modified,\\\\n        )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nclass Hunk:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff의 hunk를 나타내는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    header: str\\\\n    content: str\\\\n    original_code: str\\\\n    modified_code: str\\\\n    start_line_original: int\\\\n    line_count_original: int\\\\n    start_line_modified: int\\\\n    line_count_modified: int\\\\n\\\\n    @staticmethod\\\\n    def from_hunk_text(hunk_text: str) -> \\\\\\\"Hunk\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"hunk 텍스트로부터 Hunk 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            hunk_text: git diff의 hunk 텍스트\\\\n\\\\n        Returns:\\\\n            Hunk: Hunk 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        lines = hunk_text.split(\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n        header = lines[0]\\\\n        content = \\\\\\\"\\\\\\\\n\\\\\\\".join(lines[1:])\\\\n\\\\n        header_match = re.match(r\\\\\\\"@@ -(\\\\\\\\d+),(\\\\\\\\d+) \\\\\\\\+(\\\\\\\\d+),(\\\\\\\\d+) @@\\\\\\\", header)\\\\n        if header_match:\\\\n            start_line_original = int(header_match.group(1))\\\\n            line_count_original = int(header_match.group(2))\\\\n            start_line_modified = int(header_match.group(3))\\\\n            line_count_modified = int(header_match.group(4))\\\\n        else:\\\\n            start_line_original = 0\\\\n            line_count_original = 0\\\\n            start_line_modified = 0\\\\n            line_count_modified = 0\\\\n\\\\n        original_code, modified_code = Hunk._parse_content_to_code(content)\\\\n\\\\n        return Hunk(\\\\n            header=header,\\\\n            content=content,\\\\n            original_code=original_code,\\\\n            modified_code=modified_code,\\\\n            start_line_original=start_line_original,\\\\n            line_count_original=line_count_original,\\\\n            start_line_modified=start_line_modified,\\\\n            line_count_modified=line_count_modified,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def _parse_content_to_code(content: str) -> tuple[str, str]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"content를 파싱하여 original_code와 modified_code를 생성합니다.\\\\n\\\\n        Args:\\\\n            content: diff 내용\\\\n\\\\n        Returns:\\\\n            tuple[str, str]: (original_code, modified_code) 튜플\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        original_lines = []\\\\n        modified_lines = []\\\\n\\\\n        for line in content.splitlines():\\\\n            if not line:\\\\n                continue\\\\n\\\\n            prefix = line[0] if line else \\\\\\\"\\\\\\\"\\\\n            code_part = line[1:] if line else \\\\\\\"\\\\\\\"\\\\n\\\\n            if prefix == \\\\\\\"-\\\\\\\":  # 제거된 라인\\\\n                original_lines.append(code_part)\\\\n            elif prefix == \\\\\\\"+\\\\\\\":  # 추가된 라인\\\\n                modified_lines.append(code_part)\\\\n            elif prefix == \\\\\\\" \\\\\\\":  # 변경되지 않은 컨텍스트 라인\\\\n                original_lines.append(code_part)\\\\n                modified_lines.append(code_part)\\\\n            else:\\\\n                # 표준 diff 형식이 아닌 경우 (방어적 코딩)\\\\n                original_lines.append(line)\\\\n                modified_lines.append(line)\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(original_lines), \\\\\\\"\\\\\\\\n\\\\\\\".join(modified_lines)\\\\n```\\\", \\\"line_number\\\": 6, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"before_code\\\": \\\"```python\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n```\\\", \\\"line_number\\\": 60, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                hunk_content = hunk.content\\\\n                hunk_msg = {\\\\n                    \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                    \\\\\\\"content\\\\\\\": json.dumps(\\\\n                        obj={\\\\n                            \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                            \\\\\\\"file_name\\\\\\\": file_name,\\\\n                            \\\\\\\"content\\\\\\\": f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\",\\\\n                            \\\\\\\"line_number\\\\\\\": hunk.start_line_modified,\\\\n                            \\\\\\\"language\\\\\\\": file.language,\\\\n                        },\\\\n                        ensure_ascii=False,\\\\n                    ),\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.original_code.replace(\\\\\\\"`​``\\\\\\\", \\\\\\\"`\\\\\\\\u200b``\\\\\\\")\\\\n                safe_modified = hunk.modified_code.replace(\\\\\\\"`​``\\\\\\\", \\\\\\\"`\\\\\\\\u200b``\\\\\\\")\\\\n                hunk_msg = {\\\\n                    \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                    \\\\\\\"content\\\\\\\": json.dumps(\\\\n                        obj={\\\\n                            \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                            \\\\\\\"file_name\\\\\\\": file_name,\\\\n                            \\\\\\\"original_code\\\\\\\": f\\\\\\\"`​``{file.language}\\\\\\\\n{safe_original}\\\\\\\\n`​``\\\\\\\",\\\\n                            \\\\\\\"modified_code\\\\\\\": f\\\\\\\"`​``{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n`​``\\\\\\\",\\\\n                            \\\\\\\"line_number\\\\\\\": hunk.start_line_modified,\\\\n                            \\\\\\\"language\\\\\\\": file.language,\\\\n                        },\\\\n                        ensure_ascii=False,\\\\n                    ),\\\\n```\\\", \\\"line_number\\\": 117, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"Git diff 파싱 로직 개선 및 리뷰 프롬프트 생성 방식 변경: Hunk 객체에 원본/수정 코드 필드를 추가하고, diff 파싱 시 컨텍스트 라인을 늘렸으며, 프롬프트 생성 시 코드 블록 구문 충돌을 방지하는 처리를 추가했습니다.\", \"score\": 8.0, \"recommendations\": [\"새로 추가된 `_parse_content_to_code` 메서드에 대한 단위 테스트를 작성하여 다양한 diff 형식(특히 비표준 형식)에 대한 견고성을 확보하는 것이 좋습니다.\", \"`_parse_content_to_code`의 `else` 블록에서 비표준 라인을 처리하는 방식에 대해 더 구체적인 로깅이나 예외 처리를 고려할 수 있습니다. 현재는 단순히 라인을 그대로 추가하고 있어 예상치 못한 결과가 발생할 수 있습니다.\", \"`--unified=5` 옵션 추가는 리뷰에 더 많은 컨텍스트를 제공하여 유용하지만, 매우 큰 diff의 경우 출력 크기가 증가할 수 있습니다. 이 점을 인지하고 필요에 따라 조정할 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"requirements.txt\\\", \\\"file_content\\\": \\\"requests==2.31.0\\\\npydantic==2.6.1\\\\npython-dotenv==1.0.0\\\\nopenai>=1.0.0\\\\nanthropic>=0.5.1\\\\ntiktoken==0.5.2\\\\nstreamlit>=1.32.0 \\\\ninstructor>=1.7.7\\\\ngoogle-generativeai==0.3.1\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```text\\\\ninstructor>=1.7.7\\\\n\\\\\\\\ No newline at end of file\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\ninstructor>=1.7.7\\\\ngoogle-generativeai==0.3.1\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 모듈\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport instructor\\\\nfrom anthropic import Anthropic\\\\nfrom google import genai\\\\nfrom openai import OpenAI\\\\n\\\\n\\\\nclass LLMClientFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"provider와 api_key를 기반으로 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            provider: LLM 제공자 ('openai', 'claude', 'google')\\\\n            api_key: API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if provider == \\\\\\\"openai\\\\\\\":\\\\n            return LLMClientFactory._create_openai_client(api_key)\\\\n        elif provider == \\\\\\\"claude\\\\\\\":\\\\n            return LLMClientFactory._create_claude_client(api_key)\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return LLMClientFactory._create_gemini_client(api_key)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 제공자입니다: {provider}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def _create_openai_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: OpenAI API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: OpenAI 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = OpenAI(api_key=api_key)\\\\n        return instructor.from_openai(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_claude_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Anthropic API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: Claude 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = Anthropic(api_key=api_key)\\\\n        return instructor.from_anthropic(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_gemini_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Google API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: Gemini 클라이언트 (instructor 래핑)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = genai.Client(api_key=api_key)\\\\n        return instructor.from_google(client)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom anthropic import Anthropic\\\\nfrom google import genai\\\\nfrom openai import OpenAI\\\\n```\\\", \\\"line_number\\\": 4}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로바이더에 맞는, 구조화된 응답을 지원하는 클라이언트를 생성합니다.\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"provider와 api_key를 기반으로 LLM 클라이언트를 생성합니다.\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n            provider: LLM 프로바이더 (openai 또는 claude)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            provider: LLM 제공자 ('openai', 'claude', 'google')\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n            Instructor: instructor 래핑된 LLM 클라이언트\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 프로바이더인 경우\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            instructor.Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```python\\\\n            from openai import OpenAI\\\\n\\\\n            return instructor.from_openai(OpenAI(api_key=api_key))\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            return LLMClientFactory._create_openai_client(api_key)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"before_code\\\": \\\"```python\\\\n            from anthropic import Anthropic\\\\n\\\\n            return instructor.from_anthropic(Anthropic(api_key=api_key))\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            return LLMClientFactory._create_claude_client(api_key)\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return LLMClientFactory._create_gemini_client(api_key)\\\\n```\\\", \\\"line_number\\\": 26}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"before_code\\\": \\\"```python\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 프로바이더입니다: {provider}\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 제공자입니다: {provider}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def _create_openai_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: OpenAI API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: OpenAI 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = OpenAI(api_key=api_key)\\\\n        return instructor.from_openai(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_claude_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Anthropic API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: Claude 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = Anthropic(api_key=api_key)\\\\n        return instructor.from_anthropic(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_gemini_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Google API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: Gemini 클라이언트 (instructor 래핑)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = genai.Client(api_key=api_key)\\\\n        return instructor.from_google(client)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 63}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 71}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n```\\\", \\\"line_number\\\": 103}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 116}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"Google Gemini 모델 지원 추가: `requirements.txt`에 `google-generativeai` 라이브러리가 추가되었고, CLI 인수 파싱, 설정 관리, 사용 가능한 모델 목록, LLM 게이트웨이 팩토리, LLM 클라이언트 팩토리, 토큰 유틸리티 등 코드베이스 전반에 걸쳐 Google 모델 관련 로직이 통합되었습니다. 전반적으로 기존 구조에 맞춰 새로운 제공자 지원이 잘 구현되었습니다.\", \"score\": 9.0, \"recommendations\": [\"새로 추가된 Google Gemini 모델 지원에 대한 단위 테스트를 추가하여 기능의 안정성을 확보하는 것이 좋습니다.\", \"`TokenUtils.estimate_cost`에서 명시적으로 가격이 정의되지 않은 Gemini 모델에 대한 fallback 가격 정책을 검토해 볼 수 있습니다. 현재는 Flash 모델 가격을 기본으로 사용하는데, 다른 모델의 경우 비용이 과소 추정될 수 있습니다. (선택 사항)\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"legacy_tests/conftest.py\\\", \\\"before_code\\\": \\\"```python\\\\n        },\\\\n        file_paths=[\\\\\\\"sample.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 품질\\\\\\\",\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        },\\\\n        file_paths=[\\\\\\\"sample.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 품질\\\\\\\",\\\\n    )\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 153, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"resources/prompt/v1/code_review_system_prompt.txt\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\\\n\\\\n파일명과 라인 번호는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, 라인 번호는 정확한 숫자를 사용하세요. 파일명을 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\\\n\\\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\\\n\\\\n파일명과 라인 번호는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, 수정 행 번호는 start_line을 참조해 표기해주세요. 파일명이나 라인 번호 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\\\n\\\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\\\n\\\\n```\\\", \\\"line_number\\\": 29, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"resources/prompt/v1/code_review_system_prompt.txt\\\", \\\"before_code\\\": \\\"```text\\\\n  \\\\\\\"issues\\\\\\\": [\\\\n    {\\\\n      \\\\\\\"type\\\\\\\": \\\\\\\"이슈 유형\\\\\\\",\\\\n      \\\\\\\"line\\\\\\\": 라인번호,\\\\n      \\\\\\\"file\\\\\\\": \\\\\\\"파일명\\\\\\\",\\\\n      \\\\\\\"description\\\\\\\": \\\\\\\"이슈 설명\\\\\\\",\\\\n      \\\\\\\"suggestion\\\\\\\": \\\\\\\"개선 제안\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n  \\\\\\\"issues\\\\\\\": [\\\\n    {\\\\n      \\\\\\\"type\\\\\\\": \\\\\\\"이슈 유형\\\\\\\",\\\\n      \\\\\\\"line_number\\\\\\\": 수정 행 번호, 프롬프트의 start_line_number 참조해서 표시,\\\\n      \\\\\\\"file\\\\\\\": \\\\\\\"파일명\\\\\\\",\\\\n      \\\\\\\"description\\\\\\\": \\\\\\\"이슈 설명\\\\\\\",\\\\n      \\\\\\\"suggestion\\\\\\\": \\\\\\\"개선 제안\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 38, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n        processed_diff=diff_result.to_dict(),\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        language=next(iter(diff_result.to_dict()[\\\\\\\"language_stats\\\\\\\"]), None),\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        processed_diff=diff_result.to_dict(),\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n```\\\", \\\"line_number\\\": 465, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\", [\\\\\\\"리뷰 결과\\\\\\\", \\\\\\\"응답 로그\\\\\\\", \\\\\\\"리뷰 요청\\\\\\\", \\\\\\\"프롬프트\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\", [\\\\\\\"리뷰 결과\\\\\\\", \\\\\\\"응답 로그\\\\\\\", \\\\\\\"reviewRequest\\\\\\\", \\\\\\\"프롬프트\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n```\\\", \\\"line_number\\\": 126, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"리뷰 요청\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 155, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n                        else:\\\\n                            for i, issue in enumerate(issues, 1):\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{i}. {issue.get('type', '유형 없음')} - {issue.get('file', '파일 없음')}:{issue.get('line', 'N/A')}\\\\\\\"\\\\n                                ):\\\\n                                    st.markdown(\\\\n                                        f\\\\\\\"**심각도**: {issue.get('severity', 'info')}\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                        else:\\\\n                            for i, issue in enumerate(issues, 1):\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{i}. {issue.get('type', '유형 없음')} - {issue.get('file', '파일 없음')}:{issue.get('line_number', 'N/A')}\\\\\\\"\\\\n                                ):\\\\n                                    st.markdown(\\\\n                                        f\\\\\\\"**심각도**: {issue.get('severity', 'info')}\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 242, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"리뷰 요청\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## 리뷰 요청 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                else:  # 프롬프트\\\\n                    # 프롬프트 데이터를 raw JSON으로 표시\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                else:  # 프롬프트\\\\n                    # 프롬프트 데이터를 raw JSON으로 표시\\\\n```\\\", \\\"line_number\\\": 279, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n    def _get_language_prompt(self, language: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"언어 정보 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            language: 언어 정보\\\\n\\\\n        Returns:\\\\n            str: 언어 정보 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n코드는 {language} 언어로 작성되었습니다.\\\\\\\"\\\\n\\\\n    def _get_file_paths_prompt(self, file_paths: list[str]) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일 목록 프롬프트를 반환합니다.\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n    def _get_file_paths_prompt(self, file_paths: list[str]) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일 목록 프롬프트를 반환합니다.\\\\n\\\\n```\\\", \\\"line_number\\\": 75, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        if review_request.review_focus:\\\\n            system_prompt += self._get_review_focus_prompt(review_request.review_focus)\\\\n\\\\n        # 언어 정보가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.language:\\\\n            system_prompt += self._get_language_prompt(review_request.language)\\\\n\\\\n        # 파일 목록이 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.file_paths and len(review_request.file_paths) > 0:\\\\n            system_prompt += self._get_file_paths_prompt(review_request.file_paths)\\\\n\\\\n        messages = [{\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": system_prompt}]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        if review_request.review_focus:\\\\n            system_prompt += self._get_review_focus_prompt(review_request.review_focus)\\\\n\\\\n        # 파일 목록이 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.file_paths:\\\\n            system_prompt += self._get_file_paths_prompt(review_request.file_paths)\\\\n\\\\n        messages = [{\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": system_prompt}]\\\\n```\\\", \\\"line_number\\\": 107, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n                                \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                \\\\\\\"content\\\\\\\": hunk_msg,\\\\n                                \\\\\\\"start_line_original\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_original\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"line_count_original\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"line_count_original\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"start_line_modified\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"line_count_modified\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"line_count_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                            }\\\\n                        )\\\\n            case _:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                                \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                \\\\\\\"content\\\\\\\": hunk_msg,\\\\n                                \\\\\\\"start_line_number\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"language\\\\\\\": file_info.get(\\\\\\\"language\\\\\\\", \\\\\\\"\\\\\\\"),\\\\n                            }\\\\n                        )\\\\n            case _:\\\\n```\\\", \\\"line_number\\\": 141, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"before_code\\\": \\\"```python\\\\n    )\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    language: Optional[str] = None\\\\n    additional_context: Optional[str] = None\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    )\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    additional_context: Optional[str] = None\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 13, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n    return ReviewRequest(\\\\n        diff_content=\\\\\\\"diff --git a/file.py b/file.py\\\\\\\\nindex 1234..5678 100644\\\\\\\\n--- a/file.py\\\\\\\\n+++ b/file.py\\\\\\\\n@@ -1,3 +1,4 @@\\\\\\\\n+print('Hello')\\\\\\\\n print('World')\\\\\\\\n\\\\\\\",\\\\n        file_paths=[\\\\\\\"file.py\\\\\\\"],\\\\n        language=\\\\\\\"Python\\\\\\\",\\\\n        review_focus=\\\\\\\"코드 구조\\\\\\\",\\\\n        additional_context=\\\\\\\"테스트 컨텍스트\\\\\\\",\\\\n        processed_diff={\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    return ReviewRequest(\\\\n        diff_content=\\\\\\\"diff --git a/file.py b/file.py\\\\\\\\nindex 1234..5678 100644\\\\\\\\n--- a/file.py\\\\\\\\n+++ b/file.py\\\\\\\\n@@ -1,3 +1,4 @@\\\\\\\\n+print('Hello')\\\\\\\\n print('World')\\\\\\\\n\\\\\\\",\\\\n        file_paths=[\\\\\\\"file.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 구조\\\\\\\",\\\\n        additional_context=\\\\\\\"테스트 컨텍스트\\\\\\\",\\\\n        processed_diff={\\\\n```\\\", \\\"line_number\\\": 13, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        assert messages[0][\\\\\\\"role\\\\\\\"] == \\\\\\\"system\\\\\\\"\\\\n        assert \\\\\\\"Mock system prompt\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"특별히 다음 측면에 집중하세요: 코드 구조\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"코드는 Python 언어로 작성되었습니다.\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"변경된 파일 목록:\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n\\\\n        # 프로세스된 diff가 올바르게 처리되었는지 확인\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        assert messages[0][\\\\\\\"role\\\\\\\"] == \\\\\\\"system\\\\\\\"\\\\n        assert \\\\\\\"Mock system prompt\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"특별히 다음 측면에 집중하세요: 코드 구조\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"변경된 파일 목록:\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n\\\\n        # 프로세스된 diff가 올바르게 처리되었는지 확인\\\\n```\\\", \\\"line_number\\\": 87, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 129, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 요소에서 한국어와 영어가 혼용되어 사용되고 있습니다. '리뷰 요청' 대신 'reviewRequest'와 같은 영어 표현이 사용되어 사용자 경험의 일관성을 해칠 수 있습니다.\", \"suggestion\": \"UI 요소의 언어를 일관되게 유지하세요. 한국어 사용자를 대상으로 한다면 '리뷰 요청'과 같은 한국어 용어를 사용하는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"st.sidebar.markdown(f\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\")\", \"suggested_code\": \"st.sidebar.markdown(f\\\"**리뷰 요청 저장 위치**: {request_dir}\\\")\"}, {\"type\": \"style\", \"line_number\": 132, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 요소에서 한국어와 영어가 혼용되어 사용되고 있습니다. '리뷰 요청' 대신 'reviewRequest'와 같은 영어 표현이 사용되어 사용자 경험의 일관성을 해칠 수 있습니다.\", \"suggestion\": \"UI 요소의 언어를 일관되게 유지하세요. 한국어 사용자를 대상으로 한다면 '리뷰 요청'과 같은 한국어 용어를 사용하는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"\\\"reviewRequest\\\"\", \"suggested_code\": \"\\\"리뷰 요청\\\"\"}, {\"type\": \"style\", \"line_number\": 158, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 요소에서 한국어와 영어가 혼용되어 사용되고 있습니다. '리뷰 요청' 대신 'reviewRequest'와 같은 영어 표현이 사용되어 사용자 경험의 일관성을 해칠 수 있습니다.\", \"suggestion\": \"UI 요소의 언어를 일관되게 유지하세요. 한국어 사용자를 대상으로 한다면 '리뷰 요청'과 같은 한국어 용어를 사용하는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"elif view_type == \\\"reviewRequest\\\":\", \"suggested_code\": \"elif view_type == \\\"리뷰 요청\\\":\"}, {\"type\": \"style\", \"line_number\": 282, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 요소에서 한국어와 영어가 혼용되어 사용되고 있습니다. '리뷰 요청' 대신 'reviewRequest'와 같은 영어 표현이 사용되어 사용자 경험의 일관성을 해칠 수 있습니다.\", \"suggestion\": \"UI 요소의 언어를 일관되게 유지하세요. 한국어 사용자를 대상으로 한다면 '리뷰 요청'과 같은 한국어 용어를 사용하는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"st.markdown(\\\"## reviewRequest 내용\\\")\", \"suggested_code\": \"st.markdown(\\\"## 리뷰 요청 내용\\\")\"}], \"summary\": \"리뷰 요청 모델에서 언어 필드를 제거하고 관련 로직을 정리했습니다. 프롬프트 텍스트와 UI에서 라인 번호 표기 방식을 'line'에서 'line_number'로 변경했습니다. UI 일부에서 '리뷰 요청'이라는 한국어 표현을 'reviewRequest'라는 영어 표현으로 변경했습니다.\", \"score\": 7.0, \"recommendations\": [\"사용자 인터페이스(UI) 전반에 걸쳐 사용되는 언어(한국어/영어)를 일관되게 유지하여 사용자 경험을 개선하세요. 한국어 사용자를 대상으로 한다면 '리뷰 요청'과 같은 한국어 용어를 사용하는 것이 더 자연스럽습니다.\", \"리뷰 요청 모델에서 언어 필드를 제거한 변경이 모델의 리뷰 품질에 영향을 미치지 않는지 확인하는 테스트를 고려해 볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"legacy_tests/test_diff_parser.py\\\", \\\"before_code\\\": \\\"```python\\\\nimport pytest\\\\nimport os\\\\nimport subprocess\\\\nfrom unittest.mock import MagicMock, patch\\\\nfrom reviewer.src.diff_parser.parser import split_git_diff, run_git_diff, parse_git_diff\\\\nfrom reviewer.src.diff_parser.models import DiffResult, FileDiff\\\\n\\\\n\\\\ndef read_diff_file(filename):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트용 diff 파일을 읽습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    with open(os.path.join(\\\\\\\"tests/sample_data\\\\\\\", filename), \\\\\\\"r\\\\\\\") as f:\\\\n        return f.read()\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport os\\\\nimport subprocess\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nfrom reviewer.src.diff_parser.models import DiffResult, FileDiff\\\\nfrom reviewer.src.diff_parser.parser import parse_git_diff, run_git_diff, split_git_diff\\\\n\\\\n\\\\ndef read_diff_file(filename):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트용 diff 파일을 읽습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    with open(os.path.join(\\\\\\\"tests/sample_data\\\\\\\", filename)) as f:\\\\n        return f.read()\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"pyproject.toml\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n[tool.ruff]\\\\nline-length = 88\\\\nselect = [\\\\\\\"E\\\\\\\", \\\\\\\"F\\\\\\\", \\\\\\\"I\\\\\\\", \\\\\\\"B\\\\\\\", \\\\\\\"C4\\\\\\\", \\\\\\\"ARG\\\\\\\", \\\\\\\"N\\\\\\\", \\\\\\\"UP\\\\\\\", \\\\\\\"ANN\\\\\\\", \\\\\\\"S\\\\\\\", \\\\\\\"A\\\\\\\"]\\\\n\\\\n[tool.ruff.lint.per-file-ignores]\\\\n\\\\\\\"tests/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\n[tool.ruff]\\\\nline-length = 88\\\\nselect = [\\\\\\\"E\\\\\\\", \\\\\\\"F\\\\\\\", \\\\\\\"I\\\\\\\", \\\\\\\"B\\\\\\\", \\\\\\\"C4\\\\\\\", \\\\\\\"ARG\\\\\\\", \\\\\\\"N\\\\\\\", \\\\\\\"UP\\\\\\\", \\\\\\\"ANN\\\\\\\", \\\\\\\"S\\\\\\\", \\\\\\\"A\\\\\\\", \\\\\\\"ANN401\\\\\\\"]\\\\n\\\\n[tool.ruff.lint.per-file-ignores]\\\\n\\\\\\\"tests/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 20, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"resources/prompt/v1/code_review_system_prompt.txt\\\", \\\"before_code\\\": \\\"```text\\\\n  \\\\\\\"issues\\\\\\\": [\\\\n    {\\\\n      \\\\\\\"type\\\\\\\": \\\\\\\"이슈 유형\\\\\\\",\\\\n      \\\\\\\"line_number\\\\\\\": 수정 행 번호\\\\n      \\\\\\\"file\\\\\\\": \\\\\\\"파일명\\\\\\\",\\\\n      \\\\\\\"description\\\\\\\": \\\\\\\"이슈 설명\\\\\\\",\\\\n      \\\\\\\"suggestion\\\\\\\": \\\\\\\"개선 제안\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n  \\\\\\\"issues\\\\\\\": [\\\\n    {\\\\n      \\\\\\\"type\\\\\\\": \\\\\\\"이슈 유형\\\\\\\",\\\\n      \\\\\\\"line_number\\\\\\\": 라인 번호\\\\n      \\\\\\\"file\\\\\\\": \\\\\\\"파일명\\\\\\\",\\\\n      \\\\\\\"description\\\\\\\": \\\\\\\"이슈 설명\\\\\\\",\\\\n      \\\\\\\"suggestion\\\\\\\": \\\\\\\"개선 제안\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 39, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result.to_dict(),\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n    )\\\\n```\\\", \\\"line_number\\\": 462, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/file_diff.py\\\", \\\"before_code\\\": \\\"```python\\\\nimport os\\\\nfrom dataclasses import dataclass, field\\\\nfrom typing import Optional\\\\n\\\\nfrom .hunk import Hunk\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport os\\\\nfrom dataclasses import dataclass, field\\\\n\\\\nfrom .hunk import Hunk\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/file_diff.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n    filename: str\\\\n    hunks: list[Hunk] = field(default_factory=list)\\\\n    language: Optional[str] = None\\\\n    additions: int = 0\\\\n    deletions: int = 0\\\\n\\\\n    def calculate_changes(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일의 추가/삭제 라인 수를 계산합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.additions = 0\\\\n        self.deletions = 0\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n    filename: str\\\\n    hunks: list[Hunk] = field(default_factory=list)\\\\n    language: str | None = None\\\\n    additions: int = 0\\\\n    deletions: int = 0\\\\n\\\\n    def calculate_changes(self) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일의 추가/삭제 라인 수를 계산합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.additions = 0\\\\n        self.deletions = 0\\\\n```\\\", \\\"line_number\\\": 10, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/file_diff.py\\\", \\\"before_code\\\": \\\"```python\\\\n                elif line.startswith(\\\\\\\"-\\\\\\\") and not line.startswith(\\\\\\\"---\\\\\\\"):\\\\n                    self.deletions += 1\\\\n\\\\n    def detect_language(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일 확장자를 기반으로 언어를 감지합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        ext_to_lang = {\\\\n            \\\\\\\".py\\\\\\\": \\\\\\\"python\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                elif line.startswith(\\\\\\\"-\\\\\\\") and not line.startswith(\\\\\\\"---\\\\\\\"):\\\\n                    self.deletions += 1\\\\n\\\\n    def detect_language(self) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일 확장자를 기반으로 언어를 감지합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        ext_to_lang = {\\\\n            \\\\\\\".py\\\\\\\": \\\\\\\"python\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 26, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/hunk.py\\\", \\\"before_code\\\": \\\"```python\\\\n    start_line_modified: int\\\\n    line_count_modified: int\\\\n\\\\n    @classmethod\\\\n    def from_hunk_text(cls, hunk_text: str) -> \\\\\\\"Hunk\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"hunk 텍스트로부터 Hunk 객체를 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        lines = hunk_text.split(\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n        header = lines[0]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    start_line_modified: int\\\\n    line_count_modified: int\\\\n\\\\n    @staticmethod\\\\n    def from_hunk_text(hunk_text: str) -> \\\\\\\"Hunk\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"hunk 텍스트로부터 Hunk 객체를 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        lines = hunk_text.split(\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n        header = lines[0]\\\\n```\\\", \\\"line_number\\\": 13, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/models/hunk.py\\\", \\\"before_code\\\": \\\"```python\\\\n            start_line_modified = 0\\\\n            line_count_modified = 0\\\\n\\\\n        return cls(\\\\n            header=header,\\\\n            content=content,\\\\n            start_line_original=start_line_original,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            start_line_modified = 0\\\\n            line_count_modified = 0\\\\n\\\\n        return Hunk(\\\\n            header=header,\\\\n            content=content,\\\\n            start_line_original=start_line_original,\\\\n```\\\", \\\"line_number\\\": 34, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"before_code\\\": \\\"```python\\\\nimport re\\\\nimport subprocess\\\\nfrom typing import Any, Dict, List\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n\\\\ndef split_git_diff(diff_text: str) -> Dict[str, List[str]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파일별로 분할하고 각 파일의 변경사항(hunks)을 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n\\\\n    Returns:\\\\n        Dict[str, List[str]]: 파일명을 키로 하고, 해당 파일의 변경사항(hunks) 리스트를 값으로 하는 딕셔너리\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 파일 단위로 분할 (각 파일의 diff는 \\\\\\\"diff --git\\\\\\\" 헤더로 시작)\\\\n    file_diffs = re.split(r\\\\\\\"(?=^diff --git)\\\\\\\", diff_text, flags=re.MULTILINE)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport re\\\\nimport subprocess\\\\nfrom typing import Any\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n\\\\ndef split_git_diff(diff_text: str) -> dict[str, list[str]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파일별로 분할하고 각 파일의 변경사항(hunks)을 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n\\\\n    Returns:\\\\n        dict[str, list[str]]: 파일명을 키로 하고, 해당 파일의 변경사항(hunks) 리스트를 값으로 하는 딕셔너리\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 파일 단위로 분할 (각 파일의 diff는 \\\\\\\"diff --git\\\\\\\" 헤더로 시작)\\\\n    file_diffs = re.split(r\\\\\\\"(?=^diff --git)\\\\\\\", diff_text, flags=re.MULTILINE)\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 4, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n            system_prompt += self._get_file_paths_prompt(review_request.file_paths)\\\\n\\\\n        messages = [{\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": system_prompt}]\\\\n        # 가공된 diff 데이터가 있으면 활용하여 각 파일/hunk별로 컨텍스트 구성\\\\n        match review_request.processed_diff:\\\\n            case dict() as diff if diff:\\\\n                files = diff.get(\\\\\\\"files\\\\\\\", [])\\\\n\\\\n                # 각 파일에 대한 메시지 생성\\\\n                for _, file_info in enumerate(files):\\\\n                    file_name = file_info.get(\\\\\\\"filename\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                    if not file_name:\\\\n                        raise ValueError(\\\\\\\"파일명이 없습니다.\\\\\\\")\\\\n\\\\n                    if file_name and file_name not in review_request.file_paths:\\\\n                        review_request.file_paths.append(file_name)\\\\n\\\\n                    hunks = file_info.get(\\\\\\\"hunks\\\\\\\", [])\\\\n                    for hunk_idx, hunk in enumerate(hunks):\\\\n                        hunk_content = hunk.get(\\\\\\\"content\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                        if not hunk_content:\\\\n                            continue\\\\n\\\\n                        hunk_msg = {\\\\n                            \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                            \\\\\\\"content\\\\\\\": json.dumps(\\\\n                                obj={\\\\n                                    \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                    \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                    \\\\\\\"content\\\\\\\": f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\",\\\\n                                    \\\\\\\"line_number\\\\\\\": str(\\\\n                                        hunk.get(\\\\\\\"start_line_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                    ),\\\\n                                    \\\\\\\"language\\\\\\\": file_info.get(\\\\\\\"language\\\\\\\", \\\\\\\"\\\\\\\"),\\\\n                                },\\\\n                                ensure_ascii=False,\\\\n                            ),\\\\n                        }\\\\n                        messages.append(hunk_msg)\\\\n            case _:\\\\n                raise ValueError(\\\\\\\"processed_diff가 올바른 형식이 아닙니다.\\\\\\\")\\\\n\\\\n        return messages\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            system_prompt += self._get_file_paths_prompt(review_request.file_paths)\\\\n\\\\n        messages = [{\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": system_prompt}]\\\\n        if isinstance(review_request.processed_diff, DiffResult):\\\\n            for file in review_request.processed_diff.files:\\\\n                file_name = file.filename\\\\n                if file_name not in review_request.file_paths:\\\\n                    review_request.file_paths.append(file_name)\\\\n\\\\n                for hunk_idx, hunk in enumerate(file.hunks):\\\\n                    hunk_content = hunk.content\\\\n                    hunk_msg = {\\\\n                        \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                        \\\\\\\"content\\\\\\\": json.dumps(\\\\n                            obj={\\\\n                                \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                \\\\\\\"content\\\\\\\": f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\",\\\\n                                \\\\\\\"line_number\\\\\\\": hunk.start_line_modified,\\\\n                                \\\\\\\"language\\\\\\\": file.language,\\\\n                            },\\\\n                            ensure_ascii=False,\\\\n                        ),\\\\n                    }\\\\n                    messages.append(hunk_msg)\\\\n\\\\n        return messages\\\\n```\\\", \\\"line_number\\\": 114, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"before_code\\\": \\\"```python\\\\nfrom enum import Enum\\\\nfrom typing import Any, Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: Optional[dict[str, Any]] = (\\\\n        None  # 가공된 diff 데이터를 저장하는 필드\\\\n    )\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    additional_context: Optional[str] = None\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    additional_context: Optional[str] = None\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\nfrom reviewer.src.diff_parser.models.file_diff import FileDiff\\\\nfrom reviewer.src.diff_parser.models.hunk import Hunk\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n```\\\", \\\"line_number\\\": 4, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        file_paths=[\\\\\\\"file.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 구조\\\\\\\",\\\\n        additional_context=\\\\\\\"테스트 컨텍스트\\\\\\\",\\\\n        processed_diff={\\\\n            \\\\\\\"files\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"filename\\\\\\\": \\\\\\\"file.py\\\\\\\",\\\\n                    \\\\\\\"hunks\\\\\\\": [\\\\n                        {\\\\n                            \\\\\\\"content\\\\\\\": \\\\\\\"@@ -1,3 +1,4 @@\\\\\\\\n+print('Hello')\\\\\\\\n print('World')\\\\\\\\n\\\\\\\",\\\\n                            \\\\\\\"start_line\\\\\\\": 1,\\\\n                            \\\\\\\"line_count\\\\\\\": 4,\\\\n                        }\\\\n                    ],\\\\n                }\\\\n            ]\\\\n        },\\\\n    )\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        file_paths=[\\\\\\\"file.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 구조\\\\\\\",\\\\n        additional_context=\\\\\\\"테스트 컨텍스트\\\\\\\",\\\\n        processed_diff=DiffResult(\\\\n            files=[\\\\n                FileDiff(\\\\n                    filename=\\\\\\\"file.py\\\\\\\",\\\\n                    hunks=[\\\\n                        Hunk(\\\\n                            header=\\\\\\\"@@ -153,7 +153,6 @@ def sample_review_request(sample_diff_content) -> ReviewRequest:\\\\\\\",\\\\n                            content=\\\\\\\"\\\\\\\"\\\\\\\" },\\\\\\\\n         file_paths=[\\\\\\\"sample.py\\\\\\\"],\\\\\\\\n         review_focus=\\\\\\\"코드 품질\\\\\\\",\\\\\\\\n-        language=\\\\\\\"python\\\\\\\",\\\\\\\\n     )\\\\\\\\n \\\\\\\\n \\\\\\\\n\\\\\\\"\\\\\\\"\\\\\\\",\\\\n                            start_line_original=153,\\\\n                            line_count_original=7,\\\\n                            start_line_modified=153,\\\\n                            line_count_modified=6,\\\\n                        )\\\\n                    ],\\\\n                )\\\\n            ]\\\\n        ),\\\\n    )\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 18, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        assert len(messages) == 2  # 시스템 메시지와 사용자 메시지\\\\n        assert messages[0][\\\\\\\"role\\\\\\\"] == \\\\\\\"system\\\\\\\"\\\\n        assert \\\\\\\"Mock system prompt\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert messages[1][\\\\\\\"role\\\\\\\"] == \\\\\\\"user\\\\\\\"\\\\n        assert \\\\\\\"`​``diff\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"file.py\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n\\\\n    @patch.object(\\\\n        PromptGenerator,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        assert len(messages) == 2  # 시스템 메시지와 사용자 메시지\\\\n        assert messages[0][\\\\\\\"role\\\\\\\"] == \\\\\\\"system\\\\\\\"\\\\n        assert \\\\\\\"Mock system prompt\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n\\\\n        assert messages[1][\\\\\\\"role\\\\\\\"] == \\\\\\\"user\\\\\\\"\\\\n        assert \\\\\\\"`​``diff\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"file_name: file.py\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"hunk_idx: 1\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"line_number: 1\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n\\\\n    @patch.object(\\\\n        PromptGenerator,\\\\n```\\\", \\\"line_number\\\": 68, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n        # 프로세스된 diff가 올바르게 처리되었는지 확인\\\\n        assert messages[1][\\\\\\\"role\\\\\\\"] == \\\\\\\"user\\\\\\\"\\\\n        assert \\\\\\\"파일: file.py\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"Hunk #1\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"`​``diff\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"라인 범위: 1~4\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n\\\\n    @patch.object(\\\\n        PromptGenerator,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n        # 프로세스된 diff가 올바르게 처리되었는지 확인\\\\n        assert messages[1][\\\\\\\"role\\\\\\\"] == \\\\\\\"user\\\\\\\"\\\\n        assert \\\\\\\"file_name: file.py\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"hunk_idx: 1\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"`​``diff\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"line_number: 1\\\\\\\" in messages[1][\\\\\\\"content\\\\\\\"]\\\\n\\\\n    @patch.object(\\\\n        PromptGenerator,\\\\n```\\\", \\\"line_number\\\": 100, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 1, \"file\": \"legacy_tests/test_diff_parser.py\", \"description\": \"테스트 파일에서 `pytest` 모듈 임포트가 제거되었습니다. 해당 파일이 `pytest`를 사용하는 테스트 코드라면 오류가 발생할 수 있습니다.\", \"suggestion\": \"`pytest` 임포트를 다시 추가하거나, 해당 파일이 더 이상 테스트 파일이 아닌지 확인하세요.\", \"severity\": \"warning\", \"target_code\": \"import os\", \"suggested_code\": \"import pytest\\nimport os\"}, {\"type\": \"bug\", \"line_number\": 13, \"file\": \"reviewer/src/diff_parser/models/hunk.py\", \"description\": \"클래스 팩토리 메서드(`from_hunk_text`)에 `@staticmethod` 데코레이터가 사용되었습니다. 이 메서드는 클래스 자체(`cls`)를 사용하여 인스턴스를 생성하므로 `@classmethod`를 사용해야 합니다.\", \"suggestion\": \"`@staticmethod`를 `@classmethod`로 변경하세요.\", \"severity\": \"error\", \"target_code\": \"@staticmethod\", \"suggested_code\": \"@classmethod\"}, {\"type\": \"style\", \"line_number\": 34, \"file\": \"reviewer/src/diff_parser/models/hunk.py\", \"description\": \"팩토리 메서드(`from_hunk_text`)에서 클래스 이름(`Hunk`)을 직접 사용하여 인스턴스를 생성하고 있습니다. `@classmethod`와 `cls(...)`를 사용하면 상속 시 서브클래스의 인스턴스를 반환할 수 있어 더 유연합니다. (이슈 2와 관련됨)\", \"suggestion\": \"`@classmethod` 데코레이터를 사용하고 `return cls(...)`로 변경하세요.\", \"severity\": \"warning\", \"target_code\": \"return Hunk(\", \"suggested_code\": \"return cls(\"}, {\"type\": \"bug\", \"line_number\": 76, \"file\": \"tests/test_prompt_generator.py\", \"description\": \"테스트에서 생성된 프롬프트 메시지의 `line_number` 값이 `1`인지 확인하는 부분이 있습니다. 하지만 테스트 데이터(`tests/test_prompt_generator.py` Hunk 2)에서는 `start_line_modified` 값이 `153`으로 설정되어 있으므로, 이 테스트는 실패하거나 잘못된 값을 검증하게 됩니다.\", \"suggestion\": \"테스트 데이터에 맞게 `line_number` 검증 값을 `153`으로 수정하거나, 테스트 데이터를 `line_number`가 `1`이 되도록 수정해야 합니다.\", \"severity\": \"error\", \"target_code\": \"assert \\\"line_number: 1\\\" in messages[1][\\\"content\\\"]\", \"suggested_code\": \"assert \\\"line_number: 153\\\" in messages[1][\\\"content\\\"]\"}], \"summary\": \"processed_diff 필드를 딕셔너리에서 DiffResult 객체로 변경하는 리팩토링이 주요 변경 내용입니다. 관련하여 여러 파일에서 타입 힌트 및 객체 사용 방식이 업데이트되었습니다. 전반적으로 코드의 타입 안전성이 향상되었으나, Hunk 모델의 팩토리 메서드와 테스트 코드의 일부 검증 로직에 오류가 발견되었습니다.\", \"score\": 7.0, \"recommendations\": [\"Hunk 모델의 from_hunk_text 메서드에서 @staticmethod 대신 @classmethod를 사용하고, Hunk(...) 대신 cls(...)를 사용하여 인스턴스를 생성하도록 수정하세요.\", \"tests/test_prompt_generator.py 파일에서 line_number 검증 로직을 테스트 데이터에 맞게 수정하세요.\", \"legacy_tests/test_diff_parser.py 파일에서 pytest 임포트 제거가 의도된 것인지 확인하고, 필요하다면 다시 추가하세요.\", \"ReviewRequest 모델의 processed_diff 필드가 더 이상 Optional이 아니므로, 해당 모델을 사용하는 모든 곳에서 DiffResult 객체를 필수로 제공하는지 확인하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"legacy_tests/conftest.py\\\", \\\"before_code\\\": \\\"```python\\\\n        },\\\\n        file_paths=[\\\\\\\"sample.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 품질\\\\\\\",\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        },\\\\n        file_paths=[\\\\\\\"sample.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 품질\\\\\\\",\\\\n    )\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 153, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"legacy_tests/conftest.py\\\", \\\"before_code\\\": \\\"```python\\\\n    return [\\\\n        ReviewIssue(\\\\n            type=\\\\\\\"Type Safety\\\\\\\",\\\\n            line=4,\\\\n            file=\\\\\\\"sample.py\\\\\\\",\\\\n            description=\\\\\\\"문자열을 정수로 변환하는 과정에서 타입 오류가 발생할 수 있습니다.\\\\\\\",\\\\n            suggestion=\\\\\\\"입력 타입을 명시적으로 검사하거나 예외 처리를 추가하세요.\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    return [\\\\n        ReviewIssue(\\\\n            type=\\\\\\\"Type Safety\\\\\\\",\\\\n            line_number=4,\\\\n            file=\\\\\\\"sample.py\\\\\\\",\\\\n            description=\\\\\\\"문자열을 정수로 변환하는 과정에서 타입 오류가 발생할 수 있습니다.\\\\\\\",\\\\n            suggestion=\\\\\\\"입력 타입을 명시적으로 검사하거나 예외 처리를 추가하세요.\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 162, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"legacy_tests/conftest.py\\\", \\\"before_code\\\": \\\"```python\\\\n        ),\\\\n        ReviewIssue(\\\\n            type=\\\\\\\"Logging\\\\\\\",\\\\n            line=3,\\\\n            file=\\\\\\\"sample.py\\\\\\\",\\\\n            description=\\\\\\\"로깅 레벨이 적절하지 않습니다. 단순 계산은 DEBUG 레벨이 적합합니다.\\\\\\\",\\\\n            suggestion=\\\\\\\"INFO 대신 DEBUG 로깅 레벨을 사용하세요.\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        ),\\\\n        ReviewIssue(\\\\n            type=\\\\\\\"Logging\\\\\\\",\\\\n            line_number=3,\\\\n            file=\\\\\\\"sample.py\\\\\\\",\\\\n            description=\\\\\\\"로깅 레벨이 적절하지 않습니다. 단순 계산은 DEBUG 레벨이 적합합니다.\\\\\\\",\\\\n            suggestion=\\\\\\\"INFO 대신 DEBUG 로깅 레벨을 사용하세요.\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 172, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"legacy_tests/conftest.py\\\", \\\"before_code\\\": \\\"```python\\\\n        ),\\\\n        ReviewIssue(\\\\n            type=\\\\\\\"Security\\\\\\\",\\\\n            line=8,\\\\n            file=\\\\\\\"sample.py\\\\\\\",\\\\n            description=\\\\\\\"사용자 입력이 검증 없이 처리됩니다.\\\\\\\",\\\\n            suggestion=\\\\\\\"입력값을 적절히 검증하는 코드를 추가하세요.\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        ),\\\\n        ReviewIssue(\\\\n            type=\\\\\\\"Security\\\\\\\",\\\\n            line_number=8,\\\\n            file=\\\\\\\"sample.py\\\\\\\",\\\\n            description=\\\\\\\"사용자 입력이 검증 없이 처리됩니다.\\\\\\\",\\\\n            suggestion=\\\\\\\"입력값을 적절히 검증하는 코드를 추가하세요.\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 182, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"5\\\", \\\"file_name\\\": \\\"legacy_tests/conftest.py\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"샘플 구조화된 리뷰 이슈 객체를 반환하는 fixture\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return StructuredReviewIssue(\\\\n        type=\\\\\\\"Type Safety\\\\\\\",\\\\n        line=4,\\\\n        file=\\\\\\\"sample.py\\\\\\\",\\\\n        description=\\\\\\\"문자열을 정수로 변환하는 과정에서 타입 오류가 발생할 수 있습니다.\\\\\\\",\\\\n        suggestion=\\\\\\\"입력 타입을 명시적으로 검사하거나 예외 처리를 추가하세요.\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"샘플 구조화된 리뷰 이슈 객체를 반환하는 fixture\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return StructuredReviewIssue(\\\\n        type=\\\\\\\"Type Safety\\\\\\\",\\\\n        line_number=4,\\\\n        file=\\\\\\\"sample.py\\\\\\\",\\\\n        description=\\\\\\\"문자열을 정수로 변환하는 과정에서 타입 오류가 발생할 수 있습니다.\\\\\\\",\\\\n        suggestion=\\\\\\\"입력 타입을 명시적으로 검사하거나 예외 처리를 추가하세요.\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 213, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"resources/prompt/v1/code_review_system_prompt.txt\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n각 이슈는 다음 정보를 포함해야 합니다:\\\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\\\n- line: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\\\n- description: 이슈에 대한 자세한 설명\\\\n- suggestion: 문제 해결을 위한 구체적인 제안\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\n각 이슈는 다음 정보를 포함해야 합니다:\\\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\\\n- description: 이슈에 대한 자세한 설명\\\\n- suggestion: 문제 해결을 위한 구체적인 제안\\\\n```\\\", \\\"line_number\\\": 4, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"resources/prompt/v1/code_review_system_prompt.txt\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\\\n\\\\n파일명과 라인 번호는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, 라인 번호는 정확한 숫자를 사용하세요. 파일명을 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\\\n\\\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\\\n\\\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\\\n\\\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\\\n\\\\n```\\\", \\\"line_number\\\": 29, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"resources/prompt/v1/code_review_system_prompt.txt\\\", \\\"before_code\\\": \\\"```text\\\\n  \\\\\\\"issues\\\\\\\": [\\\\n    {\\\\n      \\\\\\\"type\\\\\\\": \\\\\\\"이슈 유형\\\\\\\",\\\\n      \\\\\\\"line\\\\\\\": 라인번호,\\\\n      \\\\\\\"file\\\\\\\": \\\\\\\"파일명\\\\\\\",\\\\n      \\\\\\\"description\\\\\\\": \\\\\\\"이슈 설명\\\\\\\",\\\\n      \\\\\\\"suggestion\\\\\\\": \\\\\\\"개선 제안\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n  \\\\\\\"issues\\\\\\\": [\\\\n    {\\\\n      \\\\\\\"type\\\\\\\": \\\\\\\"이슈 유형\\\\\\\",\\\\n      \\\\\\\"line_number\\\\\\\": 수정 행 번호\\\\n      \\\\\\\"file\\\\\\\": \\\\\\\"파일명\\\\\\\",\\\\n      \\\\\\\"description\\\\\\\": \\\\\\\"이슈 설명\\\\\\\",\\\\n      \\\\\\\"suggestion\\\\\\\": \\\\\\\"개선 제안\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 39, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n        processed_diff=diff_result.to_dict(),\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        language=next(iter(diff_result.to_dict()[\\\\\\\"language_stats\\\\\\\"]), None),\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        processed_diff=diff_result.to_dict(),\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n```\\\", \\\"line_number\\\": 465, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/claude_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n                    issues.append(\\\\n                        ReviewIssue(\\\\n                            type=issue.type,\\\\n                            line=getattr(issue, \\\\\\\"line\\\\\\\", None),\\\\n                            file=getattr(issue, \\\\\\\"file\\\\\\\", None),\\\\n                            description=issue.description,\\\\n                            suggestion=getattr(issue, \\\\\\\"suggestion\\\\\\\", None),\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                    issues.append(\\\\n                        ReviewIssue(\\\\n                            type=issue.type,\\\\n                            line_number=getattr(issue, \\\\\\\"line_number\\\\\\\", None),\\\\n                            file=getattr(issue, \\\\\\\"file\\\\\\\", None),\\\\n                            description=issue.description,\\\\n                            suggestion=getattr(issue, \\\\\\\"suggestion\\\\\\\", None),\\\\n```\\\", \\\"line_number\\\": 214, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/openai_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n        # OpenAI 클라이언트 초기화\\\\n        try:\\\\n            client = OpenAI(api_key=self.api_key)\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # 기본 파라미터 설정\\\\n            params = {\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # OpenAI 클라이언트 초기화\\\\n        try:\\\\n            client = OpenAI(api_key=self.api_key)\\\\n            # print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # 기본 파라미터 설정\\\\n            params = {\\\\n```\\\", \\\"line_number\\\": 137, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/openai_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n                    issues.append(\\\\n                        ReviewIssue(\\\\n                            type=issue.type,\\\\n                            line=getattr(issue, \\\\\\\"line\\\\\\\", None),\\\\n                            file=getattr(issue, \\\\\\\"file\\\\\\\", None),\\\\n                            description=issue.description,\\\\n                            suggestion=getattr(issue, \\\\\\\"suggestion\\\\\\\", None),\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                    issues.append(\\\\n                        ReviewIssue(\\\\n                            type=issue.type,\\\\n                            line_number=getattr(issue, \\\\\\\"line_number\\\\\\\", None),\\\\n                            file=getattr(issue, \\\\\\\"file\\\\\\\", None),\\\\n                            description=issue.description,\\\\n                            suggestion=getattr(issue, \\\\\\\"suggestion\\\\\\\", None),\\\\n```\\\", \\\"line_number\\\": 203, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"before_code\\\": \\\"```python\\\\nimport json\\\\nfrom typing import Dict, Any, List, Optional\\\\nfrom reviewer.src.utils.token.models import ReviewResponse, ReviewIssue\\\\nimport html\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport html\\\\nimport json\\\\nfrom typing import Any, Dict, List\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 40, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 127, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\", [\\\\\\\"리뷰 결과\\\\\\\", \\\\\\\"응답 로그\\\\\\\", \\\\\\\"리뷰 요청\\\\\\\", \\\\\\\"프롬프트\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\", [\\\\\\\"리뷰 결과\\\\\\\", \\\\\\\"응답 로그\\\\\\\", \\\\\\\"reviewRequest\\\\\\\", \\\\\\\"프롬프트\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n```\\\", \\\"line_number\\\": 126, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"리뷰 요청\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 155, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n                        else:\\\\n                            for i, issue in enumerate(issues, 1):\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{i}. {issue.get('type', '유형 없음')} - {issue.get('file', '파일 없음')}:{issue.get('line', 'N/A')}\\\\\\\"\\\\n                                ):\\\\n                                    st.markdown(\\\\n                                        f\\\\\\\"**심각도**: {issue.get('severity', 'info')}\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                        else:\\\\n                            for i, issue in enumerate(issues, 1):\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{i}. {issue.get('type', '유형 없음')} - {issue.get('file', '파일 없음')}:{issue.get('line_number', 'N/A')}\\\\\\\"\\\\n                                ):\\\\n                                    st.markdown(\\\\n                                        f\\\\\\\"**심각도**: {issue.get('severity', 'info')}\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 242, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"before_code\\\": \\\"```python\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"리뷰 요청\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## 리뷰 요청 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                else:  # 프롬프트\\\\n                    # 프롬프트 데이터를 raw JSON으로 표시\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                else:  # 프롬프트\\\\n                    # 프롬프트 데이터를 raw JSON으로 표시\\\\n```\\\", \\\"line_number\\\": 279, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n    def _get_language_prompt(self, language: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"언어 정보 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            language: 언어 정보\\\\n\\\\n        Returns:\\\\n            str: 언어 정보 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n코드는 {language} 언어로 작성되었습니다.\\\\\\\"\\\\n\\\\n    def _get_file_paths_prompt(self, file_paths: list[str]) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일 목록 프롬프트를 반환합니다.\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n    def _get_file_paths_prompt(self, file_paths: list[str]) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일 목록 프롬프트를 반환합니다.\\\\n\\\\n```\\\", \\\"line_number\\\": 75, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        if review_request.review_focus:\\\\n            system_prompt += self._get_review_focus_prompt(review_request.review_focus)\\\\n\\\\n        # 언어 정보가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.language:\\\\n            system_prompt += self._get_language_prompt(review_request.language)\\\\n\\\\n        # 파일 목록이 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.file_paths and len(review_request.file_paths) > 0:\\\\n            system_prompt += self._get_file_paths_prompt(review_request.file_paths)\\\\n\\\\n        messages = [{\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": system_prompt}]\\\\n\\\\n        # 가공된 diff 데이터가 있으면 활용하여 각 파일/hunk별로 컨텍스트 구성\\\\n        match review_request.processed_diff:\\\\n            case dict() as diff if diff:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        if review_request.review_focus:\\\\n            system_prompt += self._get_review_focus_prompt(review_request.review_focus)\\\\n\\\\n        # 파일 목록이 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.file_paths:\\\\n            system_prompt += self._get_file_paths_prompt(review_request.file_paths)\\\\n\\\\n        messages = [{\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": system_prompt}]\\\\n        # 가공된 diff 데이터가 있으면 활용하여 각 파일/hunk별로 컨텍스트 구성\\\\n        match review_request.processed_diff:\\\\n            case dict() as diff if diff:\\\\n```\\\", \\\"line_number\\\": 107, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n                        if not hunk_content:\\\\n                            continue\\\\n\\\\n                        hunk_msg = f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\"\\\\n\\\\n                        messages.append(\\\\n                            {\\\\n                                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                                \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                \\\\\\\"content\\\\\\\": hunk_msg,\\\\n                                \\\\\\\"start_line_original\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_original\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"line_count_original\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"line_count_original\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"start_line_modified\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"line_count_modified\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"line_count_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                            }\\\\n                        )\\\\n            case _:\\\\n                raise ValueError(\\\\\\\"processed_diff가 올바른 형식이 아닙니다.\\\\\\\")\\\\n\\\\n        return messages\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                        if not hunk_content:\\\\n                            continue\\\\n\\\\n                        hunk_msg = {\\\\n                            \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                            \\\\\\\"content\\\\\\\": str(\\\\n                                {\\\\n                                    \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                    \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                    \\\\\\\"content\\\\\\\": f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\",\\\\n                                    \\\\\\\"line_number\\\\\\\": str(\\\\n                                        hunk.get(\\\\\\\"start_line_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                    ),\\\\n                                    \\\\\\\"language\\\\\\\": file_info.get(\\\\\\\"language\\\\\\\", \\\\\\\"\\\\\\\"),\\\\n                                }\\\\n                            ),\\\\n                        }\\\\n                        messages.append(hunk_msg)\\\\n            case _:\\\\n                raise ValueError(\\\\\\\"processed_diff가 올바른 형식이 아닙니다.\\\\\\\")\\\\n\\\\n        # messages.append({\\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"\\\\\\\\n\\\\\\\".join(user_prompt)})\\\\n        return messages\\\\n```\\\", \\\"line_number\\\": 132, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"before_code\\\": \\\"```python\\\\n    )\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    language: Optional[str] = None\\\\n    additional_context: Optional[str] = None\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    )\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    additional_context: Optional[str] = None\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 13, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n```\\\", \\\"line_number\\\": 20, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n```\\\", \\\"line_number\\\": 51, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n    return ReviewRequest(\\\\n        diff_content=\\\\\\\"diff --git a/file.py b/file.py\\\\\\\\nindex 1234..5678 100644\\\\\\\\n--- a/file.py\\\\\\\\n+++ b/file.py\\\\\\\\n@@ -1,3 +1,4 @@\\\\\\\\n+print('Hello')\\\\\\\\n print('World')\\\\\\\\n\\\\\\\",\\\\n        file_paths=[\\\\\\\"file.py\\\\\\\"],\\\\n        language=\\\\\\\"Python\\\\\\\",\\\\n        review_focus=\\\\\\\"코드 구조\\\\\\\",\\\\n        additional_context=\\\\\\\"테스트 컨텍스트\\\\\\\",\\\\n        processed_diff={\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    return ReviewRequest(\\\\n        diff_content=\\\\\\\"diff --git a/file.py b/file.py\\\\\\\\nindex 1234..5678 100644\\\\\\\\n--- a/file.py\\\\\\\\n+++ b/file.py\\\\\\\\n@@ -1,3 +1,4 @@\\\\\\\\n+print('Hello')\\\\\\\\n print('World')\\\\\\\\n\\\\\\\",\\\\n        file_paths=[\\\\\\\"file.py\\\\\\\"],\\\\n        review_focus=\\\\\\\"코드 구조\\\\\\\",\\\\n        additional_context=\\\\\\\"테스트 컨텍스트\\\\\\\",\\\\n        processed_diff={\\\\n```\\\", \\\"line_number\\\": 13, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"tests/test_prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n        assert messages[0][\\\\\\\"role\\\\\\\"] == \\\\\\\"system\\\\\\\"\\\\n        assert \\\\\\\"Mock system prompt\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"특별히 다음 측면에 집중하세요: 코드 구조\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"코드는 Python 언어로 작성되었습니다.\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"변경된 파일 목록:\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n\\\\n        # 프로세스된 diff가 올바르게 처리되었는지 확인\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        assert messages[0][\\\\\\\"role\\\\\\\"] == \\\\\\\"system\\\\\\\"\\\\n        assert \\\\\\\"Mock system prompt\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"특별히 다음 측면에 집중하세요: 코드 구조\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n        assert \\\\\\\"변경된 파일 목록:\\\\\\\" in messages[0][\\\\\\\"content\\\\\\\"]\\\\n\\\\n        # 프로세스된 diff가 올바르게 처리되었는지 확인\\\\n```\\\", \\\"line_number\\\": 87, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 135, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"LLM 메시지 형식이 잘못되었습니다. 메시지 객체 자체를 문자열로 변환하여 `messages` 리스트에 추가하고 있으며, 훈크(hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.) 정보가 `content` 필드 내에 JSON 문자열로 임베딩되어 있어 LLM이 제대로 파싱하기 어렵습니다.\", \"suggestion\": \"메시지 객체를 직접 리스트에 추가하고, 훈크 정보는 `content` 필드 내에 텍스트 형식으로 포함하거나, LLM API가 지원하는 경우 별도의 필드로 전달하는 것이 좋습니다.\", \"severity\": \"error\", \"target_code\": \"hunk_msg = {\\n    \\\"role\\\": \\\"user\\\",\\n    \\\"content\\\": str(\\n        {\\n            \\\"hunk_idx\\\": str(hunk_idx + 1),\\n            \\\"file_name\\\": file_name,\\n            \\\"content\\\": f\\\"`\\b\\b\\bdiff\\\\n{hunk_content}\\\\n`\\b\\b\\b\\\",\\n            \\\"line_number\\\": str(\\n                hunk.get(\\\"start_line_modified\\\", \\\"\\\")\\n            ),\\n            \\\"language\\\": file_info.get(\\\"language\\\", \\\"\\\"),\\n        }\\n    ),\\n}\\nmessages.append(hunk_msg)\", \"suggested_code\": \"hunk_msg_content = f\\\"\\\"\\\"\\nFile: {file_name}\\nHunk Index: {hunk_idx + 1}\\nStarting Line (Modified): {hunk.get(\\\"start_line_modified\\\", \\\"\\\")}\\nLanguage: {file_info.get(\\\"language\\\", \\\"\\\")}\\n\\n```diff\\n{hunk_content}\\n```\\n\\\"\\\"\\\"\\nmessages.append({\\\"role\\\": \\\"user\\\", \\\"content\\\": hunk_msg_content})\"}, {\"type\": \"style\", \"line_number\": 140, \"file\": \"reviewer/src/llm_gateway/openai_gateway.py\", \"description\": \"API 요청 정보를 출력하는 디버그용 `print` 문이 주석 처리되었습니다. 개발 또는 문제 발생 시 유용한 정보이므로 필요에 따라 다시 활성화하거나 로깅 시스템을 사용하는 것이 좋습니다.\", \"suggestion\": \"주석을 제거하거나, `logging` 모듈을 사용하여 적절한 레벨(예: `logging.debug`)로 메시지를 기록하도록 변경하세요.\", \"severity\": \"info\", \"target_code\": \"# print(f\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\")\", \"suggested_code\": \"print(f\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\")\"}, {\"type\": \"style\", \"line_number\": 129, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 텍스트에서 \\\"리뷰 요청\\\"과 \\\"reviewRequest\\\" 용어가 혼용되어 사용되고 있습니다. 사용자 경험 일관성을 위해 용어를 통일하는 것이 좋습니다.\", \"suggestion\": \"\\\"리뷰 요청\\\" 또는 \\\"Review Request\\\" 중 하나로 용어를 통일하여 사용하세요.\", \"severity\": \"info\", \"target_code\": \"st.sidebar.markdown(f\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\")\", \"suggested_code\": \"st.sidebar.markdown(f\\\"**리뷰 요청 저장 위치**: {request_dir}\\\")\"}], \"summary\": \"코드 리뷰 이슈 모델의 'line' 속성을 'line_number'로 변경하고, 'ReviewRequest' 모델에서 'language' 속성을 제거하는 변경사항이 적용되었습니다. UI 텍스트 일부가 변경되었으며, LLM 프롬프트 생성 로직이 리팩토링되었습니다. 전반적으로 속성명 변경 및 제거는 일관되게 적용되었으나, LLM 프롬프트 생성 로직에 심각한 버그가 발견되었습니다.\", \"score\": 4.0, \"recommendations\": [\"LLM 프롬프트 생성 로직의 메시지 형식을 수정하여 LLM이 훈크 정보를 올바르게 파싱할 수 있도록 해야 합니다.\", \"UI 텍스트에서 '리뷰 요청'과 'reviewRequest' 용어를 통일하여 사용자 경험의 일관성을 확보해야 합니다.\", \"디버그 메시지는 필요에 따라 `print` 대신 Python의 `logging` 모듈을 사용하여 관리하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"build.gradle.kts\\\", \\\"before_code\\\": \\\"```kotlin\\\\n}\\\\n\\\\ndependencies {\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-data-jpa\\\\\\\")\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-web\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin\\\\\\\")\\\\n    implementation(\\\\\\\"org.jetbrains.kotlin:kotlin-reflect\\\\\\\")\\\\n    runtimeOnly(\\\\\\\"com.h2database:h2\\\\\\\")\\\\n    testImplementation(\\\\\\\"org.springframework.boot:spring-boot-starter-test\\\\\\\")\\\\n    testRuntimeOnly(\\\\\\\"org.junit.platform:junit-platform-launcher\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.2\\\\\\\")\\\\n}\\\\n\\\\ntasks.withType<KotlinCompile> {\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n}\\\\n\\\\ndependencies {\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-web\\\\\\\")\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-data-jpa\\\\\\\")\\\\n    implementation(\\\\\\\"org.springframework.boot:spring-boot-starter-security\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin\\\\\\\")\\\\n    implementation(\\\\\\\"org.jetbrains.kotlin:kotlin-reflect\\\\\\\")\\\\n    implementation(\\\\\\\"io.jsonwebtoken:jjwt-api:0.12.6\\\\\\\")\\\\n    implementation(\\\\\\\"com.fasterxml.jackson.module:jackson-module-kotlin:2.17.2\\\\\\\")\\\\n\\\\n    runtimeOnly(\\\\\\\"com.h2database:h2\\\\\\\")\\\\n    runtimeOnly(\\\\\\\"io.jsonwebtoken:jjwt-impl:0.12.6\\\\\\\")\\\\n    runtimeOnly(\\\\\\\"io.jsonwebtoken:jjwt-jackson:0.12.6\\\\\\\")\\\\n\\\\n    testRuntimeOnly(\\\\\\\"org.junit.platform:junit-platform-launcher\\\\\\\")\\\\n    testImplementation(\\\\\\\"org.springframework.boot:spring-boot-starter-test\\\\\\\")\\\\n    testImplementation(\\\\\\\"io.kotest:kotest-runner-junit5:5.9.1\\\\\\\")\\\\n    testImplementation(\\\\\\\"org.springframework.security:spring-security-test\\\\\\\")\\\\n}\\\\n\\\\ntasks.withType<KotlinCompile> {\\\\n```\\\", \\\"line_number\\\": 20, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/application/JwtProvider.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.UserId\\\\nimport io.jsonwebtoken.Jwts\\\\nimport io.jsonwebtoken.io.Decoders\\\\nimport io.jsonwebtoken.security.Keys\\\\nimport org.springframework.stereotype.Component\\\\nimport java.time.LocalDateTime\\\\nimport java.time.ZoneOffset\\\\nimport java.util.*\\\\n\\\\n@Component\\\\nclass JwtProvider {\\\\n    /**\\\\n     * Creates a JWT token for the given user ID.\\\\n     *\\\\n     * @param userId the ID of the user for whom the JWT token is being created\\\\n     * @return the generated JWT token as a string\\\\n     */\\\\n    fun create(userId: UserId): String {\\\\n        val now = LocalDateTime.now()\\\\n        val expirationTime = now.plusMinutes(EXPIRATION_MINUTES)\\\\n\\\\n        return Jwts.builder()\\\\n            .signWith(SECRET_KEY)\\\\n            .header()\\\\n            .add(\\\\\\\"typ\\\\\\\", \\\\\\\"JWT\\\\\\\")\\\\n            .add(\\\\\\\"alg\\\\\\\", \\\\\\\"HS256\\\\\\\")\\\\n            .and()\\\\n            .claims()\\\\n            .add(USER_ID_PAYLOAD_PARAMETER, userId.value)\\\\n            .and()\\\\n            .issuer(ISSUER)\\\\n            .issuedAt(Date.from(now.toInstant(ZoneOffset.UTC)))\\\\n            .expiration(Date.from(expirationTime.toInstant(ZoneOffset.UTC)))\\\\n            .compact()\\\\n    }\\\\n\\\\n    /**\\\\n     * Parses a JSON Web Signature (JWS) and retrieves the user ID from its payload.\\\\n     *\\\\n     * @param jws the JWS string to parse\\\\n     * @return the user ID extracted from the JWS payload as a Long\\\\n     */\\\\n    fun parse(jws: String) = Jwts.parser()\\\\n        .verifyWith(SECRET_KEY)\\\\n        .build()\\\\n        .parseSignedClaims(jws)\\\\n        .payload[USER_ID_PAYLOAD_PARAMETER].toString().toLong()\\\\n\\\\n    companion object {\\\\n        //TODO: It seems better to separate all the key signature information here as properties.\\\\n        private const val SECRET_KEY_STRING = \\\\\\\"s7tT5+Z/jfY47K3JqKDl8xhAyqTDynkxNoB/qBcIZd8=\\\\\\\"\\\\n        private val SECRET_KEY = Keys.hmacShaKeyFor(Decoders.BASE64.decode(SECRET_KEY_STRING))\\\\n        private const val ISSUER = \\\\\\\"짱구\\\\\\\"\\\\n        private const val USER_ID_PAYLOAD_PARAMETER = \\\\\\\"userId\\\\\\\"\\\\n\\\\n        private const val EXPIRATION_MINUTES = 30L\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/application/UserRegistrationService.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application\\\\n\\\\nimport io.github.gunkim.realworld.domain.entity.User\\\\nimport io.github.gunkim.realworld.domain.repository.UserRepository\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport org.springframework.stereotype.Service\\\\nimport org.springframework.transaction.annotation.Transactional\\\\n\\\\n@Service\\\\nclass UserRegistrationService(\\\\n    private val userRepository: UserRepository,\\\\n) {\\\\n    @Transactional\\\\n    fun registerUser(\\\\n        username: UserName,\\\\n        email: Email,\\\\n        password: String,\\\\n    ) {\\\\n        userRepository.save(User.create(username, email, password))\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/application/UserService.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.Email\\\\nimport io.github.gunkim.realworld.domain.user.User\\\\nimport io.github.gunkim.realworld.domain.user.UserRepository\\\\nimport io.github.gunkim.realworld.web.request.UserRegistrationRequest\\\\nimport org.springframework.security.crypto.password.PasswordEncoder\\\\nimport org.springframework.stereotype.Service\\\\nimport org.springframework.transaction.annotation.Transactional\\\\n\\\\n@Service\\\\nclass UserService(\\\\n    private val userRepository: UserRepository,\\\\n    private val passwordEncoder: PasswordEncoder,\\\\n) {\\\\n    @Transactional(readOnly = true)\\\\n    fun findUserByEmail(email: Email): User? {\\\\n        return userRepository.findByEmail(email)\\\\n    }\\\\n\\\\n    @Transactional\\\\n    fun registerUser(request: UserRegistrationRequest): User = request.run {\\\\n        require(userRepository.findByEmail(email) == null) { \\\\\\\"User already exists\\\\\\\" }\\\\n\\\\n        val encodedPassword = passwordEncoder.encode(password)\\\\n        return userRepository.save(User.create(username, email, encodedPassword))\\\\n    }\\\\n\\\\n    fun authenticate(user: User, password: String) {\\\\n        require(passwordEncoder.matches(password, user.password)) { \\\\\\\"Password does not match\\\\\\\" }\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/config/PasswordEncoderConfig.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.config\\\\n\\\\nimport org.springframework.context.annotation.Bean\\\\nimport org.springframework.context.annotation.Configuration\\\\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\\\\n\\\\n@Configuration\\\\nclass PasswordEncoderConfig {\\\\n    @Bean\\\\n    fun passwordEncoder() = BCryptPasswordEncoder()\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/config/SecurityConfig.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.config\\\\n\\\\nimport org.springframework.boot.autoconfigure.security.servlet.PathRequest\\\\nimport org.springframework.context.annotation.Bean\\\\nimport org.springframework.context.annotation.Configuration\\\\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity\\\\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\\\\nimport org.springframework.security.web.SecurityFilterChain\\\\n\\\\n@Configuration\\\\n@EnableWebSecurity\\\\nclass SecurityConfig {\\\\n    @Bean\\\\n    fun filterChain(http: HttpSecurity): SecurityFilterChain {\\\\n        return http\\\\n            .csrf { it.disable() }\\\\n            .cors { it.disable() }\\\\n            .sessionManagement { it.disable() }\\\\n            .headers { it.frameOptions { it.sameOrigin() } }\\\\n            .authorizeHttpRequests {\\\\n                it.requestMatchers(\\\\\\\"/api/users/**\\\\\\\").permitAll()\\\\n                it.requestMatchers(PathRequest.toH2Console()).permitAll()\\\\n                it.anyRequest().authenticated()\\\\n            }\\\\n            .build()\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/Article.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.AggregateRoot\\\\nimport io.github.gunkim.realworld.domain.vo.ArticleId\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.AggregateRoot\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/ArticleId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/Comment.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.DomainEntity\\\\nimport io.github.gunkim.realworld.domain.vo.CommentId\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.DomainEntity\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/CommentId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/Tag.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.DomainEntity\\\\nimport io.github.gunkim.realworld.domain.vo.TagId\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.FetchType\\\\nimport jakarta.persistence.Id\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.DomainEntity\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.FetchType\\\\nimport jakarta.persistence.Id\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/article/TagId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.article\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/common/AggregateRoot.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.base\\\\n\\\\nimport org.springframework.data.domain.AfterDomainEventPublication\\\\nimport org.springframework.data.domain.DomainEvents\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.common\\\\n\\\\nimport org.springframework.data.domain.AfterDomainEventPublication\\\\nimport org.springframework.data.domain.DomainEvents\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/common/DomainEntity.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.base\\\\n\\\\nabstract class DomainEntity<T : DomainEntity<T, TID>?, TID> {\\\\n    override fun equals(other: Any?): Boolean {\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.common\\\\n\\\\nabstract class DomainEntity<T : DomainEntity<T, TID>?, TID> {\\\\n    override fun equals(other: Any?): Boolean {\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/common/ValueObject.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.base\\\\n\\\\nimport java.lang.reflect.Field\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.common\\\\n\\\\nimport java.lang.reflect.Field\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/repository/UserRepository.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.repository\\\\n\\\\nimport io.github.gunkim.realworld.domain.entity.User\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport org.springframework.data.jpa.repository.JpaRepository\\\\n\\\\ninterface UserRepository : JpaRepository<User, UserId>\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/Email.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport io.github.gunkim.realworld.domain.article.ArticleId\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/User.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.AggregateRoot\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.AggregateRoot\\\\nimport jakarta.persistence.*\\\\nimport java.time.LocalDateTime\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/User.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n    @Id\\\\n    override val id: UserId?,\\\\n    @Embedded\\\\n    val email: Email,\\\\n    password: String,\\\\n    @OneToOne(fetch = FetchType.LAZY, cascade = [CascadeType.ALL])\\\\n    val profile: UserProfile,\\\\n    val createdAt: LocalDateTime = LocalDateTime.now(),\\\\n) : AggregateRoot<User, UserId>() {\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n    @Id\\\\n    override val id: UserId?,\\\\n    @Embedded\\\\n    @Column(unique = true)\\\\n    val email: Email,\\\\n    password: String,\\\\n    @OneToOne(cascade = [CascadeType.ALL])\\\\n    val profile: UserProfile,\\\\n    val createdAt: LocalDateTime = LocalDateTime.now(),\\\\n) : AggregateRoot<User, UserId>() {\\\\n```\\\", \\\"line_number\\\": 9, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserId.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport io.github.gunkim.realworld.domain.article.ArticleId\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\nimport java.util.*\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserName.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.vo\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.ValueObject\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.ValueObject\\\\nimport io.github.gunkim.realworld.domain.article.ArticleId\\\\nimport jakarta.persistence.Column\\\\nimport jakarta.persistence.Embeddable\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserProfile.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.entity\\\\n\\\\nimport io.github.gunkim.realworld.domain.base.DomainEntity\\\\nimport io.github.gunkim.realworld.domain.vo.UserId\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.Id\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\nimport io.github.gunkim.realworld.domain.common.DomainEntity\\\\nimport jakarta.persistence.Entity\\\\nimport jakarta.persistence.Id\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserRepository.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.domain.user\\\\n\\\\ninterface UserRepository {\\\\n    fun save(user: User): User\\\\n    fun findByEmail(email: Email): User?\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/persistence/UserJpaRepository.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.persistence\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.User\\\\nimport io.github.gunkim.realworld.domain.user.UserId\\\\nimport io.github.gunkim.realworld.domain.user.UserRepository\\\\nimport org.springframework.data.jpa.repository.JpaRepository\\\\n\\\\ninterface UserJpaRepository : JpaRepository<User, UserId>, UserRepository {\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/UserController.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web\\\\n\\\\nimport io.github.gunkim.realworld.application.UserRegistrationService\\\\nimport io.github.gunkim.realworld.domain.vo.Email\\\\nimport io.github.gunkim.realworld.domain.vo.UserName\\\\nimport org.springframework.web.bind.annotation.PostMapping\\\\nimport org.springframework.web.bind.annotation.RequestBody\\\\nimport org.springframework.web.bind.annotation.RequestMapping\\\\nimport org.springframework.web.bind.annotation.RestController\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"/api/users\\\\\\\")\\\\nclass UserController(\\\\n    private val userRegistrationService: UserRegistrationService,\\\\n) {\\\\n    @PostMapping\\\\n    fun registration(\\\\n        @RequestBody\\\\n        request: UserRegistrationRequest,\\\\n    ) {\\\\n        request.user.apply { run() }\\\\n    }\\\\n\\\\n    private fun UserRegistrationRequest.UserDetailRequest.run() {\\\\n        userRegistrationService.registerUser(\\\\n            UserName(username),\\\\n            Email(email),\\\\n            password\\\\n        )\\\\n    }\\\\n}\\\\n\\\\ndata class UserRegistrationRequest(\\\\n    val user: UserDetailRequest,\\\\n) {\\\\n    data class UserDetailRequest(\\\\n        val username: String,\\\\n        val email: String,\\\\n        val password: String,\\\\n    )\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/api/UserController.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.api\\\\n\\\\nimport io.github.gunkim.realworld.application.JwtProvider\\\\nimport io.github.gunkim.realworld.application.UserService\\\\nimport io.github.gunkim.realworld.domain.user.Email\\\\nimport io.github.gunkim.realworld.web.request.UserAuthenticateRequest\\\\nimport io.github.gunkim.realworld.web.request.UserRegistrationRequest\\\\nimport io.github.gunkim.realworld.web.response.UserResponse\\\\nimport org.springframework.web.bind.annotation.PostMapping\\\\nimport org.springframework.web.bind.annotation.RequestBody\\\\nimport org.springframework.web.bind.annotation.RequestMapping\\\\nimport org.springframework.web.bind.annotation.RestController\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"/api/users\\\\\\\")\\\\nclass UserController(\\\\n    private val userService: UserService,\\\\n    private val jwtProvider: JwtProvider,\\\\n) {\\\\n    @PostMapping\\\\n    fun registration(\\\\n        @RequestBody\\\\n        request: UserRegistrationRequest,\\\\n    ): UserResponse {\\\\n        val registeredUser = userService.registerUser(request)\\\\n        return UserResponse.from(registeredUser, jwtProvider.create(registeredUser.id!!))\\\\n    }\\\\n\\\\n    @PostMapping(\\\\\\\"/login\\\\\\\")\\\\n    fun authenticate(\\\\n        @RequestBody\\\\n        request: UserAuthenticateRequest,\\\\n    ): UserResponse {\\\\n        val user = userService.findUserByEmail(Email(request.email))\\\\n            ?: throw IllegalArgumentException(\\\\\\\"User not found\\\\\\\")\\\\n\\\\n        userService.authenticate(user, request.password)\\\\n\\\\n        return UserResponse.from(user, jwtProvider.create(user.id!!))\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/request/UserAuthenticateRequest.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.request\\\\n\\\\ndata class UserAuthenticateRequest(\\\\n    val email: String,\\\\n    val password: String,\\\\n)\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/request/UserRegistrationRequest.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.request\\\\n\\\\nimport io.github.gunkim.realworld.domain.user.Email\\\\nimport io.github.gunkim.realworld.domain.user.UserName\\\\n\\\\nclass UserRegistrationRequest(\\\\n    username: String,\\\\n    email: String,\\\\n    val password: String,\\\\n) {\\\\n    val username = UserName(username)\\\\n    val email = Email(email)\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/kotlin/io/github/gunkim/realworld/web/response/UserResponse.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.web.response\\\\n\\\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo\\\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.As.WRAPPER_OBJECT\\\\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.Id.NAME\\\\nimport com.fasterxml.jackson.annotation.JsonTypeName\\\\nimport io.github.gunkim.realworld.domain.user.User\\\\n\\\\n@JsonTypeName(\\\\\\\"user\\\\\\\")\\\\n@JsonTypeInfo(include = WRAPPER_OBJECT, use = NAME)\\\\ndata class UserResponse(\\\\n    val email: String,\\\\n    val token: String,\\\\n    val username: String,\\\\n    val bio: String?,\\\\n    val image: String?,\\\\n) {\\\\n    companion object {\\\\n        fun from(user: User, token: String) = UserResponse(\\\\n            user.email.value,\\\\n            token,\\\\n            user.profile.name.value,\\\\n            user.profile.bio,\\\\n            user.profile.image\\\\n        )\\\\n    }\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/main/resources/application.yml\\\", \\\"before_code\\\": \\\"```yaml\\\\n  jpa:\\\\n    database-platform: org.hibernate.dialect.H2Dialect\\\\n    show-sql: true\\\\n  h2:\\\\n    console:\\\\n      enabled: true\\\\n      path: /h2-console\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```yaml\\\\n  jpa:\\\\n    database-platform: org.hibernate.dialect.H2Dialect\\\\n    show-sql: true\\\\n    open-in-view: false\\\\n  h2:\\\\n    console:\\\\n      enabled: true\\\\n      path: /h2-console\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 6, \\\"language\\\": \\\"yaml\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"src/test/kotlin/io/github/gunkim/realworld/application/user/JwtProviderTest.kt\\\", \\\"before_code\\\": \\\"```kotlin\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```kotlin\\\\npackage io.github.gunkim.realworld.application.user\\\\n\\\\nimport io.github.gunkim.realworld.application.JwtProvider\\\\nimport io.kotest.assertions.throwables.shouldNotThrow\\\\nimport io.kotest.core.annotation.DisplayName\\\\nimport io.kotest.core.spec.style.StringSpec\\\\nimport io.kotest.matchers.shouldBe\\\\n\\\\nprivate const val TEST_USER_ID = 1L\\\\n\\\\n@DisplayName(\\\\\\\"JwtProvider is\\\\\\\")\\\\nclass JwtProviderTest : StringSpec({\\\\n    val sut = JwtProvider()\\\\n\\\\n    \\\\\\\"should create JWT token successfully\\\\\\\" {\\\\n        shouldNotThrow<IllegalStateException> {\\\\n            sut.create(TEST_USER_ID)\\\\n        }\\\\n    }\\\\n\\\\n    \\\\\\\"should parse JWT token correctly\\\\\\\" {\\\\n        val jws = sut.create(TEST_USER_ID)\\\\n        sut.parse(jws) shouldBe TEST_USER_ID\\\\n    }\\\\n})\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"kotlin\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"security\", \"line_number\": 55, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/application/JwtProvider.kt\", \"description\": \"JWT 서명에 사용되는 비밀 키가 소스 코드에 하드코딩되어 있습니다. 이는 보안상 매우 취약하며, 키가 노출될 경우 심각한 문제가 발생할 수 있습니다.\", \"suggestion\": \"비밀 키를 환경 변수, 외부 설정 파일 또는 Spring Cloud Config와 같은 중앙 집중식 설정 관리 시스템을 통해 관리하도록 변경해야 합니다. 하드코딩된 키는 즉시 제거하고 안전한 방식으로 로드하도록 수정하세요.\", \"severity\": \"error\", \"target_code\": \"private const val SECRET_KEY_STRING = \\\"s7tT5+Z/jfY47K3JqKDl8xhAyqTDynkxNoB/qBcIZd8=\\\"\", \"suggested_code\": null}, {\"type\": \"bug\", \"line_number\": 4, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/Email.kt\", \"description\": \"`io.github.gunkim.realworld.domain.article.ArticleId`가 `Email` 클래스에 불필요하게 임포트되었습니다. 이는 코드의 혼란을 야기하고 잠재적인 버그를 유발할 수 있습니다.\", \"suggestion\": \"사용되지 않는 임포트 문을 제거하세요.\", \"severity\": \"warning\", \"target_code\": \"import io.github.gunkim.realworld.domain.article.ArticleId\", \"suggested_code\": null}, {\"type\": \"bug\", \"line_number\": 4, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserId.kt\", \"description\": \"`io.github.gunkim.realworld.domain.article.ArticleId`가 `UserId` 클래스에 불필요하게 임포트되었습니다. 이는 코드의 혼란을 야기하고 잠재적인 버그를 유발할 수 있습니다.\", \"suggestion\": \"사용되지 않는 임포트 문을 제거하세요.\", \"severity\": \"warning\", \"target_code\": \"import io.github.gunkim.realworld.domain.article.ArticleId\", \"suggested_code\": null}, {\"type\": \"bug\", \"line_number\": 4, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/UserName.kt\", \"description\": \"`io.github.gunkim.realworld.domain.article.ArticleId`가 `UserName` 클래스에 불필요하게 임포트되었습니다. 이는 코드의 혼란을 야기하고 잠재적인 버그를 유발할 수 있습니다.\", \"suggestion\": \"사용되지 않는 임포트 문을 제거하세요.\", \"severity\": \"warning\", \"target_code\": \"import io.github.gunkim.realworld.domain.article.ArticleId\", \"suggested_code\": null}, {\"type\": \"performance\", \"line_number\": 15, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/domain/user/User.kt\", \"description\": \"`profile` 관계에 대해 `fetch = FetchType.LAZY`가 제거되어 기본값인 `EAGER` 로딩이 적용됩니다. 이는 `User` 엔티티를 조회할 때마다 연관된 `UserProfile` 엔티티를 항상 함께 로딩하게 되어, 불필요한 데이터 로딩으로 인한 성능 저하를 유발할 수 있습니다.\", \"suggestion\": \"`profile` 관계에 `fetch = FetchType.LAZY`를 명시적으로 지정하여 필요한 경우에만 로딩되도록 변경하는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"@OneToOne(cascade = [CascadeType.ALL])\", \"suggested_code\": \"@OneToOne(fetch = FetchType.LAZY, cascade = [CascadeType.ALL])\"}, {\"type\": \"bug\", \"line_number\": 26, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/web/api/UserController.kt\", \"description\": \"`registeredUser.id!!`와 같이 널이 아님을 강제로 단언하는 연산자(`!!`)를 사용하고 있습니다. `user.id`가 실제로 널일 경우 `NullPointerException`이 발생할 수 있습니다. JPA 엔티티의 ID는 저장 후에는 널이 아니지만, 코드의 안정성을 높이기 위해 널 가능성을 명시적으로 처리하는 것이 좋습니다.\", \"suggestion\": \"널 가능성을 고려하여 안전 호출(`?.`) 또는 널 체크 후 사용하거나, 도메인 로직에서 ID가 항상 존재함을 보장하도록 설계하는 것을 고려하세요. 예를 들어, `let` 스코프 함수를 사용할 수 있습니다.\", \"severity\": \"warning\", \"target_code\": \"registeredUser.id!!\", \"suggested_code\": \"registeredUser.id?.let { jwtProvider.create(it) } ?: throw IllegalStateException(\\\"User ID cannot be null after registration\\\")\"}, {\"type\": \"bug\", \"line_number\": 39, \"file\": \"src/main/kotlin/io/github/gunkim/realworld/web/api/UserController.kt\", \"description\": \"`user.id!!`와 같이 널이 아님을 강제로 단언하는 연산자(`!!`)를 사용하고 있습니다. `user.id`가 실제로 널일 경우 `NullPointerException`이 발생할 수 있습니다. JPA 엔티티의 ID는 저장 후에는 널이 아니지만, 코드의 안정성을 높이기 위해 널 가능성을 명시적으로 처리하는 것이 좋습니다.\", \"suggestion\": \"널 가능성을 고려하여 안전 호출(`?.`) 또는 널 체크 후 사용하거나, 도메인 로직에서 ID가 항상 존재함을 보장하도록 설계하는 것을 고려하세요. 예를 들어, `let` 스코프 함수를 사용할 수 있습니다.\", \"severity\": \"warning\", \"target_code\": \"user.id!!\", \"suggested_code\": \"user.id?.let { jwtProvider.create(it) } ?: throw IllegalStateException(\\\"User ID cannot be null after authentication\\\")\"}], \"summary\": \"사용자 등록 및 인증 기능에 Spring Security와 JWT가 도입되었습니다. 도메인 모델 패키지 구조가 재구성되었으며, JPA 관련 설정(Open Session In View 비활성화, Email Unique 제약조건 추가)이 개선되었습니다. 전반적으로 기능 구현 및 아키텍처 개선이 이루어졌으나, JWT 비밀 키 하드코딩, 불필요한 임포트, EAGER 로딩, 안전하지 않은 널 단언 등 몇 가지 중요한 보안, 버그, 성능 관련 이슈가 발견되었습니다.\", \"score\": 6.0, \"recommendations\": [\"JWT 비밀 키와 같은 민감 정보는 환경 변수나 외부 설정 파일을 통해 안전하게 관리해야 합니다.\", \"JWT 파싱 시 발생할 수 있는 예외(예: 토큰 만료, 잘못된 서명)에 대한 명확한 예외 처리 로직을 추가해야 합니다.\", \"웹 계층에서 발생하는 비즈니스 로직 예외(예: 사용자 없음, 비밀번호 불일치)를 Global Exception Handler를 통해 적절한 HTTP 상태 코드(예: 404 Not Found, 401 Unauthorized)로 매핑하여 반환하도록 개선해야 합니다.\", \"Spring Security 설정에서 CORS를 전역적으로 비활성화하는 대신, 필요한 오리진만 허용하도록 구체적으로 설정하는 것을 고려해야 합니다.\", \"새로 추가된 기능(인증, 등록) 및 발견된 이슈(JWT 파싱, 예외 처리)에 대한 단위 및 통합 테스트 케이스를 추가하여 코드의 안정성을 확보해야 합니다.\", \"파일 끝에 개행 문자를 추가하여 파일 형식을 일관되게 유지하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/.mvn/wrapper/maven-wrapper.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\ndistributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.4/apache-maven-3.9.4-bin.zip\\\\nwrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/pom.xml\\\", \\\"before_code\\\": \\\"```xml\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```xml\\\\n<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?>\\\\n<project xmlns=\\\\\\\"http://maven.apache.org/POM/4.0.0\\\\\\\" xmlns:xsi=\\\\\\\"http://www.w3.org/2001/XMLSchema-instance\\\\\\\"\\\\n\\\\txsi:schemaLocation=\\\\\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\\\\\">\\\\n\\\\t<modelVersion>4.0.0</modelVersion>\\\\n\\\\t<parent>\\\\n\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t<artifactId>spring-boot-starter-parent</artifactId>\\\\n\\\\t\\\\t<version>3.1.3</version>\\\\n\\\\t\\\\t<relativePath/> <!-- lookup parent from repository -->\\\\n\\\\t</parent>\\\\n\\\\t<groupId>com.hoangtien2k3</groupId>\\\\n\\\\t<artifactId>order-serivce</artifactId>\\\\n\\\\t<version>0.0.1-SNAPSHOT</version>\\\\n\\\\t<name>order-serivce</name>\\\\n\\\\t<description>Demo project for Spring Boot</description>\\\\n\\\\t<properties>\\\\n\\\\t\\\\t<java.version>17</java.version>\\\\n\\\\t</properties>\\\\n\\\\t<dependencies>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jdbc</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jpa</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-security</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-validation</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-web</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-devtools</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>runtime</scope>\\\\n\\\\t\\\\t\\\\t<optional>true</optional>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>com.mysql</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>mysql-connector-j</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>runtime</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t<optional>true</optional>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-test</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.security</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-security-test</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t</dependencies>\\\\n\\\\n\\\\t<build>\\\\n\\\\t\\\\t<plugins>\\\\n\\\\t\\\\t\\\\t<plugin>\\\\n\\\\t\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t<artifactId>spring-boot-maven-plugin</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t<configuration>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t<excludes>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t</exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t</excludes>\\\\n\\\\t\\\\t\\\\t\\\\t</configuration>\\\\n\\\\t\\\\t\\\\t</plugin>\\\\n\\\\t\\\\t</plugins>\\\\n\\\\t</build>\\\\n\\\\n</project>\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"xml\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/src/main/java/com/hoangtien2k3/orderserivce/OrderSerivceApplication.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.orderserivce;\\\\n\\\\nimport org.springframework.boot.SpringApplication;\\\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\\\n\\\\n@SpringBootApplication\\\\npublic class OrderSerivceApplication {\\\\n\\\\n\\\\tpublic static void main(String[] args) {\\\\n\\\\t\\\\tSpringApplication.run(OrderSerivceApplication.class, args);\\\\n\\\\t}\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/src/main/resources/application.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n#Server port :\\\\nserver.port=8813\\\\n\\\\n#Application name :\\\\nspring.application.name=order-service\\\\n\\\\n## Datasource :\\\\nspring.datasource.url=jdbc:mysql://localhost:3306/orderservice?useSSL=false\\\\nspring.datasource.username=root\\\\nspring.datasource.password=12042003\\\\n\\\\n## JPA/Hibernate :\\\\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\\\\nspring.jpa.ddl-auto=update\\\\nspring.jpa.show-sql=true\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/src/test/java/com/hoangtien2k3/orderserivce/OrderSerivceApplicationTests.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.orderserivce;\\\\n\\\\nimport org.junit.jupiter.api.Test;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\n\\\\n@SpringBootTest\\\\nclass OrderSerivceApplicationTests {\\\\n\\\\n\\\\t@Test\\\\n\\\\tvoid contextLoads() {\\\\n\\\\t}\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/.mvn/wrapper/maven-wrapper.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\ndistributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.4/apache-maven-3.9.4-bin.zip\\\\nwrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/pom.xml\\\", \\\"before_code\\\": \\\"```xml\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```xml\\\\n<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?>\\\\n<project xmlns=\\\\\\\"http://maven.apache.org/POM/4.0.0\\\\\\\" xmlns:xsi=\\\\\\\"http://www.w3.org/2001/XMLSchema-instance\\\\\\\"\\\\n\\\\txsi:schemaLocation=\\\\\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\\\\\">\\\\n\\\\t<modelVersion>4.0.0</modelVersion>\\\\n\\\\t<parent>\\\\n\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t<artifactId>spring-boot-starter-parent</artifactId>\\\\n\\\\t\\\\t<version>3.1.3</version>\\\\n\\\\t\\\\t<relativePath/> <!-- lookup parent from repository -->\\\\n\\\\t</parent>\\\\n\\\\t<groupId>com.hoangtien2k3</groupId>\\\\n\\\\t<artifactId>user-service</artifactId>\\\\n\\\\t<version>0.0.1-SNAPSHOT</version>\\\\n\\\\t<name>user-service</name>\\\\n\\\\t<description>Demo project for Spring Boot</description>\\\\n\\\\t<properties>\\\\n\\\\t\\\\t<java.version>17</java.version>\\\\n\\\\t</properties>\\\\n\\\\t<dependencies>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jdbc</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jpa</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-web</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>com.mysql</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>mysql-connector-j</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>runtime</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t<optional>true</optional>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-test</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>javax.validation</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>validation-api</artifactId>\\\\n\\\\t\\\\t\\\\t<version>2.0.0.Final</version>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>junit</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>junit</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t</dependencies>\\\\n\\\\n\\\\t<build>\\\\n\\\\t\\\\t<plugins>\\\\n\\\\t\\\\t\\\\t<plugin>\\\\n\\\\t\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t<artifactId>spring-boot-maven-plugin</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t<configuration>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t<excludes>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t</exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t</excludes>\\\\n\\\\t\\\\t\\\\t\\\\t</configuration>\\\\n\\\\t\\\\t\\\\t</plugin>\\\\n\\\\t\\\\t</plugins>\\\\n\\\\t</build>\\\\n\\\\n</project>\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"xml\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/UserServiceApplication.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice;\\\\n\\\\nimport org.springframework.boot.SpringApplication;\\\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\\\n\\\\n@SpringBootApplication\\\\npublic class UserServiceApplication {\\\\n\\\\n\\\\tpublic static void main(String[] args) {\\\\n\\\\t\\\\tSpringApplication.run(UserServiceApplication.class, args);\\\\n\\\\t}\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/controller/RegisterController.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.controller;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport com.hoangtien2k3.userservice.service.http.header.HeaderGenerator;\\\\nimport jakarta.servlet.http.HttpServletRequest;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.http.HttpStatus;\\\\nimport org.springframework.http.ResponseEntity;\\\\nimport org.springframework.web.bind.annotation.PostMapping;\\\\nimport org.springframework.web.bind.annotation.RequestBody;\\\\nimport org.springframework.web.bind.annotation.RequestMapping;\\\\nimport org.springframework.web.bind.annotation.RestController;\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"/api/register\\\\\\\")\\\\npublic class RegisterController {\\\\n\\\\n    @Autowired\\\\n    private UserService userService;\\\\n\\\\n    @Autowired\\\\n    private HeaderGenerator headerGenerator;\\\\n\\\\n    @PostMapping(value = \\\\\\\"/registration\\\\\\\")\\\\n    public ResponseEntity<User> addUser(@RequestBody User user, HttpServletRequest request){\\\\n        if(user != null)\\\\n            try {\\\\n                userService.saveUser(user);\\\\n                return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessPostMethod(request, user.getId()), HttpStatus.CREATED);\\\\n            }catch (Exception e) {\\\\n                e.printStackTrace();\\\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\\\n            }\\\\n        return new ResponseEntity<User>(HttpStatus.BAD_REQUEST);\\\\n    }\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/controller/UserController.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.controller;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport com.hoangtien2k3.userservice.service.http.header.HeaderGenerator;\\\\nimport jakarta.servlet.http.HttpServletRequest;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.http.HttpStatus;\\\\nimport org.springframework.http.ResponseEntity;\\\\nimport org.springframework.web.bind.annotation.*;\\\\n\\\\nimport java.util.List;\\\\nimport java.util.Optional;\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"api/user\\\\\\\")\\\\npublic class UserController {\\\\n\\\\n    @Autowired\\\\n    private UserService userService;\\\\n\\\\n    @Autowired\\\\n    private HeaderGenerator headerGenerator;\\\\n\\\\n    @GetMapping(value = \\\\\\\"/users\\\\\\\")\\\\n    public ResponseEntity<List<User>> getAllUser() {\\\\n        List<User> users = userService.getAllUser();\\\\n\\\\n        if (!users.isEmpty()) {\\\\n            return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\\\n        }\\\\n        return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\\\\n    }\\\\n\\\\n    @GetMapping(value = \\\\\\\"/users\\\\\\\", params = \\\\\\\"name\\\\\\\")\\\\n    public ResponseEntity<User> getUserByName(@RequestParam(\\\\\\\"name\\\\\\\") String username) {\\\\n        User user = userService.getUserByName(username);\\\\n\\\\n        if (user != null) {\\\\n            return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\\\n        }\\\\n        return new ResponseEntity<User>(headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\\\\n\\\\n    }\\\\n\\\\n    @GetMapping(value = \\\\\\\"/users/{id}\\\\\\\")\\\\n    public ResponseEntity<User> getUserById(@PathVariable(\\\\\\\"id\\\\\\\") Long id) {\\\\n        User user = userService.getUserById(id);\\\\n        if (user != null) {\\\\n            return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\\\n        }\\\\n        return new ResponseEntity<User>(headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\\\\n    }\\\\n\\\\n    @PostMapping(value = \\\\\\\"/users\\\\\\\")\\\\n    public ResponseEntity<User> addUser(@RequestBody User user, HttpServletRequest request) {\\\\n        if (user != null)\\\\n            try {\\\\n                userService.saveUser(user);\\\\n                return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessPostMethod(request, user.getId()), HttpStatus.CREATED);\\\\n            } catch (Exception e) {\\\\n                e.printStackTrace();\\\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\\\n            }\\\\n        return new ResponseEntity<User>(HttpStatus.BAD_REQUEST);\\\\n    }\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/entity/User.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.entity;\\\\n\\\\nimport jakarta.persistence.*;\\\\nimport lombok.*;\\\\n\\\\n@Getter\\\\n@Setter\\\\n@AllArgsConstructor\\\\n@NoArgsConstructor\\\\n@Builder\\\\n@Entity\\\\n@Table(name = \\\\\\\"users\\\\\\\")\\\\npublic class User {\\\\n\\\\n    @Id\\\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\\\n    private Long id;\\\\n\\\\n    @Column(name = \\\\\\\"user_name\\\\\\\", nullable = false, unique = true, length = 50)\\\\n    private String userName;\\\\n    @Column(name = \\\\\\\"user_password\\\\\\\", nullable = false, length = 50)\\\\n    private String userPassword;\\\\n    @Column(name = \\\\\\\"active\\\\\\\")\\\\n    private int active;\\\\n\\\\n    @OneToOne(cascade = CascadeType.ALL)\\\\n    @JoinColumn(name = \\\\\\\"user_details_id\\\\\\\")\\\\n    private UserDetails userDetails;\\\\n\\\\n    @ManyToOne\\\\n    @JoinColumn(name = \\\\\\\"role_id\\\\\\\")\\\\n    private UserRole role;\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserDetails.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.entity;\\\\n\\\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\\\nimport jakarta.persistence.*;\\\\nimport lombok.*;\\\\n\\\\n@Getter\\\\n@Setter\\\\n@AllArgsConstructor\\\\n@NoArgsConstructor\\\\n@Data\\\\n@Entity\\\\n@Table(name = \\\\\\\"users_details\\\\\\\")\\\\npublic class UserDetails {\\\\n\\\\n    @Id\\\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\\\n    private Long id;\\\\n\\\\n    @Column(name = \\\\\\\"first_name\\\\\\\", nullable = false, length = 50)\\\\n    private String firstName;\\\\n    @Column(name = \\\\\\\"last_name\\\\\\\", nullable = false, length = 50)\\\\n    private String lastName;\\\\n    @Column(name = \\\\\\\"email\\\\\\\", nullable = false, unique = true, length = 50)\\\\n    private String email;\\\\n    @Column(name = \\\\\\\"phone_number\\\\\\\", length = 15)\\\\n    private String phoneNumber;\\\\n    @Column(name = \\\\\\\"street\\\\\\\", length = 30)\\\\n    private String street;\\\\n    @Column(name = \\\\\\\"street_number\\\\\\\", length = 10)\\\\n    private String streetNumber;\\\\n    @Column(name = \\\\\\\"zip_code\\\\\\\", length = 6)\\\\n    private String zipCode;\\\\n    @Column(name = \\\\\\\"locality\\\\\\\", length = 30)\\\\n    private String locality;\\\\n    @Column(name = \\\\\\\"country\\\\\\\", length = 30)\\\\n    private String country;\\\\n\\\\n    @OneToOne(mappedBy = \\\\\\\"userDetails\\\\\\\") // bidirectional\\\\n    @JsonIgnore\\\\n    private User user;\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserRole.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.entity;\\\\n\\\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\\\nimport jakarta.persistence.*;\\\\nimport lombok.*;\\\\n\\\\nimport java.util.List;\\\\n\\\\n@Getter\\\\n@Setter\\\\n@AllArgsConstructor\\\\n@NoArgsConstructor\\\\n@Data\\\\n@Entity\\\\n@Table(name = \\\\\\\"user_role\\\\\\\")\\\\npublic class UserRole {\\\\n\\\\n    @Id\\\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\\\n    private Long id;\\\\n\\\\n    @Column(name = \\\\\\\"role_name\\\\\\\")\\\\n    private String roleName;\\\\n\\\\n    @OneToMany(mappedBy = \\\\\\\"role\\\\\\\")\\\\n    @JsonIgnore\\\\n    private List<User> users;\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/repository/UserDetailsRepository.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.repository;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.UserDetails;\\\\nimport org.springframework.data.jpa.repository.JpaRepository;\\\\nimport org.springframework.stereotype.Repository;\\\\n\\\\n@Repository\\\\npublic interface UserDetailsRepository extends JpaRepository<UserDetails, Long> {\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/repository/UserRepository.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.repository;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport org.springframework.data.jpa.repository.JpaRepository;\\\\nimport org.springframework.stereotype.Repository;\\\\n\\\\n@Repository\\\\npublic interface UserRepository extends JpaRepository<User, Long> {\\\\n\\\\n    User findByUserName(String userName);\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/repository/UserRoleRepository.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.repository;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.UserRole;\\\\nimport org.springframework.data.jpa.repository.JpaRepository;\\\\n\\\\npublic interface UserRoleRepository extends JpaRepository<UserRole, Long> {\\\\n    UserRole findUserRoleByRoleName(String roleName);\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/UserService.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.service;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\n\\\\nimport java.util.List;\\\\n\\\\npublic interface UserService {\\\\n    List<User> getAllUser();\\\\n    User getUserById(Long id);\\\\n    User getUserByName(String userName);\\\\n    User saveUser(User user);\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/http/header/HeaderGenerator.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.service.http.header;\\\\n\\\\nimport jakarta.servlet.http.HttpServletRequest;\\\\nimport org.springframework.http.HttpHeaders;\\\\nimport org.springframework.stereotype.Service;\\\\n\\\\nimport java.net.URI;\\\\nimport java.net.URISyntaxException;\\\\n\\\\n@Service\\\\npublic class HeaderGenerator {\\\\n\\\\n    public HttpHeaders getHeadersSuccessGetMethod() {\\\\n        HttpHeaders httpHeaders = new HttpHeaders();\\\\n        httpHeaders.add(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"application/json; charset=UTF-8\\\\\\\");\\\\n        return httpHeaders;\\\\n    }\\\\n\\\\n    public HttpHeaders getHeadersError() {\\\\n        HttpHeaders httpHeaders = new HttpHeaders();\\\\n        httpHeaders.add(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"application/problem+json; charset=UTF-8\\\\\\\");\\\\n        return httpHeaders;\\\\n    }\\\\n\\\\n    public HttpHeaders getHeadersSuccessPostMethod(HttpServletRequest request, Long resourceId) {\\\\n        HttpHeaders httpHeaders = new HttpHeaders();\\\\n        try {\\\\n            httpHeaders.setLocation(new URI(request.getRequestURI() + \\\\\\\"/\\\\\\\" + resourceId));\\\\n        } catch (URISyntaxException e) {\\\\n            e.printStackTrace();\\\\n        }\\\\n        httpHeaders.add(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"application/json; charset=UTF-8\\\\\\\");\\\\n        return httpHeaders;\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.service.impl;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.entity.UserRole;\\\\nimport com.hoangtien2k3.userservice.repository.UserRepository;\\\\nimport com.hoangtien2k3.userservice.repository.UserRoleRepository;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.stereotype.Service;\\\\n\\\\nimport java.util.List;\\\\n\\\\n@Service\\\\npublic class UserServiceImpl implements UserService {\\\\n\\\\n    @Autowired\\\\n    private UserRepository userRepository;\\\\n\\\\n    @Autowired\\\\n    private UserRoleRepository userRoleRepository;\\\\n\\\\n    @Override\\\\n    public List<User> getAllUser() {\\\\n        return userRepository.findAll();\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserById(Long id) {\\\\n\\\\n        return userRepository.getOne(id);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserByName(String userName) {\\\\n        return userRepository.findByUserName(userName);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User saveUser(User user) {\\\\n\\\\n        user.setActive(1); // active success\\\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\\\\\"ROLE_USER\\\\\\\");\\\\n        user.setRole(role);\\\\n\\\\n        return userRepository.save(user);\\\\n    }\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/resources/application.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\nserver.port=8080\\\\nspring.application.name= user-service\\\\nserver.url= http://localhost:8080\\\\n\\\\n##Client registration properties :\\\\n#eureka.client.service-url.defaultZone = http://localhost:8070/eureka\\\\n\\\\nspring.datasource.url=jdbc:mysql://localhost:3306/userservice?useSSL=false\\\\nspring.datasource.username=root\\\\nspring.datasource.password=12042003\\\\n\\\\nspring.jpa.show-sql=true\\\\nspring.jpa.properties.hibernate=org.hibernate.dialect.MySQLDialect\\\\nspring.jpa.hibernate.ddl-auto= update\\\\n\\\\n##### HTTP #####\\\\nerror.404.schema.details=The resource you are looking for might have been removed, had its name changed, or is temporarily unavailable\\\\nerror.406.schema.details=This request is not acceptable. Supported MIME types are application/json\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/test/java/com/hoangtien2k3/userservice/UserServiceApplicationTests.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice;\\\\n\\\\nimport org.junit.jupiter.api.Test;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\n\\\\n@SpringBootTest\\\\nclass UserServiceApplicationTests {\\\\n\\\\n\\\\t@Test\\\\n\\\\tvoid contextLoads() {\\\\n\\\\t}\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/test/java/com/hoangtien2k3/userservice/controllertest/UserControllerTest.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.controllertest;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport org.junit.Test;\\\\nimport org.junit.runner.RunWith;\\\\nimport org.mockito.Mockito;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\nimport org.springframework.http.MediaType;\\\\nimport org.springframework.test.context.junit4.SpringRunner;\\\\nimport org.springframework.test.web.client.ExpectedCount;\\\\nimport org.springframework.test.web.servlet.MockMvc;\\\\nimport org.springframework.test.web.servlet.ResultMatcher;\\\\n\\\\nimport java.util.ArrayList;\\\\nimport java.util.List;\\\\n\\\\n\\\\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\\\\nimport static org.springframework.test.web.client.ExpectedCount.times;\\\\nimport static org.springframework.test.web.client.match.MockRestRequestMatchers.content;\\\\nimport static org.springframework.test.web.client.match.MockRestRequestMatchers.jsonPath;\\\\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\\\\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\\\\n\\\\n@AutoConfigureMockMvc\\\\n@RunWith(SpringRunner.class)\\\\n@SpringBootTest\\\\npublic class UserControllerTest {\\\\n    private final Long USER_ID = 1L;\\\\n    private final String USER_NAME = \\\\\\\"test\\\\\\\";\\\\n    private User user;\\\\n    private List<User> listUsers;\\\\n\\\\n    @Autowired\\\\n    private MockMvc mockMvc;\\\\n\\\\n    @Autowired\\\\n    private UserService userService;\\\\n\\\\n    @Test\\\\n    public void getAllUserController_Should_Return200_When_ValidRequest() throws Exception {\\\\n/*\\\\n        User user1 = User.builder()\\\\n                .id(USER_ID)\\\\n                .userName(USER_NAME)\\\\n                .build();\\\\n\\\\n        listUsers = new ArrayList<>();\\\\n        listUsers.add(user1);\\\\n\\\\n        Mockito.when(userService.getAllUser()).thenReturn(listUsers);\\\\n\\\\n        //then\\\\n        mockMvc.perform(get(\\\\\\\"/users\\\\\\\"))\\\\n                .andExpect(status().isOk())\\\\n                .andExpect((ResultMatcher) content().contentType(MediaType.APPLICATION_JSON_UTF8))\\\\n                .andExpect((ResultMatcher) jsonPath(\\\\\\\"$[0].id\\\\\\\").value(USER_ID))\\\\n                .andExpect((ResultMatcher) jsonPath(\\\\\\\"$[0].userName\\\\\\\").value(USER_NAME));\\\\n\\\\n        verify(userService, times(1)).getAllUsers();\\\\n        verifyNoMoreInteractions(userService);\\\\n*/\\\\n\\\\n\\\\n    }\\\\n\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/test/java/com/hoangtien2k3/userservice/servicetest/UserControllerTest.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.servicetest;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.repository.UserRepository;\\\\nimport com.hoangtien2k3.userservice.service.impl.UserServiceImpl;\\\\nimport org.junit.Before;\\\\nimport org.junit.Test;\\\\nimport org.junit.runner.RunWith;\\\\nimport org.mockito.InjectMocks;\\\\nimport org.mockito.Mock;\\\\nimport org.mockito.Mockito;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\nimport org.springframework.test.context.junit4.SpringRunner;\\\\n\\\\nimport java.util.ArrayList;\\\\nimport java.util.List;\\\\n\\\\nimport static org.junit.Assert.assertEquals;\\\\nimport static org.mockito.ArgumentMatchers.anyLong;\\\\nimport static org.mockito.ArgumentMatchers.anyString;\\\\n\\\\n\\\\n@SpringBootTest\\\\n@RunWith(SpringRunner.class)\\\\npublic class UserControllerTest {\\\\n\\\\n    private final Long USER_ID = 2L;\\\\n    private final String USER_NAME = \\\\\\\"test\\\\\\\";\\\\n    private List<User> userList;\\\\n    private User user;\\\\n\\\\n    @Mock\\\\n    private UserRepository userRepository;\\\\n\\\\n    @InjectMocks\\\\n    private UserServiceImpl userService;\\\\n\\\\n    @Before\\\\n    public void setUp() {\\\\n        user = User.builder()\\\\n                .id(USER_ID)\\\\n                .userName(USER_NAME)\\\\n                .build();\\\\n\\\\n        userList = new ArrayList<>();\\\\n        userList.add(user);\\\\n    }\\\\n\\\\n    @Test\\\\n    public void get_AllUser_Test() {\\\\n        // give\\\\n        Mockito.when(userRepository.findAll()).thenReturn(userList);\\\\n\\\\n        // when\\\\n        List<User> foundUsers = userService.getAllUser();\\\\n\\\\n        // then\\\\n        assertEquals(foundUsers.get(0).getUserName(), USER_NAME);\\\\n        Mockito.verify(userRepository, Mockito.times(1)).findAll();\\\\n        Mockito.verifyNoMoreInteractions(userRepository);\\\\n    }\\\\n\\\\n    @Test\\\\n    public void get_UserById_Test(){\\\\n        // given\\\\n        Mockito.when(userRepository.getOne(anyLong())).thenReturn(user);\\\\n\\\\n        // when\\\\n        User foundUser = userService.getUserById(USER_ID);\\\\n\\\\n        // then\\\\n        assertEquals(foundUser.getUserName(), USER_NAME);\\\\n        Mockito.verify(userRepository, Mockito.times(1)).getOne(anyLong());\\\\n        Mockito.verifyNoMoreInteractions(userRepository);\\\\n    }\\\\n\\\\n    @Test\\\\n    public void get_UserByName_Test(){\\\\n        // given\\\\n        Mockito.when(userRepository.findByUserName(anyString())).thenReturn(user);\\\\n\\\\n        // when\\\\n        User foundUser = userService.getUserByName(USER_NAME);\\\\n\\\\n        // then\\\\n        assertEquals(foundUser.getId(), USER_ID);\\\\n        Mockito.verify(userRepository, Mockito.times(1)).findByUserName(USER_NAME);\\\\n        Mockito.verifyNoMoreInteractions(userRepository);\\\\n    }\\\\n\\\\n\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"security\", \"line_number\": 8, \"file\": \"order-serivce/src/main/resources/application.properties\", \"description\": \"데이터베이스 접속 정보(username, password)가 설정 파일에 하드코딩되어 있습니다. 이는 보안상 매우 취약합니다.\", \"suggestion\": \"데이터베이스 접속 정보는 환경 변수, 외부 설정 서버(예: Spring Cloud Config), 또는 시크릿 관리 시스템(예: Vault, Kubernetes Secrets)을 사용하여 관리해야 합니다.\", \"severity\": \"error\", \"target_code\": \"spring.datasource.username=root\\nspring.datasource.password=12042003\", \"suggested_code\": null}, {\"type\": \"security\", \"line_number\": 9, \"file\": \"user-service/src/main/resources/application.properties\", \"description\": \"데이터베이스 접속 정보(username, password)가 설정 파일에 하드코딩되어 있습니다. 이는 보안상 매우 취약합니다.\", \"suggestion\": \"데이터베이스 접속 정보는 환경 변수, 외부 설정 서버(예: Spring Cloud Config), 또는 시크릿 관리 시스템(예: Vault, Kubernetes Secrets)을 사용하여 관리해야 합니다.\", \"severity\": \"error\", \"target_code\": \"spring.datasource.username=root\\nspring.datasource.password=12042003\", \"suggested_code\": null}, {\"type\": \"security\", \"line_number\": 21, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/User.java\", \"description\": \"사용자 비밀번호 필드(userPassword)의 길이가 50자로 설정되어 있습니다. 안전한 비밀번호 해싱 알고리즘(예: BCrypt)으로 암호화된 비밀번호를 저장하기에는 길이가 너무 짧습니다. 또한, 비밀번호가 해싱되지 않고 저장될 가능성이 있습니다.\", \"suggestion\": \"비밀번호는 반드시 BCrypt와 같은 강력한 단방향 해싱 알고리즘으로 암호화하여 저장해야 합니다. 비밀번호 해시를 저장할 필드의 길이는 해싱 알고리즘의 출력 길이를 고려하여 충분히 길게 설정하세요 (예: BCrypt의 경우 60자 이상).\", \"severity\": \"error\", \"target_code\": \"@Column(name = \\\"user_password\\\", nullable = false, length = 50)\\n    private String userPassword;\", \"suggested_code\": \"@Column(name = \\\"user_password\\\", nullable = false, length = 100) // BCrypt 해시를 저장하기 위한 충분한 길이\\n    private String userPassword;\"}, {\"type\": \"security\", \"line_number\": 37, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"사용자 비밀번호를 저장하기 전에 해싱하는 로직이 없습니다. 비밀번호를 평문으로 저장하는 것은 심각한 보안 취약점입니다.\", \"suggestion\": \"Spring Security의 PasswordEncoder(예: BCryptPasswordEncoder)를 사용하여 사용자 비밀번호를 저장하기 전에 반드시 해싱해야 합니다.\", \"severity\": \"error\", \"target_code\": \"return userRepository.save(user);\", \"suggested_code\": \"user.setUserPassword(passwordEncoder.encode(user.getUserPassword()));\\n        return userRepository.save(user);\"}, {\"type\": \"bug\", \"line_number\": 30, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/controller/RegisterController.java\", \"description\": \"광범위한 Exception을 catch하고 있습니다. 이는 예상치 못한 오류를 숨기고 디버깅을 어렵게 만들 수 있습니다. 또한, 스택 트레이스를 콘솔에 출력하는 것은 운영 환경에서 부적절하며, 민감한 정보가 노출될 위험이 있습니다.\", \"suggestion\": \"구체적인 예외를 catch하고 각 예외에 맞는 적절한 처리를 수행하세요. 예외 발생 시에는 로깅 프레임워크(예: SLF4J)를 사용하여 오류를 기록해야 합니다. 클라이언트에게는 일반적인 오류 메시지를 반환하는 것이 좋습니다.\", \"severity\": \"error\", \"target_code\": \"}catch (Exception e) {\\n                e.printStackTrace();\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\n            }\", \"suggested_code\": \"} catch (DataIntegrityViolationException e) { // 예시: 데이터베이스 제약 조건 위반\\n                // 로깅: log.error(\\\"Failed to save user due to data integrity violation\\\", e);\\n                return new ResponseEntity<>(HttpStatus.CONFLICT); // 409 Conflict\\n            } catch (Exception e) { // 그 외 예상치 못한 오류\\n                // 로깅: log.error(\\\"An unexpected error occurred while saving user\\\", e);\\n                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); // 500 Internal Server Error\\n            }\"}, {\"type\": \"bug\", \"line_number\": 60, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/controller/UserController.java\", \"description\": \"광범위한 Exception을 catch하고 있습니다. 이는 예상치 못한 오류를 숨기고 디버깅을 어렵게 만들 수 있습니다. 또한, 스택 트레이스를 콘솔에 출력하는 것은 운영 환경에서 부적절하며, 민감한 정보가 노출될 위험이 있습니다.\", \"suggestion\": \"구체적인 예외를 catch하고 각 예외에 맞는 적절한 처리를 수행하세요. 예외 발생 시에는 로깅 프레임워크(예: SLF4J)를 사용하여 오류를 기록해야 합니다. 클라이언트에게는 일반적인 오류 메시지를 반환하는 것이 좋습니다.\", \"severity\": \"error\", \"target_code\": \"} catch (Exception e) {\\n                e.printStackTrace();\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\n            }\", \"suggested_code\": \"} catch (DataIntegrityViolationException e) { // 예시: 데이터베이스 제약 조건 위반\\n                // 로깅: log.error(\\\"Failed to save user due to data integrity violation\\\", e);\\n                return new ResponseEntity<>(HttpStatus.CONFLICT); // 409 Conflict\\n            } catch (Exception e) { // 그 외 예상치 못한 오류\\n                // 로깅: log.error(\\\"An unexpected error occurred while saving user\\\", e);\\n                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); // 500 Internal Server Error\\n            }\"}, {\"type\": \"bug\", \"line_number\": 28, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/controller/UserController.java\", \"description\": \"사용자 목록이 비어 있을 때 HTTP 상태 코드 404 Not Found를 반환하고 있습니다. 컬렉션 리소스에 대한 GET 요청에서 결과가 없을 때는 일반적으로 200 OK와 빈 목록을 반환하는 것이 RESTful API의 표준입니다.\", \"suggestion\": \"사용자 목록이 비어 있더라도 200 OK 상태 코드와 빈 리스트를 반환하도록 수정하세요.\", \"severity\": \"warning\", \"target_code\": \"if (!users.isEmpty()) {\\n            return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\n        }\\n        return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\", \"suggested_code\": \"return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\"}, {\"type\": \"bug\", \"line_number\": 28, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"사용자 ID로 조회 시 `userRepository.getOne(id)`를 사용하고 있습니다. `getOne`은 Spring Data JPA 2.x부터 deprecated되었으며, `getReferenceById`로 대체되었습니다. 이 메서드는 실제 엔티티를 즉시 로드하지 않고 프록시를 반환할 수 있으며, 엔티티가 존재하지 않을 경우 `EntityNotFoundException`이 발생할 수 있습니다. 일반적으로 ID로 단일 엔티티를 조회할 때는 `findById`를 사용하는 것이 권장됩니다.\", \"suggestion\": \"`userRepository.findById(id)`를 사용하여 `Optional<User>`를 반환받고, 결과가 없을 경우 적절히 처리하세요 (예: null 반환 또는 예외 발생).\", \"severity\": \"warning\", \"target_code\": \"return userRepository.getOne(id);\", \"suggested_code\": \"return userRepository.findById(id).orElse(null); // 또는 Optional<User> 반환 및 호출부에서 처리\"}, {\"type\": \"style\", \"line_number\": 6, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/User.java\", \"description\": \"Lombok의 `@Data` 어노테이션은 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`를 포함합니다. 이미 `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor`, `@Builder`를 사용하고 있으므로 `@Data`는 중복이며, 특히 양방향 연관 관계에서 `@ToString` 및 `@EqualsAndHashCode`로 인해 StackOverflowError가 발생할 수 있습니다.\", \"suggestion\": \"`@Data` 어노테이션을 제거하고 필요한 Lombok 어노테이션만 명시적으로 사용하거나, `@Data`를 사용하되 연관 관계 필드에 `@ToString.Exclude` 및 `@EqualsAndHashCode.Exclude`를 추가하여 문제를 방지하세요.\", \"severity\": \"warning\", \"target_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Builder\\n@Entity\\n@Table(name = \\\"users\\\")\", \"suggested_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Builder\\n@Entity\\n@Table(name = \\\"users\\\")\\n// @Data 사용 시:\\n// @Data\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private UserDetails userDetails;\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private UserRole role;\"}, {\"type\": \"style\", \"line_number\": 10, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserDetails.java\", \"description\": \"Lombok의 `@Data` 어노테이션은 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`를 포함합니다. 이미 `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor`를 사용하고 있으므로 `@Data`는 중복이며, 특히 양방향 연관 관계에서 `@ToString` 및 `@EqualsAndHashCode`로 인해 StackOverflowError가 발생할 수 있습니다.\", \"suggestion\": \"`@Data` 어노테이션을 제거하고 필요한 Lombok 어노테이션만 명시적으로 사용하거나, `@Data`를 사용하되 연관 관계 필드에 `@ToString.Exclude` 및 `@EqualsAndHashCode.Exclude`를 추가하여 문제를 방지하세요.\", \"severity\": \"warning\", \"target_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Data\\n@Entity\\n@Table(name = \\\"users_details\\\")\", \"suggested_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Entity\\n@Table(name = \\\"users_details\\\")\\n// @Data 사용 시:\\n// @Data\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private User user;\"}, {\"type\": \"style\", \"line_number\": 10, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserRole.java\", \"description\": \"Lombok의 `@Data` 어노테이션은 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`를 포함합니다. 이미 `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor`를 사용하고 있으므로 `@Data`는 중복이며, 특히 양방향 연관 관계에서 `@ToString` 및 `@EqualsAndHashCode`로 인해 StackOverflowError가 발생할 수 있습니다.\", \"suggestion\": \"`@Data` 어노테이션을 제거하고 필요한 Lombok 어노테이션만 명시적으로 사용하거나, `@Data`를 사용하되 연관 관계 필드에 `@ToString.Exclude` 및 `@EqualsAndHashCode.Exclude`를 추가하여 문제를 방지하세요.\", \"severity\": \"warning\", \"target_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Data\\n@Entity\\n@Table(name = \\\"user_role\\\")\", \"suggested_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Entity\\n@Table(name = \\\"user_role\\\")\\n// @Data 사용 시:\\n// @Data\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private List<User> users;\"}, {\"type\": \"style\", \"line_number\": 25, \"file\": \"user-service/src/test/java/com/hoangtien2k3/userservice/controllertest/UserControllerTest.java\", \"description\": \"JUnit 4 어노테이션(`@Test`, `@RunWith`)이 사용되었습니다. Spring Boot 3.x는 JUnit 5를 기본으로 사용하므로, 테스트 프레임워크를 JUnit 5로 통일하는 것이 좋습니다.\", \"suggestion\": \"JUnit 5 어노테이션(`org.junit.jupiter.api.Test`, `@ExtendWith(SpringExtension.class)`)으로 변경하세요. `SpringRunner` 대신 `SpringExtension`을 사용합니다.\", \"severity\": \"info\", \"target_code\": \"import org.junit.Test;\\nimport org.junit.runner.RunWith;\", \"suggested_code\": \"import org.junit.jupiter.api.Test;\\nimport org.junit.jupiter.api.extension.ExtendWith;\\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\"}, {\"type\": \"style\", \"line_number\": 22, \"file\": \"user-service/src/test/java/com/hoangtien2k3/userservice/servicetest/UserControllerTest.java\", \"description\": \"JUnit 4 어노테이션(`@Test`, `@Before`, `@RunWith`)이 사용되었습니다. Spring Boot 3.x는 JUnit 5를 기본으로 사용하므로, 테스트 프레임워크를 JUnit 5로 통일하는 것이 좋습니다.\", \"suggestion\": \"JUnit 5 어노테이션(`org.junit.jupiter.api.Test`, `org.junit.jupiter.api.BeforeEach`, `@ExtendWith(SpringExtension.class)`)으로 변경하세요. `SpringRunner` 대신 `SpringExtension`을 사용합니다.\", \"severity\": \"info\", \"target_code\": \"import org.junit.Before;\\nimport org.junit.Test;\\nimport org.junit.runner.RunWith;\", \"suggested_code\": \"import org.junit.jupiter.api.BeforeEach;\\nimport org.junit.jupiter.api.Test;\\nimport org.junit.jupiter.api.extension.ExtendWith;\\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\"}, {\"type\": \"style\", \"line_number\": 12, \"file\": \"user-service/pom.xml\", \"description\": \"Spring Boot 3.x는 Jakarta EE 기반이므로 `javax.validation` 대신 `jakarta.validation`을 사용해야 합니다. `spring-boot-starter-validation` 의존성을 사용하면 자동으로 `jakarta.validation-api`와 구현체(Hibernate Validator)가 포함됩니다.\", \"suggestion\": \"`javax.validation:validation-api` 의존성을 제거하세요. `spring-boot-starter-validation`이 이미 Jakarta Validation API를 제공합니다.\", \"severity\": \"warning\", \"target_code\": \"<dependency>\\n\\t\\t\\t<groupId>javax.validation</groupId>\\n\\t\\t\\t<artifactId>validation-api</artifactId>\\n\\t\\t\\t<version>2.0.0.Final</version>\\n\\t\\t</dependency>\", \"suggested_code\": null}, {\"type\": \"style\", \"line_number\": 13, \"file\": \"user-service/pom.xml\", \"description\": \"JUnit 4 의존성(`junit:junit`)이 추가되었습니다. Spring Boot Starter Test는 기본적으로 JUnit 5(Jupiter)를 포함하므로, JUnit 4와 5를 함께 사용하는 것은 혼란을 야기할 수 있습니다. JUnit 5로 테스트 프레임워크를 통일하는 것이 좋습니다.\", \"suggestion\": \"`junit:junit` 의존성을 제거하고 모든 테스트를 JUnit 5로 마이그레이션하세요.\", \"severity\": \"info\", \"target_code\": \"<dependency>\\n\\t\\t\\t<groupId>junit</groupId>\\n\\t\\t\\t<artifactId>junit</artifactId>\\n\\t\\t\\t<scope>test</scope>\\n\\t\\t</dependency>\", \"suggested_code\": null}, {\"type\": \"performance\", \"line_number\": 15, \"file\": \"order-serivce/src/main/resources/application.properties\", \"description\": \"`spring.jpa.ddl-auto=update` 설정은 애플리케이션 시작 시 JPA가 데이터베이스 스키마를 자동으로 업데이트하도록 합니다. 개발 단계에서는 편리하지만, 운영 환경에서는 예상치 못한 스키마 변경이나 데이터 손실을 유발할 수 있어 위험합니다.\", \"suggestion\": \"운영 환경에서는 `spring.jpa.ddl-auto` 설정을 `validate` 또는 `none`으로 변경하고, 스키마 변경은 Flyway나 Liquibase와 같은 마이그레이션 도구를 사용하여 관리하는 것이 안전합니다.\", \"severity\": \"warning\", \"target_code\": \"spring.jpa.ddl-auto=update\", \"suggested_code\": \"spring.jpa.ddl-auto=validate # 또는 none\"}, {\"type\": \"performance\", \"line_number\": 14, \"file\": \"user-service/src/main/resources/application.properties\", \"description\": \"`spring.jpa.hibernate.ddl-auto= update` 설정은 애플리케이션 시작 시 JPA가 데이터베이스 스키마를 자동으로 업데이트하도록 합니다. 개발 단계에서는 편리하지만, 운영 환경에서는 예상치 못한 스키마 변경이나 데이터 손실을 유발할 수 있어 위험합니다.\", \"suggestion\": \"운영 환경에서는 `spring.jpa.hibernate.ddl-auto` 설정을 `validate` 또는 `none`으로 변경하고, 스키마 변경은 Flyway나 Liquibase와 같은 마이그레이션 도구를 사용하여 관리하는 것이 안전합니다.\", \"severity\": \"warning\", \"target_code\": \"spring.jpa.hibernate.ddl-auto= update\", \"suggested_code\": \"spring.jpa.hibernate.ddl-auto= validate # 또는 none\"}, {\"type\": \"bug\", \"line_number\": 13, \"file\": \"user-service/src/main/resources/application.properties\", \"description\": \"`spring.jpa.properties.hibernate=org.hibernate.dialect.MySQLDialect` 속성 키가 잘못되었습니다. 올바른 속성 키는 `spring.jpa.properties.hibernate.dialect`입니다.\", \"suggestion\": \"속성 키를 `spring.jpa.properties.hibernate.dialect`로 수정하세요.\", \"severity\": \"error\", \"target_code\": \"spring.jpa.properties.hibernate=org.hibernate.dialect.MySQLDialect\", \"suggested_code\": \"spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\"}], \"summary\": \"초기 Spring Boot 프로젝트 설정 및 기본 CRUD 기능 구현입니다. 데이터베이스 연결, JPA 엔티티 및 레포지토리, 기본적인 서비스 및 컨트롤러 레이어가 구성되었습니다. Maven Wrapper 및 POM 파일 설정, 애플리케이션 진입점, 속성 파일 설정 등이 포함됩니다. 전반적으로 기본적인 구조는 갖추었으나, 보안, 오류 처리, 의존성 관리, 테스트 코드 등 여러 측면에서 개선이 필요합니다.\", \"score\": 3.0, \"recommendations\": [\"데이터베이스 접속 정보 및 민감한 설정은 환경 변수나 외부 설정 관리 시스템을 사용하세요.\", \"사용자 비밀번호는 반드시 강력한 해싱 알고리즘으로 암호화하여 저장하고, 로그인 시 검증 로직을 추가하세요.\", \"예외 처리를 구체화하고, 로깅 프레임워크를 사용하여 오류를 기록하세요. 클라이언트에게는 상세한 스택 트레이스 대신 일반적인 오류 응답을 제공하세요.\", \"Spring Boot 3.x 환경에 맞게 Jakarta EE 기반의 의존성(예: `jakarta.validation`)을 사용하고, JUnit 5로 테스트 프레임워크를 통일하세요.\", \"JPA `ddl-auto` 설정은 운영 환경에서 `validate` 또는 `none`으로 변경하고, 스키마 변경은 마이그레이션 도구를 사용하세요.\", \"Lombok `@Data` 사용 시 양방향 연관 관계에서 StackOverflowError가 발생하지 않도록 `@ToString.Exclude`, `@EqualsAndHashCode.Exclude`를 사용하거나 `@Data` 대신 필요한 어노테이션만 명시적으로 사용하세요.\", \"`userRepository.getOne` 대신 `userRepository.findById`를 사용하고 `Optional` 결과를 처리하도록 코드를 수정하세요.\", \"테스트 코드를 작성하고 실행하여 코드의 신뢰성을 높이세요. 현재 주석 처리된 테스트 코드를 활성화하고 완성하세요.\", \"컨트롤러에서 빈 목록 응답 시 404 대신 200 OK를 반환하도록 수정하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"line_number\\\": 56}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"line_number\\\": 166}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 4}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"Git diff 대상 지정을 위한 CLI 옵션(--staged, --target-commit, --target-branch)이 추가되었고, 이를 지원하도록 `run_git_diff` 함수가 리팩토링되었습니다. 변경 사항은 코드의 유연성과 기능성을 향상시킵니다.\", \"score\": 9.0, \"recommendations\": [\"새로 추가된 `run_git_diff` 함수의 다양한 옵션 조합(--staged, --target-commit, --target-branch)에 대한 단위 테스트를 추가하여 기능의 정확성을 보장하는 것이 좋습니다.\", \"CLI 명령어의 도움말 출력 방식에 일관성을 부여하기 위해, `handle_config_command` 및 `handle_results_command` 함수에서 직접 `logger.info`로 도움말을 출력하는 대신 `argparse`의 도움말 기능을 활용하는 것을 고려해볼 수 있습니다.\", \"`config_list` 함수에서 API 키를 마스킹하는 로직이 하드코딩되어 있습니다. 향후 다른 제공자의 API 키가 추가될 경우 중복이 발생할 수 있으므로, API 키 마스킹을 위한 별도의 헬퍼 함수를 만들어 재사용성을 높이는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"before_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-1.5-pro-001\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-1.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 1.5 Pro 모델, 안정적인 성능과 긴 컨텍스트 지원\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-1.5-flash-001\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-1.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 1.5 Flash 모델, 빠른 속도와 경제적인 비용\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n    \\\\\\\"gemini-1.5-pro\\\\\\\": \\\\\\\"gemini-1.5-pro-001\\\\\\\",\\\\n    \\\\\\\"gemini-1.5-flash\\\\\\\": \\\\\\\"gemini-1.5-flash-001\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 122, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"before_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            genai.Client: Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 34, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom google import genai\\\\nfrom google.genai.types import HttpOptions\\\\n```\\\", \\\"line_number\\\": 5, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n                from reviewer.src.llm_gateway import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(\\\\n                    api_key=api_key, http_options=HttpOptions(api_version=\\\\\\\"v1\\\\\\\")\\\\n                )\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                if \\\\\\\"2.5\\\\\\\" in model_name:\\\\n                    if \\\\\\\"flash\\\\\\\" in model_name:\\\\n                        model_name = \\\\\\\"gemini-1.5-flash-001\\\\\\\"\\\\n                    else:\\\\n                        model_name = \\\\\\\"gemini-1.5-pro-001\\\\\\\"\\\\n                elif \\\\\\\"1.5\\\\\\\" in model_name:\\\\n                    if \\\\\\\"flash\\\\\\\" in model_name:\\\\n                        model_name = \\\\\\\"gemini-1.5-flash-001\\\\\\\"\\\\n                    else:\\\\n                        model_name = \\\\\\\"gemini-1.5-pro-001\\\\\\\"\\\\n                else:\\\\n                    # 기본값으로 설정\\\\n                    model_name = \\\\\\\"gemini-1.5-flash-001\\\\\\\"\\\\n\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n```\\\", \\\"line_number\\\": 39, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 116, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 124, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"5\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n```\\\", \\\"line_number\\\": 156, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"6\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 169, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 58, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Gemini 모델의 토큰 계산 시, 모델 이름 매핑 로직에 오류가 있습니다. '2.5' 버전 모델이 '1.5' 버전 모델로 잘못 매핑되고 있습니다. 이로 인해 실제 사용하려는 모델과 다른 모델로 토큰 계산이 시도될 수 있습니다.\", \"suggestion\": \"입력된 모델 이름을 기반으로 `available_models.py`에 정의된 전체 모델 이름(`full_name`)을 찾아 사용해야 합니다. 하드코딩된 매핑 대신, 모델 정보 딕셔너리를 활용하여 정확한 모델 이름을 가져오도록 수정하세요.\", \"severity\": \"error\", \"target_code\": \"if \\\"2.5\\\" in model_name:\\n    if \\\"flash\\\" in model_name:\\n        model_name = \\\"gemini-1.5-flash-001\\\"\\n    else:\\n        model_name = \\\"gemini-1.5-pro-001\\\"\\nelif \\\"1.5\\\" in model_name:\\n    if \\\"flash\\\" in model_name:\\n        model_name = \\\"gemini-1.5-flash-001\\\"\\n    else:\\n        model_name = \\\"gemini-1.5-pro-001\\\"\", \"suggested_code\": \"# 모델 이름 매핑 로직 수정 (예시)\\nfrom reviewer.src.available_models import AVAILABLE_MODELS, MODEL_ALIASES\\n\\n# 입력된 model 이름을 기반으로 실제 모델 정보 찾기\\n# 이 로직은 count_tokens 함수 외부에서 모델 정보를 미리 가져와 전달하는 것이 더 효율적일 수 있습니다.\\nmodel_info = None\\nfor full_name, info in AVAILABLE_MODELS.items():\\n    if info[\\\"provider\\\"] == \\\"google\\\" and (model.lower() == full_name.lower() or model.lower() in [alias.lower() for alias in info.get(\\\"aliases\\\", [])]):\\n        model_info = info\\n        break\\n\\nif model_info:\\n    model_name_for_api = model_info[\\\"full_name\\\"]\\n    # ... client.models.count_tokens(model=model_name_for_api, contents=text)\\nelse:\\n    # 모델 정보를 찾지 못한 경우의 처리 (예: 오류 발생 또는 기본값 사용)\\n    print(f\\\"경고: 알 수 없는 Gemini 모델 '{model}' 입니다. 기본값 사용 또는 오류 처리 필요.\\\")\\n    model_name_for_api = \\\"gemini-1.5-flash-001\\\" # 또는 다른 기본값/오류 처리\"}, {\"type\": \"style\", \"line_number\": 75, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"토큰 계산 중 발생하는 예외를 너무 광범위하게(Exception) 처리하고 있습니다. 이는 예상치 못한 오류까지 모두 잡아내어 디버깅을 어렵게 만들 수 있습니다. Google GenAI API에서 발생할 수 있는 특정 예외(예: API 오류, 네트워크 오류)만 명시적으로 처리하는 것이 좋습니다.\", \"suggestion\": \"`except Exception as e:` 대신 `google.api_core.exceptions` 모듈 등에서 제공하는 구체적인 예외 타입을 명시하여 처리하세요. 이를 통해 어떤 종류의 오류가 발생했는지 더 명확하게 파악할 수 있습니다.\", \"severity\": \"warning\", \"target_code\": \"except Exception as e:\", \"suggested_code\": \"except (google.api_core.exceptions.GoogleAPIError, ConnectionError) as e: # 예시\\n    print(f\\\"Gemini API 오류 또는 네트워크 문제 발생: {e}\\\")\\n    # ... 대체 로직 ...\\nexcept Exception as e: # 예상치 못한 다른 오류를 위한 마지막 예외 처리 (선택 사항)\\n    print(f\\\"예상치 못한 오류 발생: {e}\\\")\\n    # ... 오류 처리 ...\\n\"}, {\"type\": \"performance\", \"line_number\": 46, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`count_tokens` 함수 내부에서 `get_api_key(\\\"google\\\")`를 호출하여 API 키를 가져오고 `genai.Client` 객체를 생성하고 있습니다. 이 함수가 여러 번 호출될 경우, 매번 API 키를 가져오고 클라이언트를 새로 생성하는 것은 비효율적일 수 있습니다.\", \"suggestion\": \"API 키는 애플리케이션 시작 시 한 번만 가져오거나, `genai.Client` 객체를 생성하여 재사용하는 것이 좋습니다. `count_tokens` 함수에는 이미 생성된 클라이언트 객체나 API 키를 인자로 전달하는 방식으로 리팩토링을 고려해 보세요.\", \"severity\": \"info\", \"target_code\": \"api_key = get_api_key(\\\"google\\\")\\n\\n# Client 객체 생성\\nclient = genai.Client(\\n    api_key=api_key, http_options=HttpOptions(api_version=\\\"v1\\\")\\n)\", \"suggested_code\": \"# count_tokens 함수 시그니처 변경 고려:\\n# def count_tokens(model: str, text: str, client: genai.Client | None = None) -> int:\\n# 함수 호출 시 클라이언트 전달:\\n# if client is None:\\n#     # 클라이언트가 전달되지 않은 경우에만 생성 (또는 오류 발생)\\n#     api_key = get_api_key(\\\"google\\\") # 이 부분도 외부에서 처리하는 것이 좋음\\n#     client = genai.Client(api_key=api_key, http_options=HttpOptions(api_version=\\\"v1\\\"))\\n# ... 기존 로직 ...\\n\"}], \"summary\": \"Google Gemini 모델 지원을 추가하는 변경사항입니다. CLI 옵션, 사용 가능한 모델 목록, 게이트웨이 팩토리, LLM 클라이언트 팩토리, 토큰 계산 유틸리티 등 여러 파일에 걸쳐 수정이 이루어졌습니다.\", \"score\": 6.0, \"recommendations\": [\"토큰 계산 로직에서 모델 이름 매핑 오류를 수정하여 정확한 모델로 토큰 수를 계산하도록 개선해야 합니다.\", \"예외 처리를 더 구체적으로 하여 디버깅 용이성을 높여야 합니다.\", \"API 키 로딩 및 LLM 클라이언트 생성 로직을 최적화하여 성능을 개선할 수 있습니다. 특히 토큰 계산 함수 내에서의 반복적인 클라이언트 생성은 피하는 것이 좋습니다.\", \"새로 추가된 Google Gemini 기능에 대한 단위 테스트를 작성하여 기능의 정확성과 안정성을 확보해야 합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"코드 변경 사항은 `review_focus` 기능을 제거하고 관련 코드를 정리합니다.\", \"score\": 10.0, \"recommendations\": [\"`review_focus` 기능 제거가 의도된 변경인지 확인하세요. 변경 사항 자체는 관련 코드를 깔끔하게 제거했습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\nfrom reviewer.src.diff_parser import run_git_diff, parse_git_diff\\\\nfrom reviewer.src.llm_gateway import get_llm_gateway, ReviewRequest\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.config import get_api_key, set_api_key, get_default_results_dir, set_default_results_dir, get_default_model, set_default_model, get_default_raw_log_dir, get_default_review_request_dir\\\\n\\\\ndef parse_args():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\nfrom reviewer.src.diff_parser import run_git_diff, parse_git_diff\\\\nfrom reviewer.src.llm_gateway import get_llm_gateway, ReviewRequest\\\\nfrom reviewer.src.available_models import get_supported_models, get_default_model\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.config import get_api_key, set_api_key, get_default_results_dir, set_default_results_dir, get_default_review_request_dir\\\\n\\\\ndef parse_args():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 9, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n    results_dir_parser = config_subparsers.add_parser('results-dir', help='결과 저장 디렉토리 설정')\\\\n    results_dir_parser.add_argument('path', nargs='?', help='저장 경로 (입력하지 않으면 현재 설정 표시)')\\\\n    \\\\n    # 기본 모델 설정\\\\n    model_parser = config_subparsers.add_parser('model', help='기본 모델 설정')\\\\n    model_parser.add_argument('name', nargs='?', choices=get_supported_models(),\\\\n                             help='모델 이름 (입력하지 않으면 현재 설정 표시)')\\\\n    \\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser('list', help='모든 설정 표시')\\\\n    \\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    results_dir_parser = config_subparsers.add_parser('results-dir', help='결과 저장 디렉토리 설정')\\\\n    results_dir_parser.add_argument('path', nargs='?', help='저장 경로 (입력하지 않으면 현재 설정 표시)')\\\\n    \\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser('list', help='모든 설정 표시')\\\\n    \\\\n```\\\", \\\"line_number\\\": 53, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\ndef config_model(args):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, 'name') or not args.name:\\\\n        # 현재 설정 표시\\\\n        current_model = get_default_model()\\\\n        print(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        \\\\n        # 지원 모델 목록 표시\\\\n        print(\\\\\\\"\\\\\\\\n지원되는 모델:\\\\\\\")\\\\n        for model in get_supported_models():\\\\n            print(f\\\\\\\"  - {model}\\\\\\\")\\\\n        return\\\\n    \\\\n    # 새 모델 저장\\\\n    if set_default_model(args.name):\\\\n        print(f\\\\\\\"기본 모델이 {args.name}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n\\\\ndef config_list():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\ndef config_list():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 164, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n        config_api_key(args)\\\\n    elif args.config_command == 'results-dir':\\\\n        config_results_dir(args)\\\\n    elif args.config_command == 'model':\\\\n        config_model(args)\\\\n    elif args.config_command == 'list':\\\\n        config_list()\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        config_api_key(args)\\\\n    elif args.config_command == 'results-dir':\\\\n        config_results_dir(args)\\\\n    elif args.config_command == 'list':\\\\n        config_list()\\\\n\\\\n```\\\", \\\"line_number\\\": 205, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n}\\\\n\\\\ndef get_model_info(model_name: str) -> Optional[ModelInfoDict]:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n}\\\\n\\\\ndef get_model_info(model_name: str) -> Optional[ModelInfoDict]:\\\\n```\\\", \\\"line_number\\\": 74, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_models_by_provider(provider: ModelProvider) -> List[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 제공자의 모델 목록을 반환합니다.\\\\n    \\\\n    Args:\\\\n        provider: 모델 제공자\\\\n        \\\\n    Returns:\\\\n        List[str]: 해당 제공자의 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return [\\\\n        model_name \\\\n        for model_name, info in AVAILABLE_MODELS.items() \\\\n        if info[\\\\\\\"provider\\\\\\\"] == provider\\\\n    ] \\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\\\\\ No newline at end of file\\\\ndef get_default_model() -> str:\\\\n    return 'o4-mini'\\\\n```\\\", \\\"line_number\\\": 105, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"before_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n        return False\\\\n\\\\ndef get_default_model() -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    \\\\n    # 설정 파일에 지정된 경우\\\\n    if 'model' in config['default']:\\\\n        return config['default']['model']\\\\n    \\\\n    # 환경 변수 확인\\\\n    default_model = os.getenv('OPENAI_MODEL')\\\\n    if default_model:\\\\n        return default_model\\\\n    \\\\n    # 기본값\\\\n    return 'o4-mini'\\\\n\\\\ndef set_default_model(model: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config['default']['model'] = model\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n        return False\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n        return False\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n```\\\", \\\"line_number\\\": 148, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\nfrom openai import OpenAI\\\\nfrom anthropic import Anthropic\\\\nfrom reviewer.src.available_models import get_model_info, ModelInfoDict\\\\nfrom reviewer.src.config import get_api_key, get_default_model, get_default_raw_log_dir, get_default_review_prompt_dir\\\\nimport instructor\\\\nfrom datetime import datetime\\\\n\\\\n# 환경 변수 로드\\\\nload_dotenv('.env')\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom openai import OpenAI\\\\nfrom anthropic import Anthropic\\\\nfrom reviewer.src.available_models import get_model_info, ModelInfoDict\\\\nfrom reviewer.src.config import get_api_key, get_default_raw_log_dir, get_default_review_prompt_dir\\\\nimport instructor\\\\nfrom datetime import datetime\\\\nfrom reviewer.src.available_models import get_default_model\\\\n\\\\n# 환경 변수 로드\\\\nload_dotenv('.env')\\\\n```\\\", \\\"line_number\\\": 11, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"design\", \"line_number\": 107, \"file\": \"reviewer/src/available_models.py\", \"description\": \"기본 모델 이름이 코드에 하드코딩되었습니다. 이는 설정 파일이나 환경 변수를 통한 유연한 설정 변경을 불가능하게 만듭니다. 애플리케이션의 재사용성과 배포 편의성을 저해할 수 있습니다.\", \"suggestion\": \"기본 모델 설정을 다시 설정 파일 또는 환경 변수에서 읽어오도록 변경하여 유연성을 확보해야 합니다. `reviewer/src/config.py`에서 해당 로직을 복원하거나, 새로운 설정 로직을 구현하는 것을 고려하세요.\", \"severity\": \"error\", \"target_code\": \"return 'o4-mini'\", \"suggested_code\": null}, {\"type\": \"design\", \"line_number\": 53, \"file\": \"reviewer/cli.py\", \"description\": \"기본 모델을 설정하는 CLI 명령(`config model`)이 제거되었습니다. 이로 인해 사용자는 명령줄을 통해 기본 모델을 쉽게 변경할 수 없게 되었습니다.\", \"suggestion\": \"기본 모델 설정 기능을 CLI에 다시 추가하여 사용자가 쉽게 설정을 변경할 수 있도록 해야 합니다. `parse_args` 함수에 `model` 서브파서를 복원하고, `main` 함수에서 해당 명령을 처리하는 로직을 추가하세요.\", \"severity\": \"warning\", \"target_code\": \"config_subparsers.add_parser('list', help='모든 설정 표시')\", \"suggested_code\": null}, {\"type\": \"design\", \"line_number\": 164, \"file\": \"reviewer/cli.py\", \"description\": \"기본 모델 설정을 처리하는 `config_model` 함수가 제거되었습니다. 이는 프로그램적으로 기본 모델을 변경하고 저장하는 기능을 상실하게 합니다.\", \"suggestion\": \"`config_model` 함수를 복원하여 기본 모델 설정을 처리할 수 있도록 해야 합니다. 이 함수는 `reviewer/src/config.py`의 `set_default_model` 함수를 호출하는 로직을 포함해야 합니다.\", \"severity\": \"warning\", \"target_code\": \"def config_list():\", \"suggested_code\": null}, {\"type\": \"style\", \"line_number\": 107, \"file\": \"reviewer/src/available_models.py\", \"description\": \"`get_default_model` 함수에 Docstring이 없습니다. 함수의 목적과 반환 값을 명확히 설명하는 Docstring을 추가하여 코드 가독성을 높여야 합니다.\", \"suggestion\": \"함수 정의 바로 아래에 Docstring을 추가하세요.\", \"severity\": \"info\", \"target_code\": \"def get_default_model() -> str:\", \"suggested_code\": \"def get_default_model() -> str:\\n    \\\"\\\"\\\"기본 모델 이름을 반환합니다.\\\"\\\"\\\"\\n    return 'o4-mini'\"}, {\"type\": \"style\", \"line_number\": 108, \"file\": \"reviewer/src/available_models.py\", \"description\": \"파일 끝에 개행 문자가 없습니다. 일부 시스템이나 편집기에서 문제를 일으킬 수 있으며, 코드 스타일 가이드에 위배될 수 있습니다.\", \"suggestion\": \"파일 끝에 빈 줄을 추가하세요.\", \"severity\": \"info\", \"target_code\": \"return 'o4-mini'\", \"suggested_code\": null}], \"summary\": \"기본 모델 설정 방식이 코드 하드코딩으로 변경되었으며, CLI를 통한 설정 기능이 제거되었습니다. `get_default_model` 함수가 `config.py`에서 `available_models.py`로 이동했습니다. 새로운 모델 별칭이 추가되었습니다.\", \"score\": 3.0, \"recommendations\": [\"기본 모델 설정을 코드 하드코딩 대신 설정 파일 또는 환경 변수에서 읽어오도록 복원하여 애플리케이션의 유연성을 높이세요.\", \"기본 모델을 설정하는 CLI 명령을 다시 추가하여 사용자가 쉽게 설정을 변경할 수 있도록 하세요.\", \"새로 추가되거나 수정된 함수에 Docstring을 추가하여 코드 가독성을 향상시키세요.\", \"모든 소스 파일이 파일 끝에 개행 문자로 끝나도록 일관성을 유지하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"before_code\\\": \\\"```python\\\\n                files = diff.get(\\\\\\\"files\\\\\\\", [])\\\\n\\\\n                # 각 파일에 대한 메시지 생성\\\\n                for _, file_info in enumerate(files):\\\\n                    file_name = file_info.get(\\\\\\\"filename\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                    if not file_name:\\\\n                        raise ValueError(\\\\\\\"파일명이 없습니다.\\\\\\\")\\\\n\\\\n                    if file_name and file_name not in review_request.file_paths:\\\\n                        review_request.file_paths.append(file_name)\\\\n\\\\n                    hunks = file_info.get(\\\\\\\"hunks\\\\\\\", [])\\\\n                    for hunk_idx, hunk in enumerate(hunks):\\\\n                        hunk_content = hunk.get(\\\\\\\"content\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                        if not hunk_content:\\\\n                            continue\\\\n\\\\n                        hunk_msg = f\\\\\\\"`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\"\\\\n\\\\n                        messages.append(\\\\n                            {\\\\n                                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                                \\\\\\\"hunk_idx\\\\\\\": str(hunk_idx + 1),\\\\n                                \\\\\\\"file_name\\\\\\\": file_name,\\\\n                                \\\\\\\"content\\\\\\\": hunk_msg,\\\\n                                \\\\\\\"start_line_original\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_original\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"line_count_original\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"line_count_original\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"start_line_modified\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"start_line_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                                \\\\\\\"line_count_modified\\\\\\\": str(\\\\n                                    hunk.get(\\\\\\\"line_count_modified\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                                ),\\\\n                            }\\\\n                        )\\\\n            case _:\\\\n                raise ValueError(\\\\\\\"processed_diff가 올바른 형식이 아닙니다.\\\\\\\")\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                files = diff.get(\\\\\\\"files\\\\\\\", [])\\\\n\\\\n                # 각 파일에 대한 메시지 생성\\\\n                for file_idx, file_info in enumerate(files):\\\\n                    file_name = file_info.get(\\\\\\\"filename\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                    if not file_name:  # 파일명이 없는 경우 대체\\\\n                        file_name = f\\\\\\\"unknown_file_{file_idx + 1}\\\\\\\"\\\\n\\\\n                # 파일 경로를 file_paths에 추가\\\\n                if file_name and file_name not in review_request.file_paths:\\\\n                    review_request.file_paths.append(file_name)\\\\n\\\\n                hunks = file_info.get(\\\\\\\"hunks\\\\\\\", [])\\\\n\\\\n                # 각 hunk에 대한 컨텍스트 생성\\\\n                for hunk_idx, hunk in enumerate(hunks):\\\\n                    hunk_content = hunk.get(\\\\\\\"content\\\\\\\", \\\\\\\"\\\\\\\")\\\\n                    if not hunk_content:\\\\n                        continue\\\\n\\\\n                    hunk_msg = f\\\\\\\"파일: {file_name}\\\\\\\\nHunk #{hunk_idx + 1}:\\\\\\\\n`​``diff\\\\\\\\n{hunk_content}\\\\\\\\n`​``\\\\\\\"\\\\n\\\\n                    # hunk의 위치 정보를 추가\\\\n                    if \\\\\\\"start_line\\\\\\\" in hunk and \\\\\\\"line_count\\\\\\\" in hunk:\\\\n                        hunk_msg += f\\\\\\\"\\\\\\\\n[라인 범위: {hunk.get('start_line')}~{hunk.get('start_line') + hunk.get('line_count') - 1}]\\\\\\\"\\\\n\\\\n                    messages.append({\\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\", \\\\\\\"content\\\\\\\": hunk_msg})\\\\n            case _:\\\\n                raise ValueError(\\\\\\\"processed_diff가 올바른 형식이 아닙니다.\\\\\\\")\\\\n\\\\n```\\\", \\\"line_number\\\": 134, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 145, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"파일 목록(`files`)을 순회하는 `for` 루프 바깥에서 hunk 목록(`hunks`)을 가져오고 처리하는 루프가 시작됩니다. 이로 인해 `files` 목록의 마지막 파일에 대한 hunk만 처리되는 심각한 버그가 발생합니다.\", \"suggestion\": \"hunk 목록을 가져오고 처리하는 전체 블록을 파일 목록 순회 루프 안으로 이동시켜야 합니다. `hunks = file_info.get(\\\"hunks\\\", [])` 라인과 그 아래의 `for hunk_idx, hunk in enumerate(hunks):` 루프 전체를 파일 루프(`for file_idx, file_info in enumerate(files):`)의 들여쓰기 레벨 안으로 옮기세요.\", \"severity\": \"error\", \"target_code\": \"hunks = file_info.get(\\\"hunks\\\", [])\", \"suggested_code\": \"    hunks = file_info.get(\\\"hunks\\\", []) # <-- 이 줄과 아래 hunk 처리 루프를 파일 루프 안으로 이동\"}, {\"type\": \"design\", \"line_number\": 152, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"이전 코드에서는 hunk 관련 메타데이터(hunk_idx, file_name, 라인 정보 등)를 메시지 객체의 별도 필드로 포함했습니다. 변경된 코드에서는 이 정보를 `content` 문자열 안에 포함시키고 있습니다. 이는 구조화된 데이터 처리를 어렵게 만들 수 있으며, 다운스트림 시스템에서 이 정보를 파싱해야 하는 부담을 줍니다.\", \"suggestion\": \"가능하다면, 이전 코드처럼 hunk 메타데이터를 메시지 객체의 별도 필드로 유지하는 것이 데이터의 구조화 및 재사용 측면에서 더 좋습니다.\", \"severity\": \"info\", \"target_code\": \"messages.append({\\\"role\\\": \\\"user\\\", \\\"content\\\": hunk_msg})\", \"suggested_code\": \"messages.append(\\n    {\\n        \\\"role\\\": \\\"user\\\",\\n        \\\"hunk_idx\\\": str(hunk_idx + 1),\\n        \\\"file_name\\\": file_name,\\n        \\\"content\\\": hunk_msg, # hunk_msg는 diff 내용만 포함하도록 변경\\n        \\\"start_line_modified\\\": str(hunk.get(\\\"start_line\\\", \\\"\\\")),\\n        \\\"line_count_modified\\\": str(hunk.get(\\\"line_count\\\", \\\"\\\")),\\n        # 필요한 경우 original 라인 정보도 추가\\n    }\\n)\"}, {\"type\": \"bug\", \"line_number\": 150, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"hunk의 라인 범위 계산 시 `start_line`과 `line_count` 값이 정수형인지 명시적으로 확인하지 않고 덧셈 연산을 수행합니다. 만약 이 값들이 누락되거나 정수형이 아닌 다른 타입(예: 문자열)으로 제공될 경우 `TypeError`가 발생할 수 있습니다.\", \"suggestion\": \"`hunk.get()`으로 가져온 `start_line`과 `line_count` 값이 정수형인지 확인한 후 연산을 수행하거나, 가져올 때 기본값을 0으로 설정하고 연산 전에 명시적으로 int로 형변환하는 것이 안전합니다.\", \"severity\": \"warning\", \"target_code\": \"hunk_msg += f\\\"\\\\n[라인 범위: {hunk.get('start_line')}~{hunk.get('start_line') + hunk.get('line_count') - 1}]\\\"\", \"suggested_code\": \"start_line = hunk.get('start_line')\\nline_count = hunk.get('line_count')\\nif isinstance(start_line, int) and isinstance(line_count, int):\\n    hunk_msg += f\\\"\\\\n[라인 범위: {start_line}~{start_line + line_count - 1}]\\\"\\nelse:\\n    # 필요에 따라 오류 로깅 또는 기본값 처리\\n    pass\"}], \"summary\": \"파일 및 hunk 정보를 메시지 형식으로 변환하는 로직이 변경되었습니다. 파일별 hunk 처리에 심각한 버그가 있으며, 라인 정보 계산 시 타입 안정성이 부족합니다. 메시지 구조 변경은 다운스트림 처리에 영향을 줄 수 있습니다.\", \"score\": 3.0, \"recommendations\": [\"파일별 hunk를 올바르게 처리하도록 루프 구조를 수정하세요.\", \"메시지 구조를 재검토하여 hunk 메타데이터를 별도 필드로 분리하는 것을 고려하세요.\", \"딕셔너리에서 가져온 값으로 연산 수행 전, 해당 값이 예상하는 타입(예: int)인지 확인하는 로직을 추가하여 안정성을 높이세요.\", \"다양한 형식의 입력 데이터(여러 파일, 여러 hunk, 누락된 필드 등)에 대한 단위 테스트를 작성하여 코드의 견고성을 확보하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 모듈\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport instructor\\\\nfrom anthropic import Anthropic\\\\nfrom google import genai\\\\nfrom openai import OpenAI\\\\n\\\\n\\\\nclass LLMClientFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"provider와 api_key를 기반으로 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            provider: LLM 제공자 ('openai', 'claude', 'google')\\\\n            api_key: API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor | genai.Client: 구조화된 응답을 지원하는 LLM 클라이언트 또는 Google Gemini 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if provider == \\\\\\\"openai\\\\\\\":\\\\n            return LLMClientFactory._create_openai_client(api_key)\\\\n        elif provider == \\\\\\\"claude\\\\\\\":\\\\n            return LLMClientFactory._create_claude_client(api_key)\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return LLMClientFactory._create_gemini_client(api_key)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 제공자입니다: {provider}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def _create_openai_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: OpenAI API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: OpenAI 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = OpenAI(api_key=api_key)\\\\n        return instructor.from_openai(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_claude_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Anthropic API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: Claude 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = Anthropic(api_key=api_key)\\\\n        return instructor.from_anthropic(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_gemini_client(api_key: str) -> genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Google API 키\\\\n\\\\n        Returns:\\\\n            genai.Client: Gemini 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return genai.Client(api_key=api_key)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom anthropic import Anthropic\\\\nfrom google import genai\\\\nfrom openai import OpenAI\\\\n```\\\", \\\"line_number\\\": 4}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로바이더에 맞는, 구조화된 응답을 지원하는 클라이언트를 생성합니다.\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"provider와 api_key를 기반으로 LLM 클라이언트를 생성합니다.\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n            provider: LLM 프로바이더 (openai 또는 claude)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            provider: LLM 제공자 ('openai', 'claude', 'google')\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n            Instructor: instructor 래핑된 LLM 클라이언트\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 프로바이더인 경우\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            instructor.Instructor | genai.Client: 구조화된 응답을 지원하는 LLM 클라이언트 또는 Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```python\\\\n            from openai import OpenAI\\\\n\\\\n            return instructor.from_openai(OpenAI(api_key=api_key))\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            return LLMClientFactory._create_openai_client(api_key)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"before_code\\\": \\\"```python\\\\n            from anthropic import Anthropic\\\\n\\\\n            return instructor.from_anthropic(Anthropic(api_key=api_key))\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            return LLMClientFactory._create_claude_client(api_key)\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return LLMClientFactory._create_gemini_client(api_key)\\\\n```\\\", \\\"line_number\\\": 28}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"before_code\\\": \\\"```python\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 프로바이더입니다: {provider}\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 제공자입니다: {provider}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def _create_openai_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: OpenAI API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: OpenAI 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = OpenAI(api_key=api_key)\\\\n        return instructor.from_openai(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_claude_client(api_key: str) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Anthropic API 키\\\\n\\\\n        Returns:\\\\n            instructor.Instructor: Claude 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        client = Anthropic(api_key=api_key)\\\\n        return instructor.from_anthropic(client)\\\\n\\\\n    @staticmethod\\\\n    def _create_gemini_client(api_key: str) -> genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            api_key: Google API 키\\\\n\\\\n        Returns:\\\\n            genai.Client: Gemini 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 63}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 71}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n```\\\", \\\"line_number\\\": 103}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 116}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 116, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Gemini 모델의 기본 가격 책정 로직이 특정 모델이 `pricing` 딕셔너리에 없을 경우 Flash 모델 가격으로 기본 설정됩니다. 이는 Pro 모델 등 더 비싼 모델이 사용될 경우 비용을 과소평가할 수 있습니다.\", \"suggestion\": \"향후 더 다양한 Gemini 모델이 추가될 경우, 기본 가격 책정 로직을 좀 더 세분화하여 모델 이름 패턴(예: 'pro', 'flash')에 따라 다른 기본 가격을 적용하거나, 알려지지 않은 Gemini 모델에 대해서는 보수적인 가격을 적용하는 것을 고려해볼 수 있습니다.\", \"severity\": \"info\", \"target_code\": \"            model_pricing = {\\\"input\\\": 0.00015, \\\"output\\\": 0.0006}\", \"suggested_code\": null}], \"summary\": \"Google Gemini 모델 지원을 위한 코드 변경이 성공적으로 이루어졌습니다. CLI 인수, 지원 모델 목록, 게이트웨이 팩토리, LLM 클라이언트 팩토리, 토큰 유틸리티 등 관련 모듈에 Gemini 모델 관련 로직이 추가되었습니다. 전반적으로 기존 구조를 잘 따르고 있으며, `llm_factory.py`의 클라이언트 생성 로직 분리는 좋은 리팩토링입니다.\", \"score\": 9.0, \"recommendations\": [\"새로 추가된 Google Gemini 모델 지원 기능에 대한 단위 테스트를 충분히 작성하여 안정성을 확보하세요.\", \"토큰 유틸리티의 Gemini 모델 가격 추정 로직에서, 알려지지 않은 특정 Gemini 모델에 대한 기본 가격 설정을 좀 더 보수적으로 하거나 모델 종류별로 구분하는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.config import get_default_raw_log_dir\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로그 디렉토리 설정 및 생성\\\\nLOG_DIR = get_default_raw_log_dir()\\\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n            prefix: 파일명 접두사 (예: 'openai', 'claude')\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            raw_response_file = LOG_DIR / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            print(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            print(f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        print(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom typing import Any\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n```\\\", \\\"line_number\\\": 55}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n    def create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n    @abc.abstractmethod\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```python\\\\n            review_prompt: 리뷰 요청 객체\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n```\\\", \\\"line_number\\\": 200}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"before_code\\\": \\\"```python\\\\n        raise NotImplementedError\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/claude_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\nfrom . import get_api_key\\\\n\\\\n\\\\nclass ClaudeGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        api_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n        if not api_key:\\\\n            raise APIKeyNotFoundError(\\\\\\\"claude\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: Claude 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"claude\\\\\\\":\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) Claude 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"Claude\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n            self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 기본 파라미터 설정\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.get_model_name(),\\\\n            \\\\\\\"messages\\\\\\\": messages,\\\\n            # Claude는 max_tokens 파라미터가 필요합니다, Claude 3.7 Sonnet 기준,\\\\n            # normal 8192, thinking 64000\\\\n            \\\\\\\"max_tokens\\\\\\\": 8192,\\\\n        }\\\\n\\\\n        # 모델별 파라미터 설정\\\\n        model_params = self.model[\\\\\\\"params\\\\\\\"]\\\\n        params.update(model_params)\\\\n\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewResponse, StructuredReviewResponse\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 10}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비 (비용 추정 및 메시지 생성)\\\\n        self.prepare_review_request(review_prompt)\\\\n\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        # Anthropic 클라이언트 초기화\\\\n        try:\\\\n            client = self.create_client()\\\\n        except Exception as e:\\\\n            print(f\\\\\\\"클라이언트 초기화 오류: {str(e)}\\\\\\\")\\\\n            return ReviewResponse(\\\\n                issues=[],\\\\n                summary=f\\\\\\\"Claude API 클라이언트 초기화 중 오류 발생: {str(e)}\\\\\\\",\\\\n                recommendations=[\\\\\\\"API 키가 올바른지 확인하세요.\\\\\\\"],\\\\n            )\\\\n\\\\n        try:\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답이 비어있는 경우 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            # 응답 변환 및 리턴\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 70}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/openai_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"OpenAI API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\nfrom . import get_api_key\\\\n\\\\n\\\\nclass OpenAIGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"OpenAI API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        api_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n        if not api_key:\\\\n            raise APIKeyNotFoundError(\\\\\\\"openai\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: model_info 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: OpenAI 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"openai\\\\\\\":\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) OpenAI 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"OpenAI\\\\\\\")\\\\n\\\\n        print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 기본 파라미터 설정\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.get_model_name(),\\\\n            \\\\\\\"messages\\\\\\\": messages,\\\\n        }\\\\n\\\\n        # 모델별 파라미터 설정\\\\n        model_params = self.model[\\\\\\\"params\\\\\\\"]\\\\n        params.update(model_params)\\\\n\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewResponse, StructuredReviewResponse\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 10}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비 (비용 추정 및 메시지 생성)\\\\n        self.prepare_review_request(review_prompt)\\\\n\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # OpenAI 클라이언트 초기화\\\\n            client = self.create_client()\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # instructor를 사용하여 StructuredReviewResponse 모델로 파싱\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답이 비어있는 경우 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            # 응답 변환 및 리턴\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 67}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 208, \"file\": \"reviewer/src/llm_gateway/base_gateway.py\", \"description\": \"API 호출 중 발생하는 모든 예외를 일반적인 `Exception`으로 잡고 있습니다. 이는 특정 오류(예: 네트워크 문제, 인증 오류, API 응답 형식 오류 등)를 구분하지 못하게 하여 디버깅을 어렵게 만들 수 있습니다. 알려진 특정 예외를 먼저 처리하고, 예상치 못한 예외는 별도로 로깅하는 것이 좋습니다.\", \"suggestion\": \"API 호출에서 발생할 수 있는 보다 구체적인 예외 유형(예: `requests.exceptions.RequestException`, `instructor` 관련 예외 등)을 먼저 잡고 처리한 후, 마지막에 `Exception`을 잡아 예상치 못한 오류를 처리하고 상세히 로깅하도록 수정하세요.\", \"severity\": \"warning\", \"target_code\": \"except Exception as e:\\n            return ReviewResponse.get_error_response(e)\", \"suggested_code\": \"except ContextLimitExceededError as e:\\n            # 컨텍스트 제한 오류는 이미 prepare_review_request에서 처리되지만,\\n            # 혹시 모를 경우를 대비하거나 다른 특정 처리가 필요하면 여기에 추가합니다.\\n            return ReviewResponse.get_error_response(e)\\n        except Exception as e:\\n            # 예상치 못한 다른 모든 예외를 처리하고 로깅합니다.\\n            print(f\\\"API 호출 중 예상치 못한 오류 발생: {e}\\\") # 실제 로깅 시스템 사용 권장\\n            return ReviewResponse.get_error_response(e)\"}, {\"type\": \"bug\", \"line_number\": 175, \"file\": \"reviewer/src/llm_gateway/base_gateway.py\", \"description\": \"`save_raw_response` 메서드에서 파일 쓰기 및 JSON 직렬화 중 발생하는 모든 예외를 일반적인 `Exception`으로 잡고 있습니다. 이로 인해 파일 권한 문제, 디스크 공간 부족, JSON 직렬화 오류 등 구체적인 문제 원인을 파악하기 어렵습니다. 또한, 내부 `try...except Exception:` 블록은 오류를 로깅하지 않고 단순히 문자열로 대체하여 문제 해결에 도움이 되지 않습니다.\", \"suggestion\": \"파일 쓰기 관련 예외(`IOError`, `OSError`)와 JSON 직렬화 관련 예외(`json.JSONEncodeError`)를 구분하여 처리하고, 각 예외 발생 시 구체적인 오류 메시지를 로깅하도록 수정하세요. 내부 `try...except` 블록 대신 외부에서 더 구체적인 예외를 잡는 것이 좋습니다.\", \"severity\": \"warning\", \"target_code\": \"except Exception as e:\\n            print(f\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\")\", \"suggested_code\": null}], \"summary\": \"LLM 게이트웨이의 기본 클래스에 `review_code` 메서드의 핵심 로직을 통합하고, 프로바이더별 요청 파라미터 생성 로직을 추상화하는 리팩토링이 수행되었습니다. 클라이언트 생성 메서드는 내부 메서드로 변경되었습니다. 전반적으로 코드 중복을 줄이고 구조를 개선하는 긍정적인 변경입니다. 다만, 예외 처리 부분에서 개선의 여지가 있습니다.\", \"score\": 8.0, \"recommendations\": [\"예외 처리 로직을 더 구체화하여 특정 오류 유형별로 처리하고, 예상치 못한 오류 발생 시 상세한 로깅을 추가하여 디버깅 효율성을 높이세요.\", \"`save_raw_response` 메서드에서 파일 쓰기 및 JSON 직렬화 관련 예외를 명확히 구분하여 처리하도록 개선하세요.\", \"추상 메서드(`_load_api_key`, `_set_model`, `_create_request_params`)의 docstring에 `Raises` 절을 추가하여 발생 가능한 예외를 명시하는 것을 고려해 보세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 모듈\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\n\\\\nclass LLMClientFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로바이더에 맞는, 구조화된 응답을 지원하는 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            provider: LLM 프로바이더 (openai 또는 claude)\\\\n            api_key: API 키\\\\n\\\\n        Returns:\\\\n            Instructor: instructor 래핑된 LLM 클라이언트\\\\n            genai.Client: Google Gemini 클라이언트\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 프로바이더인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if provider == \\\\\\\"openai\\\\\\\":\\\\n            from openai import OpenAI\\\\n\\\\n            return instructor.from_openai(OpenAI(api_key=api_key))\\\\n        elif provider == \\\\\\\"claude\\\\\\\":\\\\n            from anthropic import Anthropic\\\\n\\\\n            return instructor.from_anthropic(Anthropic(api_key=api_key))\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 프로바이더입니다: {provider}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            genai.Client: Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 34}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 63}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 71}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n```\\\", \\\"line_number\\\": 103}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 116}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"Google Gemini 모델 지원 추가 변경 사항에 대한 코드 리뷰입니다. CLI 옵션, 지원 모델 목록, 게이트웨이 팩토리, LLM 클라이언트 팩토리, 토큰 유틸리티 등 관련 코드가 일관성 있게 잘 업데이트되었습니다.\", \"score\": 10.0, \"recommendations\": [\"코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다. 기존 코드 구조를 잘 따르고 있으며, 새로운 기능(Google Gemini 지원)이 성공적으로 통합되었습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway_request.py\\\", \\\"file_content\\\": \\\"import unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\n\\\\nclass TestRequestParamsCreation(unittest.TestCase):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로바이더별 요청 파라미터 생성 테스트\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_openai_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_claude_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"max_tokens\\\\\\\"], 8192)  # Claude 특정 파라미터\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_google_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n        self.assertIn(\\\\\\\"contents\\\\\\\", params)  # Google API 요청 형식에 맞게 변환됨\\\\n        self.assertIn(\\\\\\\"config\\\\\\\", params)  # Google API 구성 포함\\\\n        # config의 시스템 지시 검증\\\\n        self.assertEqual(\\\\n            params[\\\\\\\"config\\\\\\\"].system_instruction, \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"\\\\n        )\\\\n        # 온도 설정 검증\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].temperature, 0.0)\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_mime_type, \\\\\\\"application/json\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_schema, StructuredReviewResponse)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\n\\\\nclass TestRequestParamsCreation(unittest.TestCase):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로바이더별 요청 파라미터 생성 테스트\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_openai_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_claude_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"max_tokens\\\\\\\"], 8192)  # Claude 특정 파라미터\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_google_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n        self.assertIn(\\\\\\\"contents\\\\\\\", params)  # Google API 요청 형식에 맞게 변환됨\\\\n        self.assertIn(\\\\\\\"config\\\\\\\", params)  # Google API 구성 포함\\\\n        # config의 시스템 지시 검증\\\\n        self.assertEqual(\\\\n            params[\\\\\\\"config\\\\\\\"].system_instruction, \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"\\\\n        )\\\\n        # 온도 설정 검증\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].temperature, 0.0)\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_mime_type, \\\\\\\"application/json\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_schema, StructuredReviewResponse)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway_review_code.py\\\", \\\"file_content\\\": \\\"import json\\\\nfrom typing import Any\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nimport instructor\\\\nimport pytest\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, ModelParamsDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, SystemPrompt, UserPrompt\\\\nfrom reviewer.src.utils.token.models import (\\\\n    EstimatedCost,\\\\n    IssueSeverityEnum,\\\\n    ReviewResponse,\\\\n    StructuredReviewIssue,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.0}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef google_model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.1}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"google-test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"google-test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 Google 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef review_prompt_fixture() -> ReviewPrompt:\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"def example(): pass\\\\\\\",\\\\n        modified_code=\\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    return ReviewPrompt(system_prompt=system_prompt, user_prompts=[user_prompt])\\\\n\\\\n\\\\nclass MockBaseGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BaseGateway 추상 클래스를 상속받은 테스트용 구현체\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self, model_info: ModelInfoDict, api_key: str | None = \\\\\\\"fake-api-key\\\\\\\"\\\\n    ) -> None:\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = api_key if api_key is not None else self._load_api_key()\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        return \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        return {\\\\\\\"model\\\\\\\": self.get_model_name(), \\\\\\\"messages\\\\\\\": messages}\\\\n\\\\n    def get_model_name(self):\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self):\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request(\\\\n    mock_save_prompt,\\\\n    mock_estimate_cost,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"정상적인 prepare_review_request 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=1500,\\\\n        input_cost_usd=0.0015,\\\\n        estimated_output_tokens=500,\\\\n        estimated_output_cost_usd=0.0025,\\\\n        estimated_total_cost_usd=0.004,\\\\n        within_context_limit=True,\\\\n    )\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    gateway.prepare_review_request(review_prompt_fixture)\\\\n\\\\n    mock_estimate_cost.assert_called_once_with(review_prompt_fixture)\\\\n    mock_save_prompt.assert_called_once()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request_context_limit_exceeded(\\\\n    mock_save_prompt, mock_estimate_cost, model_info_fixture: ModelInfoDict\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"컨텍스트 제한 초과 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=5000,\\\\n        input_cost_usd=0.005,\\\\n        estimated_output_tokens=1000,\\\\n        estimated_output_cost_usd=0.005,\\\\n        estimated_total_cost_usd=0.01,\\\\n        within_context_limit=False,\\\\n    )\\\\n\\\\n    temp_model_info_for_test = model_info_fixture.copy()\\\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\\\n    temp_model_info_for_test[\\\\\\\"context_limit\\\\\\\"] = 4000\\\\n\\\\n    gateway = MockBaseGateway(temp_model_info_for_test)\\\\n\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        modified_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    review_prompt = ReviewPrompt(\\\\n        system_prompt=system_prompt, user_prompts=[user_prompt]\\\\n    )\\\\n\\\\n    with pytest.raises(ContextLimitExceededError) as excinfo:\\\\n        gateway.prepare_review_request(review_prompt)\\\\n\\\\n    assert \\\\\\\"5000\\\\\\\" in str(excinfo.value)\\\\n    assert \\\\\\\"4000\\\\\\\" in str(excinfo.value)\\\\n    mock_save_prompt.assert_not_called()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_instructor(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Instructor 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n\\\\n    # 테스트용 상세 응답 데이터\\\\n    expected_issues_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"함수에 구현 내용이 없습니다.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 1,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"example.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"함수에 의미 있는 구현을 추가하세요.\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.WARNING,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def example(): pass\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        },\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"suggestion\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"변수명을 더 명확하게 변경하세요.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 5,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"another_module.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"예: `data_list` -> `user_records`\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.INFO,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"data = get_data()\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"user_records = get_data()\\\\\\\",\\\\n        },\\\\n    ]\\\\n    expected_summary = \\\\\\\"코드에 몇 가지 개선 사항이 있습니다.\\\\\\\"\\\\n    expected_score = 75.0\\\\n    expected_recommendations = [\\\\\\\"명확한 변수명 사용\\\\\\\", \\\\\\\"함수 구현 추가\\\\\\\"]\\\\n\\\\n    structured_response_data = StructuredReviewResponse(\\\\n        issues=[StructuredReviewIssue(**data) for data in expected_issues_data],\\\\n        summary=expected_summary,\\\\n        score=expected_score,\\\\n        recommendations=expected_recommendations,\\\\n    )\\\\n    mock_completions.create.return_value = structured_response_data\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"messages\\\\\\\": [],\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        }\\\\n        gateway = MockBaseGateway(model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary\\\\n        assert response.score == expected_score\\\\n        assert response.recommendations == expected_recommendations\\\\n        assert len(response.issues) == len(expected_issues_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"].value\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_genai(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"genai 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n\\\\n    expected_issues_raw_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"genai: 함수 구현 필요\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": \\\\\\\"warning\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 10,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"main.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"빠르게 구현해주세요.\\\\\\\",\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def main():\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def main():\\\\\\\\\\\\\\\\n    print('Hello from GenAI')\\\\\\\",\\\\n        }\\\\n    ]\\\\n    expected_summary_genai = \\\\\\\"GenAI 리뷰: 요약입니다.\\\\\\\"\\\\n    expected_score_genai = 80.0\\\\n    expected_recommendations_genai = [\\\\\\\"GenAI 권장 사항1\\\\\\\", \\\\\\\"GenAI 권장 사항2\\\\\\\"]\\\\n\\\\n    # JSON 문자열 생성 시, 내부 문자열 값에 포함된 특수문자가 올바르게 이스케이프되도록 직접 구성\\\\n    # json.dumps를 문자열 전체가 아닌, 개별 문자열 값에만 적용하거나, 수동으로 이스케이프\\\\n    issues_list_for_json = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": expected_issues_raw_data[0][\\\\\\\"type\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": expected_issues_raw_data[0][\\\\\\\"description\\\\\\\"],\\\\n            \\\\\\\"severity\\\\\\\": expected_issues_raw_data[0][\\\\\\\"severity\\\\\\\"],\\\\n            \\\\\\\"line_number\\\\\\\": expected_issues_raw_data[0][\\\\\\\"line_number\\\\\\\"],\\\\n            \\\\\\\"file\\\\\\\": expected_issues_raw_data[0][\\\\\\\"file\\\\\\\"],\\\\n            \\\\\\\"suggestion\\\\\\\": expected_issues_raw_data[0][\\\\\\\"suggestion\\\\\\\"],\\\\n            \\\\\\\"original_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"original_code\\\\\\\"],\\\\n            \\\\\\\"improved_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"improved_code\\\\\\\"],\\\\n        }\\\\n    ]\\\\n\\\\n    mock_genai_response.text = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    {{\\\\n        \\\\\\\"issues\\\\\\\": {json.dumps(issues_list_for_json)},\\\\n        \\\\\\\"summary\\\\\\\": \\\\\\\"{expected_summary_genai}\\\\\\\", \\\\n        \\\\\\\"score\\\\\\\": {expected_score_genai}, \\\\n        \\\\\\\"recommendations\\\\\\\": {json.dumps(expected_recommendations_genai)}\\\\n    }}\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": google_model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"content\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": MagicMock(),\\\\n        }\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary_genai\\\\n        assert response.score == expected_score_genai\\\\n        assert response.recommendations == expected_recommendations_genai\\\\n        assert len(response.issues) == len(expected_issues_raw_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_raw_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"]\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_empty_response(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 응답 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n    mock_completions.create.return_value = None\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"비어있\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_error_handling(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"예외 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_create_client.side_effect = Exception(\\\\\\\"API 호출 중 오류 발생\\\\\\\")\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"오류 발생\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_parsing_error(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google API 응답 파싱 오류 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n    mock_genai_response.text = \\\\\\\"\\\\\\\"\\\\\\\"{\\\\\\\"issues\\\\\\\": [{\\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\", \\\\\\\"description\\\\\\\": \\\\\\\"desc\\\\\\\", \\\\\\\"line_number\\\\\\\": invalid_value}]}\\\\\\\"\\\\\\\"\\\\\\\"  # 잘못된 JSON\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\"):\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        assert len(response.issues) == 0\\\\n        assert \\\\\\\"API 처리 중 오류\\\\\\\" in response.summary\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    pytest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport json\\\\nfrom typing import Any\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nimport instructor\\\\nimport pytest\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, ModelParamsDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, SystemPrompt, UserPrompt\\\\nfrom reviewer.src.utils.token.models import (\\\\n    EstimatedCost,\\\\n    IssueSeverityEnum,\\\\n    ReviewResponse,\\\\n    StructuredReviewIssue,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.0}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef google_model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.1}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"google-test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"google-test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 Google 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef review_prompt_fixture() -> ReviewPrompt:\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"def example(): pass\\\\\\\",\\\\n        modified_code=\\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    return ReviewPrompt(system_prompt=system_prompt, user_prompts=[user_prompt])\\\\n\\\\n\\\\nclass MockBaseGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BaseGateway 추상 클래스를 상속받은 테스트용 구현체\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self, model_info: ModelInfoDict, api_key: str | None = \\\\\\\"fake-api-key\\\\\\\"\\\\n    ) -> None:\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = api_key if api_key is not None else self._load_api_key()\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        return \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        return {\\\\\\\"model\\\\\\\": self.get_model_name(), \\\\\\\"messages\\\\\\\": messages}\\\\n\\\\n    def get_model_name(self):\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self):\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request(\\\\n    mock_save_prompt,\\\\n    mock_estimate_cost,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"정상적인 prepare_review_request 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=1500,\\\\n        input_cost_usd=0.0015,\\\\n        estimated_output_tokens=500,\\\\n        estimated_output_cost_usd=0.0025,\\\\n        estimated_total_cost_usd=0.004,\\\\n        within_context_limit=True,\\\\n    )\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    gateway.prepare_review_request(review_prompt_fixture)\\\\n\\\\n    mock_estimate_cost.assert_called_once_with(review_prompt_fixture)\\\\n    mock_save_prompt.assert_called_once()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request_context_limit_exceeded(\\\\n    mock_save_prompt, mock_estimate_cost, model_info_fixture: ModelInfoDict\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"컨텍스트 제한 초과 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=5000,\\\\n        input_cost_usd=0.005,\\\\n        estimated_output_tokens=1000,\\\\n        estimated_output_cost_usd=0.005,\\\\n        estimated_total_cost_usd=0.01,\\\\n        within_context_limit=False,\\\\n    )\\\\n\\\\n    temp_model_info_for_test = model_info_fixture.copy()\\\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\\\n    temp_model_info_for_test[\\\\\\\"context_limit\\\\\\\"] = 4000\\\\n\\\\n    gateway = MockBaseGateway(temp_model_info_for_test)\\\\n\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        modified_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    review_prompt = ReviewPrompt(\\\\n        system_prompt=system_prompt, user_prompts=[user_prompt]\\\\n    )\\\\n\\\\n    with pytest.raises(ContextLimitExceededError) as excinfo:\\\\n        gateway.prepare_review_request(review_prompt)\\\\n\\\\n    assert \\\\\\\"5000\\\\\\\" in str(excinfo.value)\\\\n    assert \\\\\\\"4000\\\\\\\" in str(excinfo.value)\\\\n    mock_save_prompt.assert_not_called()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_instructor(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Instructor 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n\\\\n    # 테스트용 상세 응답 데이터\\\\n    expected_issues_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"함수에 구현 내용이 없습니다.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 1,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"example.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"함수에 의미 있는 구현을 추가하세요.\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.WARNING,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def example(): pass\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        },\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"suggestion\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"변수명을 더 명확하게 변경하세요.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 5,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"another_module.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"예: `data_list` -> `user_records`\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.INFO,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"data = get_data()\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"user_records = get_data()\\\\\\\",\\\\n        },\\\\n    ]\\\\n    expected_summary = \\\\\\\"코드에 몇 가지 개선 사항이 있습니다.\\\\\\\"\\\\n    expected_score = 75.0\\\\n    expected_recommendations = [\\\\\\\"명확한 변수명 사용\\\\\\\", \\\\\\\"함수 구현 추가\\\\\\\"]\\\\n\\\\n    structured_response_data = StructuredReviewResponse(\\\\n        issues=[StructuredReviewIssue(**data) for data in expected_issues_data],\\\\n        summary=expected_summary,\\\\n        score=expected_score,\\\\n        recommendations=expected_recommendations,\\\\n    )\\\\n    mock_completions.create.return_value = structured_response_data\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"messages\\\\\\\": [],\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        }\\\\n        gateway = MockBaseGateway(model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary\\\\n        assert response.score == expected_score\\\\n        assert response.recommendations == expected_recommendations\\\\n        assert len(response.issues) == len(expected_issues_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"].value\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_genai(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"genai 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n\\\\n    expected_issues_raw_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"genai: 함수 구현 필요\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": \\\\\\\"warning\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 10,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"main.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"빠르게 구현해주세요.\\\\\\\",\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def main():\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def main():\\\\\\\\\\\\\\\\n    print('Hello from GenAI')\\\\\\\",\\\\n        }\\\\n    ]\\\\n    expected_summary_genai = \\\\\\\"GenAI 리뷰: 요약입니다.\\\\\\\"\\\\n    expected_score_genai = 80.0\\\\n    expected_recommendations_genai = [\\\\\\\"GenAI 권장 사항1\\\\\\\", \\\\\\\"GenAI 권장 사항2\\\\\\\"]\\\\n\\\\n    # JSON 문자열 생성 시, 내부 문자열 값에 포함된 특수문자가 올바르게 이스케이프되도록 직접 구성\\\\n    # json.dumps를 문자열 전체가 아닌, 개별 문자열 값에만 적용하거나, 수동으로 이스케이프\\\\n    issues_list_for_json = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": expected_issues_raw_data[0][\\\\\\\"type\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": expected_issues_raw_data[0][\\\\\\\"description\\\\\\\"],\\\\n            \\\\\\\"severity\\\\\\\": expected_issues_raw_data[0][\\\\\\\"severity\\\\\\\"],\\\\n            \\\\\\\"line_number\\\\\\\": expected_issues_raw_data[0][\\\\\\\"line_number\\\\\\\"],\\\\n            \\\\\\\"file\\\\\\\": expected_issues_raw_data[0][\\\\\\\"file\\\\\\\"],\\\\n            \\\\\\\"suggestion\\\\\\\": expected_issues_raw_data[0][\\\\\\\"suggestion\\\\\\\"],\\\\n            \\\\\\\"original_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"original_code\\\\\\\"],\\\\n            \\\\\\\"improved_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"improved_code\\\\\\\"],\\\\n        }\\\\n    ]\\\\n\\\\n    mock_genai_response.text = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    {{\\\\n        \\\\\\\"issues\\\\\\\": {json.dumps(issues_list_for_json)},\\\\n        \\\\\\\"summary\\\\\\\": \\\\\\\"{expected_summary_genai}\\\\\\\", \\\\n        \\\\\\\"score\\\\\\\": {expected_score_genai}, \\\\n        \\\\\\\"recommendations\\\\\\\": {json.dumps(expected_recommendations_genai)}\\\\n    }}\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": google_model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"content\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": MagicMock(),\\\\n        }\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary_genai\\\\n        assert response.score == expected_score_genai\\\\n        assert response.recommendations == expected_recommendations_genai\\\\n        assert len(response.issues) == len(expected_issues_raw_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_raw_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"]\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_empty_response(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 응답 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n    mock_completions.create.return_value = None\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"비어있\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_error_handling(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"예외 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_create_client.side_effect = Exception(\\\\\\\"API 호출 중 오류 발생\\\\\\\")\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"오류 발생\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_parsing_error(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google API 응답 파싱 오류 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n    mock_genai_response.text = \\\\\\\"\\\\\\\"\\\\\\\"{\\\\\\\"issues\\\\\\\": [{\\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\", \\\\\\\"description\\\\\\\": \\\\\\\"desc\\\\\\\", \\\\\\\"line_number\\\\\\\": invalid_value}]}\\\\\\\"\\\\\\\"\\\\\\\"  # 잘못된 JSON\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\"):\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        assert len(response.issues) == 0\\\\n        assert \\\\\\\"API 처리 중 오류\\\\\\\" in response.summary\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    pytest.main()\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"제공된 코드는 LLM 게이트웨이의 요청 파라미터 생성 및 코드 리뷰 로직에 대한 단위 테스트입니다. OpenAI, Claude, Google 등 다양한 프로바이더에 대한 요청 파라미터 생성 테스트와, `review_code` 메서드의 정상 동작, 컨텍스트 제한 초과, 빈 응답, 일반 예외, 파싱 오류 등 다양한 시나리오에 대한 테스트를 포함하고 있습니다. 전반적으로 테스트 커버리지가 좋고 코드가 명확합니다.\", \"score\": 9.0, \"recommendations\": [\"테스트 메서드의 독스트링 스타일을 일관되게 유지하는 것이 좋습니다.\", \"Google API 응답을 위한 JSON 문자열을 수동으로 구성하는 대신, 파이썬 딕셔너리를 구성한 후 `json.dumps()`를 사용하여 문자열로 변환하는 방식을 고려해볼 수 있습니다. 현재 방식도 유효하지만, 복잡한 구조나 특수 문자가 많아질 경우 실수를 유발할 가능성이 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    formatter = ReviewFormatter()\\\\n    output_content = formatter.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_converter import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    formatter = ReviewFormatter()\\\\n    output_content = formatter.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"line_number\\\": 584}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_converter.py\\\", \\\"file_content\\\": \\\"삭제된 파일\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"line_number\\\": 6}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/file_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n    \\\\\\\".exe\\\\\\\",\\\\n    \\\\\\\".dll\\\\\\\",\\\\n    \\\\\\\".so\\\\\\\",\\\\n    \\\\\\\".dylib\\\\\\\",\\\\n    \\\\\\\".bin\\\\\\\",\\\\n    \\\\\\\".o\\\\\\\",\\\\n    \\\\\\\".obj\\\\\\\",\\\\n    \\\\\\\".a\\\\\\\",\\\\n    \\\\\\\".lib\\\\\\\",\\\\n    # 압축 파일\\\\n    \\\\\\\".zip\\\\\\\",\\\\n    \\\\\\\".tar\\\\\\\",\\\\n    \\\\\\\".gz\\\\\\\",\\\\n    \\\\\\\".bz2\\\\\\\",\\\\n    \\\\\\\".xz\\\\\\\",\\\\n    \\\\\\\".jar\\\\\\\",\\\\n    \\\\\\\".war\\\\\\\",\\\\n    \\\\\\\".ear\\\\\\\",\\\\n    \\\\\\\".aar\\\\\\\",\\\\n    # 이미지 파일\\\\n    \\\\\\\".jpg\\\\\\\",\\\\n    \\\\\\\".jpeg\\\\\\\",\\\\n    \\\\\\\".png\\\\\\\",\\\\n    \\\\\\\".gif\\\\\\\",\\\\n    \\\\\\\".bmp\\\\\\\",\\\\n    \\\\\\\".tiff\\\\\\\",\\\\n    \\\\\\\".ico\\\\\\\",\\\\n    \\\\\\\".webp\\\\\\\",\\\\n    # 비디오/오디오 파일\\\\n    \\\\\\\".mp3\\\\\\\",\\\\n    \\\\\\\".mp4\\\\\\\",\\\\n    \\\\\\\".wav\\\\\\\",\\\\n    \\\\\\\".avi\\\\\\\",\\\\n    \\\\\\\".mov\\\\\\\",\\\\n    \\\\\\\".mkv\\\\\\\",\\\\n    \\\\\\\".flac\\\\\\\",\\\\n    \\\\\\\".ogg\\\\\\\",\\\\n    # 문서 파일\\\\n    \\\\\\\".pdf\\\\\\\",\\\\n    \\\\\\\".doc\\\\\\\",\\\\n    \\\\\\\".docx\\\\\\\",\\\\n    \\\\\\\".ppt\\\\\\\",\\\\n    \\\\\\\".pptx\\\\\\\",\\\\n    \\\\\\\".xls\\\\\\\",\\\\n    \\\\\\\".xlsx\\\\\\\",\\\\n    # 기타 바이너리 파일\\\\n    \\\\\\\".class\\\\\\\",\\\\n    \\\\\\\".pyc\\\\\\\",\\\\n    \\\\\\\".pyo\\\\\\\",\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 바이너리 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n}\\\\n\\\\n# 무시할 텍스트 파일 이름 목록\\\\nIGNORE_FILENAMES = {\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n    \\\\\\\".env.local\\\\\\\",\\\\n    \\\\\\\".env.development\\\\\\\",\\\\n    \\\\\\\".env.production\\\\\\\",\\\\n    \\\\\\\".env.test\\\\\\\",\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_ignore_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 무시해야 할 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 무시해야 할 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 무시해야 할 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return (\\\\n        ext in BINARY_EXTENSIONS\\\\n        or base_name in BINARY_FILENAMES\\\\n        or base_name in IGNORE_FILENAMES\\\\n    )\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            # 삭제된 파일은 빈 문자열로 반환, 오류 발생 방지\\\\n            # 경로로 검색했을 때 존재하지 않는 경우는 삭제된 것으로 암묵적으로 간주\\\\n            # TODO: 명시적으로 삭제된 파일 처리 로직 추가\\\\n            return \\\\\\\"삭제된 파일\\\\\\\"\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[제외 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(\\\\n        f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다. 탐색 완료 경로: {current_dir}\\\\\\\"\\\\n    )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            # 삭제된 파일은 빈 문자열로 반환, 오류 발생 방지\\\\n            # 경로로 검색했을 때 존재하지 않는 경우는 삭제된 것으로 암묵적으로 간주\\\\n            # TODO: 명시적으로 삭제된 파일 처리 로직 추가\\\\n            return \\\\\\\"삭제된 파일\\\\\\\"\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n```\\\", \\\"line_number\\\": 144}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 152, \"file\": \"reviewer/src/utils/file_utils.py\", \"description\": \"파일이 존재하지 않을 때 '삭제된 파일'이라는 문자열을 반환하는 것은 잠재적인 문제를 야기할 수 있습니다. 이는 실제 파일이 존재하지 않는 다른 원인(예: 오타, 잘못된 경로)으로 인한 `FileNotFoundError`를 숨길 수 있으며, 반환된 문자열이 실제 파일 내용과 혼동될 가능성이 있습니다. '삭제된 파일'은 매직 문자열(Magic String)로, 코드의 가독성과 유지보수성을 저해할 수 있습니다.\", \"suggestion\": \"파일이 존재하지 않는 경우, 특정 문자열 대신 `None`을 반환하거나, 더 명확하게 `FileNotFoundError`를 발생시키는 것이 좋습니다. 만약 삭제된 파일을 특별히 구분해야 한다면, TODO 주석에 명시된 것처럼 명시적인 삭제 파일 처리 로직을 구현하는 것이 장기적으로 바람직합니다. 현재 변경의 의도가 삭제된 파일에 대해 오류를 발생시키지 않는 것이라면, `None`을 반환하고 호출하는 쪽에서 `None`을 명시적으로 처리하도록 하는 것이 더 안전합니다.\", \"severity\": \"warning\", \"target_code\": \"return \\\"삭제된 파일\\\"\", \"suggested_code\": \"return None\"}], \"summary\": \"ReviewConverter 클래스가 ReviewFormatter로 리팩토링되었으며, 파일 유틸리티 함수에서 파일 부재 시 처리 방식이 변경되었습니다.\", \"score\": 7.0, \"recommendations\": [\"파일이 존재하지 않는 경우에 대한 오류 처리 방식을 재검토하고, '삭제된 파일'과 같은 매직 문자열 사용을 피하세요. `None` 반환 또는 예외 처리가 더 명확합니다.\", \"TODO 주석으로 남겨진 삭제된 파일 명시적 처리 로직을 구현하여, 파일 부재의 원인(삭제 vs. 경로 오류 등)을 더 정확하게 구분할 수 있도록 개선하세요.\", \"ReviewConverter를 ReviewFormatter로 리팩토링한 변경 사항에 대해 관련 테스트 케이스를 업데이트하거나 추가하여 변경의 정확성을 검증하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"코드 변경 사항은 `review_focus` 기능을 제거하고 관련 코드를 정리합니다.\", \"score\": 10.0, \"recommendations\": [\"`review_focus` 기능 제거가 의도된 변경인지 확인하세요. 변경 사항 자체는 관련 코드를 깔끔하게 제거했습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_converter import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"line_number\\\": 584}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_converter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nimport html\\\\nimport json\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_json(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 JSON 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: JSON 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return json.dumps(review.model_dump(), indent=2, ensure_ascii=False)\\\\n\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, list[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n                if issue.file not in file_issues:\\\\n                    file_issues[issue.file] = []\\\\n                file_issues[issue.file].append(issue)\\\\n\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> list[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            list[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n        )\\\\n\\\\n        return sorted_issues[:limit]\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html, json)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n        return {\\\\n            \\\\\\\"summary\\\\\\\": review.summary,\\\\n            \\\\\\\"score\\\\\\\": review.score,\\\\n            \\\\\\\"total_issues\\\\\\\": len(review.issues),\\\\n            \\\\\\\"severity_counts\\\\\\\": severity_counts,\\\\n            \\\\\\\"type_counts\\\\\\\": type_counts,\\\\n            \\\\\\\"most_critical_issues\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"type\\\\\\\": issue.type,\\\\n                    \\\\\\\"severity\\\\\\\": issue.severity,\\\\n                    \\\\\\\"description\\\\\\\": issue.description,\\\\n                }\\\\n                for issue in most_critical\\\\n            ],\\\\n            \\\\\\\"recommendations\\\\\\\": review.recommendations,\\\\n        }\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n```\\\", \\\"line_number\\\": 165}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 1, \"file\": \"reviewer/src/review_converter.py\", \"description\": \"클래스 이름이 `ReviewConverter`로 변경되었지만, 모듈 수준 docstring에 이전 이름인 `ReviewPostProcessor`가 남아있습니다. 이는 코드와 문서 간의 불일치를 야기할 수 있습니다.\", \"suggestion\": \"docstring을 업데이트하여 실제 클래스 이름과 일치시키고, 클래스의 새로운 역할(변환)을 더 잘 반영하도록 수정하세요.\", \"severity\": \"info\", \"target_code\": \"\\\"\\\"\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\"\\\"\\\"\", \"suggested_code\": \"\\\"\\\"\\\"ReviewConverter: 리뷰 결과를 변환하는 로직을 포함한 모듈.\\\"\\\"\\\"\"}], \"summary\": \"코드 리뷰 결과 처리 로직을 `ReviewConverter` 클래스로 리팩토링하고, `ReviewAnalyzer` 클래스와 `ReviewFormatter`의 JSON 출력 기능을 제거했습니다. 전반적으로 코드는 깔끔하지만, docstring에 사소한 불일치가 있습니다.\", \"score\": 8.0, \"recommendations\": [\"`reviewer/src/review_converter.py` 파일의 모듈 수준 docstring을 업데이트하여 클래스 이름 변경 사항을 반영하세요.\", \"`ReviewAnalyzer` 클래스와 `ReviewFormatter.to_json` 메서드가 제거되었습니다. 이 기능에 의존하는 다른 코드가 없는지 확인하고, 필요한 경우 해당 코드를 업데이트하거나 대체 기능을 구현해야 합니다.\", \"프로젝트 문서(README 등)에 변경된 기능 범위(JSON 출력 및 분석 기능 제거)를 명확히 반영하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/.mvn/wrapper/maven-wrapper.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\ndistributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.4/apache-maven-3.9.4-bin.zip\\\\nwrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/pom.xml\\\", \\\"before_code\\\": \\\"```xml\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```xml\\\\n<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?>\\\\n<project xmlns=\\\\\\\"http://maven.apache.org/POM/4.0.0\\\\\\\" xmlns:xsi=\\\\\\\"http://www.w3.org/2001/XMLSchema-instance\\\\\\\"\\\\n\\\\txsi:schemaLocation=\\\\\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\\\\\">\\\\n\\\\t<modelVersion>4.0.0</modelVersion>\\\\n\\\\t<parent>\\\\n\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t<artifactId>spring-boot-starter-parent</artifactId>\\\\n\\\\t\\\\t<version>3.1.3</version>\\\\n\\\\t\\\\t<relativePath/> <!-- lookup parent from repository -->\\\\n\\\\t</parent>\\\\n\\\\t<groupId>com.hoangtien2k3</groupId>\\\\n\\\\t<artifactId>order-serivce</artifactId>\\\\n\\\\t<version>0.0.1-SNAPSHOT</version>\\\\n\\\\t<name>order-serivce</name>\\\\n\\\\t<description>Demo project for Spring Boot</description>\\\\n\\\\t<properties>\\\\n\\\\t\\\\t<java.version>17</java.version>\\\\n\\\\t</properties>\\\\n\\\\t<dependencies>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jdbc</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jpa</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-security</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-validation</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-web</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-devtools</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>runtime</scope>\\\\n\\\\t\\\\t\\\\t<optional>true</optional>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>com.mysql</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>mysql-connector-j</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>runtime</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t<optional>true</optional>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-test</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.security</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-security-test</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t</dependencies>\\\\n\\\\n\\\\t<build>\\\\n\\\\t\\\\t<plugins>\\\\n\\\\t\\\\t\\\\t<plugin>\\\\n\\\\t\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t<artifactId>spring-boot-maven-plugin</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t<configuration>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t<excludes>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t</exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t</excludes>\\\\n\\\\t\\\\t\\\\t\\\\t</configuration>\\\\n\\\\t\\\\t\\\\t</plugin>\\\\n\\\\t\\\\t</plugins>\\\\n\\\\t</build>\\\\n\\\\n</project>\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"xml\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/src/main/java/com/hoangtien2k3/orderserivce/OrderSerivceApplication.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.orderserivce;\\\\n\\\\nimport org.springframework.boot.SpringApplication;\\\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\\\n\\\\n@SpringBootApplication\\\\npublic class OrderSerivceApplication {\\\\n\\\\n\\\\tpublic static void main(String[] args) {\\\\n\\\\t\\\\tSpringApplication.run(OrderSerivceApplication.class, args);\\\\n\\\\t}\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/src/main/resources/application.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n#Server port :\\\\nserver.port=8813\\\\n\\\\n#Application name :\\\\nspring.application.name=order-service\\\\n\\\\n## Datasource :\\\\nspring.datasource.url=jdbc:mysql://localhost:3306/orderservice?useSSL=false\\\\nspring.datasource.username=root\\\\nspring.datasource.password=12042003\\\\n\\\\n## JPA/Hibernate :\\\\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\\\\nspring.jpa.ddl-auto=update\\\\nspring.jpa.show-sql=true\\\\n\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"order-serivce/src/test/java/com/hoangtien2k3/orderserivce/OrderSerivceApplicationTests.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.orderserivce;\\\\n\\\\nimport org.junit.jupiter.api.Test;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\n\\\\n@SpringBootTest\\\\nclass OrderSerivceApplicationTests {\\\\n\\\\n\\\\t@Test\\\\n\\\\tvoid contextLoads() {\\\\n\\\\t}\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/.mvn/wrapper/maven-wrapper.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\ndistributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.4/apache-maven-3.9.4-bin.zip\\\\nwrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.2.0/maven-wrapper-3.2.0.jar\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/pom.xml\\\", \\\"before_code\\\": \\\"```xml\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```xml\\\\n<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?>\\\\n<project xmlns=\\\\\\\"http://maven.apache.org/POM/4.0.0\\\\\\\" xmlns:xsi=\\\\\\\"http://www.w3.org/2001/XMLSchema-instance\\\\\\\"\\\\n\\\\txsi:schemaLocation=\\\\\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\\\\\">\\\\n\\\\t<modelVersion>4.0.0</modelVersion>\\\\n\\\\t<parent>\\\\n\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t<artifactId>spring-boot-starter-parent</artifactId>\\\\n\\\\t\\\\t<version>3.1.3</version>\\\\n\\\\t\\\\t<relativePath/> <!-- lookup parent from repository -->\\\\n\\\\t</parent>\\\\n\\\\t<groupId>com.hoangtien2k3</groupId>\\\\n\\\\t<artifactId>user-service</artifactId>\\\\n\\\\t<version>0.0.1-SNAPSHOT</version>\\\\n\\\\t<name>user-service</name>\\\\n\\\\t<description>Demo project for Spring Boot</description>\\\\n\\\\t<properties>\\\\n\\\\t\\\\t<java.version>17</java.version>\\\\n\\\\t</properties>\\\\n\\\\t<dependencies>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jdbc</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-data-jpa</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-web</artifactId>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>com.mysql</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>mysql-connector-j</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>runtime</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t<optional>true</optional>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>spring-boot-starter-test</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>javax.validation</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>validation-api</artifactId>\\\\n\\\\t\\\\t\\\\t<version>2.0.0.Final</version>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\t\\\\t<dependency>\\\\n\\\\t\\\\t\\\\t<groupId>junit</groupId>\\\\n\\\\t\\\\t\\\\t<artifactId>junit</artifactId>\\\\n\\\\t\\\\t\\\\t<scope>test</scope>\\\\n\\\\t\\\\t</dependency>\\\\n\\\\n\\\\t</dependencies>\\\\n\\\\n\\\\t<build>\\\\n\\\\t\\\\t<plugins>\\\\n\\\\t\\\\t\\\\t<plugin>\\\\n\\\\t\\\\t\\\\t\\\\t<groupId>org.springframework.boot</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t<artifactId>spring-boot-maven-plugin</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t<configuration>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t<excludes>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<groupId>org.projectlombok</groupId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t<artifactId>lombok</artifactId>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t</exclude>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t</excludes>\\\\n\\\\t\\\\t\\\\t\\\\t</configuration>\\\\n\\\\t\\\\t\\\\t</plugin>\\\\n\\\\t\\\\t</plugins>\\\\n\\\\t</build>\\\\n\\\\n</project>\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"xml\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/UserServiceApplication.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice;\\\\n\\\\nimport org.springframework.boot.SpringApplication;\\\\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\\\\n\\\\n@SpringBootApplication\\\\npublic class UserServiceApplication {\\\\n\\\\n\\\\tpublic static void main(String[] args) {\\\\n\\\\t\\\\tSpringApplication.run(UserServiceApplication.class, args);\\\\n\\\\t}\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/controller/RegisterController.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.controller;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport com.hoangtien2k3.userservice.service.http.header.HeaderGenerator;\\\\nimport jakarta.servlet.http.HttpServletRequest;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.http.HttpStatus;\\\\nimport org.springframework.http.ResponseEntity;\\\\nimport org.springframework.web.bind.annotation.PostMapping;\\\\nimport org.springframework.web.bind.annotation.RequestBody;\\\\nimport org.springframework.web.bind.annotation.RequestMapping;\\\\nimport org.springframework.web.bind.annotation.RestController;\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"/api/register\\\\\\\")\\\\npublic class RegisterController {\\\\n\\\\n    @Autowired\\\\n    private UserService userService;\\\\n\\\\n    @Autowired\\\\n    private HeaderGenerator headerGenerator;\\\\n\\\\n    @PostMapping(value = \\\\\\\"/registration\\\\\\\")\\\\n    public ResponseEntity<User> addUser(@RequestBody User user, HttpServletRequest request){\\\\n        if(user != null)\\\\n            try {\\\\n                userService.saveUser(user);\\\\n                return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessPostMethod(request, user.getId()), HttpStatus.CREATED);\\\\n            }catch (Exception e) {\\\\n                e.printStackTrace();\\\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\\\n            }\\\\n        return new ResponseEntity<User>(HttpStatus.BAD_REQUEST);\\\\n    }\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/controller/UserController.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.controller;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport com.hoangtien2k3.userservice.service.http.header.HeaderGenerator;\\\\nimport jakarta.servlet.http.HttpServletRequest;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.http.HttpStatus;\\\\nimport org.springframework.http.ResponseEntity;\\\\nimport org.springframework.web.bind.annotation.*;\\\\n\\\\nimport java.util.List;\\\\nimport java.util.Optional;\\\\n\\\\n@RestController\\\\n@RequestMapping(\\\\\\\"api/user\\\\\\\")\\\\npublic class UserController {\\\\n\\\\n    @Autowired\\\\n    private UserService userService;\\\\n\\\\n    @Autowired\\\\n    private HeaderGenerator headerGenerator;\\\\n\\\\n    @GetMapping(value = \\\\\\\"/users\\\\\\\")\\\\n    public ResponseEntity<List<User>> getAllUser() {\\\\n        List<User> users = userService.getAllUser();\\\\n\\\\n        if (!users.isEmpty()) {\\\\n            return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\\\n        }\\\\n        return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\\\\n    }\\\\n\\\\n    @GetMapping(value = \\\\\\\"/users\\\\\\\", params = \\\\\\\"name\\\\\\\")\\\\n    public ResponseEntity<User> getUserByName(@RequestParam(\\\\\\\"name\\\\\\\") String username) {\\\\n        User user = userService.getUserByName(username);\\\\n\\\\n        if (user != null) {\\\\n            return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\\\n        }\\\\n        return new ResponseEntity<User>(headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\\\\n\\\\n    }\\\\n\\\\n    @GetMapping(value = \\\\\\\"/users/{id}\\\\\\\")\\\\n    public ResponseEntity<User> getUserById(@PathVariable(\\\\\\\"id\\\\\\\") Long id) {\\\\n        User user = userService.getUserById(id);\\\\n        if (user != null) {\\\\n            return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\\\n        }\\\\n        return new ResponseEntity<User>(headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\\\\n    }\\\\n\\\\n    @PostMapping(value = \\\\\\\"/users\\\\\\\")\\\\n    public ResponseEntity<User> addUser(@RequestBody User user, HttpServletRequest request) {\\\\n        if (user != null)\\\\n            try {\\\\n                userService.saveUser(user);\\\\n                return new ResponseEntity<User>(user, headerGenerator.getHeadersSuccessPostMethod(request, user.getId()), HttpStatus.CREATED);\\\\n            } catch (Exception e) {\\\\n                e.printStackTrace();\\\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\\\n            }\\\\n        return new ResponseEntity<User>(HttpStatus.BAD_REQUEST);\\\\n    }\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/entity/User.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.entity;\\\\n\\\\nimport jakarta.persistence.*;\\\\nimport lombok.*;\\\\n\\\\n@Getter\\\\n@Setter\\\\n@AllArgsConstructor\\\\n@NoArgsConstructor\\\\n@Builder\\\\n@Entity\\\\n@Table(name = \\\\\\\"users\\\\\\\")\\\\npublic class User {\\\\n\\\\n    @Id\\\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\\\n    private Long id;\\\\n\\\\n    @Column(name = \\\\\\\"user_name\\\\\\\", nullable = false, unique = true, length = 50)\\\\n    private String userName;\\\\n    @Column(name = \\\\\\\"user_password\\\\\\\", nullable = false, length = 50)\\\\n    private String userPassword;\\\\n    @Column(name = \\\\\\\"active\\\\\\\")\\\\n    private int active;\\\\n\\\\n    @OneToOne(cascade = CascadeType.ALL)\\\\n    @JoinColumn(name = \\\\\\\"user_details_id\\\\\\\")\\\\n    private UserDetails userDetails;\\\\n\\\\n    @ManyToOne\\\\n    @JoinColumn(name = \\\\\\\"role_id\\\\\\\")\\\\n    private UserRole role;\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserDetails.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.entity;\\\\n\\\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\\\nimport jakarta.persistence.*;\\\\nimport lombok.*;\\\\n\\\\n@Getter\\\\n@Setter\\\\n@AllArgsConstructor\\\\n@NoArgsConstructor\\\\n@Data\\\\n@Entity\\\\n@Table(name = \\\\\\\"users_details\\\\\\\")\\\\npublic class UserDetails {\\\\n\\\\n    @Id\\\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\\\n    private Long id;\\\\n\\\\n    @Column(name = \\\\\\\"first_name\\\\\\\", nullable = false, length = 50)\\\\n    private String firstName;\\\\n    @Column(name = \\\\\\\"last_name\\\\\\\", nullable = false, length = 50)\\\\n    private String lastName;\\\\n    @Column(name = \\\\\\\"email\\\\\\\", nullable = false, unique = true, length = 50)\\\\n    private String email;\\\\n    @Column(name = \\\\\\\"phone_number\\\\\\\", length = 15)\\\\n    private String phoneNumber;\\\\n    @Column(name = \\\\\\\"street\\\\\\\", length = 30)\\\\n    private String street;\\\\n    @Column(name = \\\\\\\"street_number\\\\\\\", length = 10)\\\\n    private String streetNumber;\\\\n    @Column(name = \\\\\\\"zip_code\\\\\\\", length = 6)\\\\n    private String zipCode;\\\\n    @Column(name = \\\\\\\"locality\\\\\\\", length = 30)\\\\n    private String locality;\\\\n    @Column(name = \\\\\\\"country\\\\\\\", length = 30)\\\\n    private String country;\\\\n\\\\n    @OneToOne(mappedBy = \\\\\\\"userDetails\\\\\\\") // bidirectional\\\\n    @JsonIgnore\\\\n    private User user;\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserRole.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.entity;\\\\n\\\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\\\nimport jakarta.persistence.*;\\\\nimport lombok.*;\\\\n\\\\nimport java.util.List;\\\\n\\\\n@Getter\\\\n@Setter\\\\n@AllArgsConstructor\\\\n@NoArgsConstructor\\\\n@Data\\\\n@Entity\\\\n@Table(name = \\\\\\\"user_role\\\\\\\")\\\\npublic class UserRole {\\\\n\\\\n    @Id\\\\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\\\\n    private Long id;\\\\n\\\\n    @Column(name = \\\\\\\"role_name\\\\\\\")\\\\n    private String roleName;\\\\n\\\\n    @OneToMany(mappedBy = \\\\\\\"role\\\\\\\")\\\\n    @JsonIgnore\\\\n    private List<User> users;\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/repository/UserDetailsRepository.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.repository;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.UserDetails;\\\\nimport org.springframework.data.jpa.repository.JpaRepository;\\\\nimport org.springframework.stereotype.Repository;\\\\n\\\\n@Repository\\\\npublic interface UserDetailsRepository extends JpaRepository<UserDetails, Long> {\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/repository/UserRepository.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.repository;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport org.springframework.data.jpa.repository.JpaRepository;\\\\nimport org.springframework.stereotype.Repository;\\\\n\\\\n@Repository\\\\npublic interface UserRepository extends JpaRepository<User, Long> {\\\\n\\\\n    User findByUserName(String userName);\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/repository/UserRoleRepository.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.repository;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.UserRole;\\\\nimport org.springframework.data.jpa.repository.JpaRepository;\\\\n\\\\npublic interface UserRoleRepository extends JpaRepository<UserRole, Long> {\\\\n    UserRole findUserRoleByRoleName(String roleName);\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/UserService.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.service;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\n\\\\nimport java.util.List;\\\\n\\\\npublic interface UserService {\\\\n    List<User> getAllUser();\\\\n    User getUserById(Long id);\\\\n    User getUserByName(String userName);\\\\n    User saveUser(User user);\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/http/header/HeaderGenerator.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.service.http.header;\\\\n\\\\nimport jakarta.servlet.http.HttpServletRequest;\\\\nimport org.springframework.http.HttpHeaders;\\\\nimport org.springframework.stereotype.Service;\\\\n\\\\nimport java.net.URI;\\\\nimport java.net.URISyntaxException;\\\\n\\\\n@Service\\\\npublic class HeaderGenerator {\\\\n\\\\n    public HttpHeaders getHeadersSuccessGetMethod() {\\\\n        HttpHeaders httpHeaders = new HttpHeaders();\\\\n        httpHeaders.add(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"application/json; charset=UTF-8\\\\\\\");\\\\n        return httpHeaders;\\\\n    }\\\\n\\\\n    public HttpHeaders getHeadersError() {\\\\n        HttpHeaders httpHeaders = new HttpHeaders();\\\\n        httpHeaders.add(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"application/problem+json; charset=UTF-8\\\\\\\");\\\\n        return httpHeaders;\\\\n    }\\\\n\\\\n    public HttpHeaders getHeadersSuccessPostMethod(HttpServletRequest request, Long resourceId) {\\\\n        HttpHeaders httpHeaders = new HttpHeaders();\\\\n        try {\\\\n            httpHeaders.setLocation(new URI(request.getRequestURI() + \\\\\\\"/\\\\\\\" + resourceId));\\\\n        } catch (URISyntaxException e) {\\\\n            e.printStackTrace();\\\\n        }\\\\n        httpHeaders.add(\\\\\\\"Content-Type\\\\\\\", \\\\\\\"application/json; charset=UTF-8\\\\\\\");\\\\n        return httpHeaders;\\\\n    }\\\\n}\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.service.impl;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.entity.UserRole;\\\\nimport com.hoangtien2k3.userservice.repository.UserRepository;\\\\nimport com.hoangtien2k3.userservice.repository.UserRoleRepository;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.stereotype.Service;\\\\n\\\\nimport java.util.List;\\\\n\\\\n@Service\\\\npublic class UserServiceImpl implements UserService {\\\\n\\\\n    @Autowired\\\\n    private UserRepository userRepository;\\\\n\\\\n    @Autowired\\\\n    private UserRoleRepository userRoleRepository;\\\\n\\\\n    @Override\\\\n    public List<User> getAllUser() {\\\\n        return userRepository.findAll();\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserById(Long id) {\\\\n\\\\n        return userRepository.getOne(id);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserByName(String userName) {\\\\n        return userRepository.findByUserName(userName);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User saveUser(User user) {\\\\n\\\\n        user.setActive(1); // active success\\\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\\\\\"ROLE_USER\\\\\\\");\\\\n        user.setRole(role);\\\\n\\\\n        return userRepository.save(user);\\\\n    }\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/main/resources/application.properties\\\", \\\"before_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```text\\\\n\\\\nserver.port=8080\\\\nspring.application.name= user-service\\\\nserver.url= http://localhost:8080\\\\n\\\\n##Client registration properties :\\\\n#eureka.client.service-url.defaultZone = http://localhost:8070/eureka\\\\n\\\\nspring.datasource.url=jdbc:mysql://localhost:3306/userservice?useSSL=false\\\\nspring.datasource.username=root\\\\nspring.datasource.password=12042003\\\\n\\\\nspring.jpa.show-sql=true\\\\nspring.jpa.properties.hibernate=org.hibernate.dialect.MySQLDialect\\\\nspring.jpa.hibernate.ddl-auto= update\\\\n\\\\n##### HTTP #####\\\\nerror.404.schema.details=The resource you are looking for might have been removed, had its name changed, or is temporarily unavailable\\\\nerror.406.schema.details=This request is not acceptable. Supported MIME types are application/json\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/test/java/com/hoangtien2k3/userservice/UserServiceApplicationTests.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice;\\\\n\\\\nimport org.junit.jupiter.api.Test;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\n\\\\n@SpringBootTest\\\\nclass UserServiceApplicationTests {\\\\n\\\\n\\\\t@Test\\\\n\\\\tvoid contextLoads() {\\\\n\\\\t}\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/test/java/com/hoangtien2k3/userservice/controllertest/UserControllerTest.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.controllertest;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport org.junit.Test;\\\\nimport org.junit.runner.RunWith;\\\\nimport org.mockito.Mockito;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\nimport org.springframework.http.MediaType;\\\\nimport org.springframework.test.context.junit4.SpringRunner;\\\\nimport org.springframework.test.web.client.ExpectedCount;\\\\nimport org.springframework.test.web.servlet.MockMvc;\\\\nimport org.springframework.test.web.servlet.ResultMatcher;\\\\n\\\\nimport java.util.ArrayList;\\\\nimport java.util.List;\\\\n\\\\n\\\\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\\\\nimport static org.springframework.test.web.client.ExpectedCount.times;\\\\nimport static org.springframework.test.web.client.match.MockRestRequestMatchers.content;\\\\nimport static org.springframework.test.web.client.match.MockRestRequestMatchers.jsonPath;\\\\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\\\\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\\\\n\\\\n@AutoConfigureMockMvc\\\\n@RunWith(SpringRunner.class)\\\\n@SpringBootTest\\\\npublic class UserControllerTest {\\\\n    private final Long USER_ID = 1L;\\\\n    private final String USER_NAME = \\\\\\\"test\\\\\\\";\\\\n    private User user;\\\\n    private List<User> listUsers;\\\\n\\\\n    @Autowired\\\\n    private MockMvc mockMvc;\\\\n\\\\n    @Autowired\\\\n    private UserService userService;\\\\n\\\\n    @Test\\\\n    public void getAllUserController_Should_Return200_When_ValidRequest() throws Exception {\\\\n/*\\\\n        User user1 = User.builder()\\\\n                .id(USER_ID)\\\\n                .userName(USER_NAME)\\\\n                .build();\\\\n\\\\n        listUsers = new ArrayList<>();\\\\n        listUsers.add(user1);\\\\n\\\\n        Mockito.when(userService.getAllUser()).thenReturn(listUsers);\\\\n\\\\n        //then\\\\n        mockMvc.perform(get(\\\\\\\"/users\\\\\\\"))\\\\n                .andExpect(status().isOk())\\\\n                .andExpect((ResultMatcher) content().contentType(MediaType.APPLICATION_JSON_UTF8))\\\\n                .andExpect((ResultMatcher) jsonPath(\\\\\\\"$[0].id\\\\\\\").value(USER_ID))\\\\n                .andExpect((ResultMatcher) jsonPath(\\\\\\\"$[0].userName\\\\\\\").value(USER_NAME));\\\\n\\\\n        verify(userService, times(1)).getAllUsers();\\\\n        verifyNoMoreInteractions(userService);\\\\n*/\\\\n\\\\n\\\\n    }\\\\n\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"user-service/src/test/java/com/hoangtien2k3/userservice/servicetest/UserControllerTest.java\\\", \\\"before_code\\\": \\\"```java\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```java\\\\npackage com.hoangtien2k3.userservice.servicetest;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.repository.UserRepository;\\\\nimport com.hoangtien2k3.userservice.service.impl.UserServiceImpl;\\\\nimport org.junit.Before;\\\\nimport org.junit.Test;\\\\nimport org.junit.runner.RunWith;\\\\nimport org.mockito.InjectMocks;\\\\nimport org.mockito.Mock;\\\\nimport org.mockito.Mockito;\\\\nimport org.springframework.boot.test.context.SpringBootTest;\\\\nimport org.springframework.test.context.junit4.SpringRunner;\\\\n\\\\nimport java.util.ArrayList;\\\\nimport java.util.List;\\\\n\\\\nimport static org.junit.Assert.assertEquals;\\\\nimport static org.mockito.ArgumentMatchers.anyLong;\\\\nimport static org.mockito.ArgumentMatchers.anyString;\\\\n\\\\n\\\\n@SpringBootTest\\\\n@RunWith(SpringRunner.class)\\\\npublic class UserControllerTest {\\\\n\\\\n    private final Long USER_ID = 2L;\\\\n    private final String USER_NAME = \\\\\\\"test\\\\\\\";\\\\n    private List<User> userList;\\\\n    private User user;\\\\n\\\\n    @Mock\\\\n    private UserRepository userRepository;\\\\n\\\\n    @InjectMocks\\\\n    private UserServiceImpl userService;\\\\n\\\\n    @Before\\\\n    public void setUp() {\\\\n        user = User.builder()\\\\n                .id(USER_ID)\\\\n                .userName(USER_NAME)\\\\n                .build();\\\\n\\\\n        userList = new ArrayList<>();\\\\n        userList.add(user);\\\\n    }\\\\n\\\\n    @Test\\\\n    public void get_AllUser_Test() {\\\\n        // give\\\\n        Mockito.when(userRepository.findAll()).thenReturn(userList);\\\\n\\\\n        // when\\\\n        List<User> foundUsers = userService.getAllUser();\\\\n\\\\n        // then\\\\n        assertEquals(foundUsers.get(0).getUserName(), USER_NAME);\\\\n        Mockito.verify(userRepository, Mockito.times(1)).findAll();\\\\n        Mockito.verifyNoMoreInteractions(userRepository);\\\\n    }\\\\n\\\\n    @Test\\\\n    public void get_UserById_Test(){\\\\n        // given\\\\n        Mockito.when(userRepository.getOne(anyLong())).thenReturn(user);\\\\n\\\\n        // when\\\\n        User foundUser = userService.getUserById(USER_ID);\\\\n\\\\n        // then\\\\n        assertEquals(foundUser.getUserName(), USER_NAME);\\\\n        Mockito.verify(userRepository, Mockito.times(1)).getOne(anyLong());\\\\n        Mockito.verifyNoMoreInteractions(userRepository);\\\\n    }\\\\n\\\\n    @Test\\\\n    public void get_UserByName_Test(){\\\\n        // given\\\\n        Mockito.when(userRepository.findByUserName(anyString())).thenReturn(user);\\\\n\\\\n        // when\\\\n        User foundUser = userService.getUserByName(USER_NAME);\\\\n\\\\n        // then\\\\n        assertEquals(foundUser.getId(), USER_ID);\\\\n        Mockito.verify(userRepository, Mockito.times(1)).findByUserName(USER_NAME);\\\\n        Mockito.verifyNoMoreInteractions(userRepository);\\\\n    }\\\\n\\\\n\\\\n\\\\n}\\\\n```\\\", \\\"line_number\\\": 1, \\\"language\\\": \\\"java\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"security\", \"line_number\": 8, \"file\": \"order-serivce/src/main/resources/application.properties\", \"description\": \"데이터베이스 접속 정보(username, password)가 설정 파일에 하드코딩되어 있습니다. 이는 보안상 매우 취약합니다.\", \"suggestion\": \"데이터베이스 접속 정보는 환경 변수, 외부 설정 서버(예: Spring Cloud Config), 또는 시크릿 관리 시스템(예: Vault, Kubernetes Secrets)을 사용하여 관리해야 합니다.\", \"severity\": \"error\", \"target_code\": \"spring.datasource.username=root\\nspring.datasource.password=12042003\", \"suggested_code\": null}, {\"type\": \"security\", \"line_number\": 9, \"file\": \"user-service/src/main/resources/application.properties\", \"description\": \"데이터베이스 접속 정보(username, password)가 설정 파일에 하드코딩되어 있습니다. 이는 보안상 매우 취약합니다.\", \"suggestion\": \"데이터베이스 접속 정보는 환경 변수, 외부 설정 서버(예: Spring Cloud Config), 또는 시크릿 관리 시스템(예: Vault, Kubernetes Secrets)을 사용하여 관리해야 합니다.\", \"severity\": \"error\", \"target_code\": \"spring.datasource.username=root\\nspring.datasource.password=12042003\", \"suggested_code\": null}, {\"type\": \"security\", \"line_number\": 21, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/User.java\", \"description\": \"사용자 비밀번호 필드(userPassword)의 길이가 50자로 설정되어 있습니다. 안전한 비밀번호 해싱 알고리즘(예: BCrypt)으로 암호화된 비밀번호를 저장하기에는 길이가 너무 짧습니다. 또한, 비밀번호가 해싱되지 않고 저장될 가능성이 있습니다.\", \"suggestion\": \"비밀번호는 반드시 BCrypt와 같은 강력한 단방향 해싱 알고리즘으로 암호화하여 저장해야 합니다. 비밀번호 해시를 저장할 필드의 길이는 해싱 알고리즘의 출력 길이를 고려하여 충분히 길게 설정하세요 (예: BCrypt의 경우 60자 이상).\", \"severity\": \"error\", \"target_code\": \"@Column(name = \\\"user_password\\\", nullable = false, length = 50)\\n    private String userPassword;\", \"suggested_code\": \"@Column(name = \\\"user_password\\\", nullable = false, length = 100) // BCrypt 해시를 저장하기 위한 충분한 길이\\n    private String userPassword;\"}, {\"type\": \"security\", \"line_number\": 37, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"사용자 비밀번호를 저장하기 전에 해싱하는 로직이 없습니다. 비밀번호를 평문으로 저장하는 것은 심각한 보안 취약점입니다.\", \"suggestion\": \"Spring Security의 PasswordEncoder(예: BCryptPasswordEncoder)를 사용하여 사용자 비밀번호를 저장하기 전에 반드시 해싱해야 합니다.\", \"severity\": \"error\", \"target_code\": \"return userRepository.save(user);\", \"suggested_code\": \"user.setUserPassword(passwordEncoder.encode(user.getUserPassword()));\\n        return userRepository.save(user);\"}, {\"type\": \"bug\", \"line_number\": 30, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/controller/RegisterController.java\", \"description\": \"광범위한 Exception을 catch하고 있습니다. 이는 예상치 못한 오류를 숨기고 디버깅을 어렵게 만들 수 있습니다. 또한, 스택 트레이스를 콘솔에 출력하는 것은 운영 환경에서 부적절하며, 민감한 정보가 노출될 위험이 있습니다.\", \"suggestion\": \"구체적인 예외를 catch하고 각 예외에 맞는 적절한 처리를 수행하세요. 예외 발생 시에는 로깅 프레임워크(예: SLF4J)를 사용하여 오류를 기록해야 합니다. 클라이언트에게는 일반적인 오류 메시지를 반환하는 것이 좋습니다.\", \"severity\": \"error\", \"target_code\": \"}catch (Exception e) {\\n                e.printStackTrace();\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\n            }\", \"suggested_code\": \"} catch (DataIntegrityViolationException e) { // 예시: 데이터베이스 제약 조건 위반\\n                // 로깅: log.error(\\\"Failed to save user due to data integrity violation\\\", e);\\n                return new ResponseEntity<>(HttpStatus.CONFLICT); // 409 Conflict\\n            } catch (Exception e) { // 그 외 예상치 못한 오류\\n                // 로깅: log.error(\\\"An unexpected error occurred while saving user\\\", e);\\n                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); // 500 Internal Server Error\\n            }\"}, {\"type\": \"bug\", \"line_number\": 60, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/controller/UserController.java\", \"description\": \"광범위한 Exception을 catch하고 있습니다. 이는 예상치 못한 오류를 숨기고 디버깅을 어렵게 만들 수 있습니다. 또한, 스택 트레이스를 콘솔에 출력하는 것은 운영 환경에서 부적절하며, 민감한 정보가 노출될 위험이 있습니다.\", \"suggestion\": \"구체적인 예외를 catch하고 각 예외에 맞는 적절한 처리를 수행하세요. 예외 발생 시에는 로깅 프레임워크(예: SLF4J)를 사용하여 오류를 기록해야 합니다. 클라이언트에게는 일반적인 오류 메시지를 반환하는 것이 좋습니다.\", \"severity\": \"error\", \"target_code\": \"} catch (Exception e) {\\n                e.printStackTrace();\\n                return new ResponseEntity<User>(HttpStatus.INTERNAL_SERVER_ERROR);\\n            }\", \"suggested_code\": \"} catch (DataIntegrityViolationException e) { // 예시: 데이터베이스 제약 조건 위반\\n                // 로깅: log.error(\\\"Failed to save user due to data integrity violation\\\", e);\\n                return new ResponseEntity<>(HttpStatus.CONFLICT); // 409 Conflict\\n            } catch (Exception e) { // 그 외 예상치 못한 오류\\n                // 로깅: log.error(\\\"An unexpected error occurred while saving user\\\", e);\\n                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); // 500 Internal Server Error\\n            }\"}, {\"type\": \"bug\", \"line_number\": 28, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/controller/UserController.java\", \"description\": \"사용자 목록이 비어 있을 때 HTTP 상태 코드 404 Not Found를 반환하고 있습니다. 컬렉션 리소스에 대한 GET 요청에서 결과가 없을 때는 일반적으로 200 OK와 빈 목록을 반환하는 것이 RESTful API의 표준입니다.\", \"suggestion\": \"사용자 목록이 비어 있더라도 200 OK 상태 코드와 빈 리스트를 반환하도록 수정하세요.\", \"severity\": \"warning\", \"target_code\": \"if (!users.isEmpty()) {\\n            return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\\n        }\\n        return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersError(), HttpStatus.NOT_FOUND);\", \"suggested_code\": \"return new ResponseEntity<List<User>>(users, headerGenerator.getHeadersSuccessGetMethod(), HttpStatus.OK);\"}, {\"type\": \"bug\", \"line_number\": 28, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"사용자 ID로 조회 시 `userRepository.getOne(id)`를 사용하고 있습니다. `getOne`은 Spring Data JPA 2.x부터 deprecated되었으며, `getReferenceById`로 대체되었습니다. 이 메서드는 실제 엔티티를 즉시 로드하지 않고 프록시를 반환할 수 있으며, 엔티티가 존재하지 않을 경우 `EntityNotFoundException`이 발생할 수 있습니다. 일반적으로 ID로 단일 엔티티를 조회할 때는 `findById`를 사용하는 것이 권장됩니다.\", \"suggestion\": \"`userRepository.findById(id)`를 사용하여 `Optional<User>`를 반환받고, 결과가 없을 경우 적절히 처리하세요 (예: null 반환 또는 예외 발생).\", \"severity\": \"warning\", \"target_code\": \"return userRepository.getOne(id);\", \"suggested_code\": \"return userRepository.findById(id).orElse(null); // 또는 Optional<User> 반환 및 호출부에서 처리\"}, {\"type\": \"style\", \"line_number\": 6, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/User.java\", \"description\": \"Lombok의 `@Data` 어노테이션은 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`를 포함합니다. 이미 `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor`, `@Builder`를 사용하고 있으므로 `@Data`는 중복이며, 특히 양방향 연관 관계에서 `@ToString` 및 `@EqualsAndHashCode`로 인해 StackOverflowError가 발생할 수 있습니다.\", \"suggestion\": \"`@Data` 어노테이션을 제거하고 필요한 Lombok 어노테이션만 명시적으로 사용하거나, `@Data`를 사용하되 연관 관계 필드에 `@ToString.Exclude` 및 `@EqualsAndHashCode.Exclude`를 추가하여 문제를 방지하세요.\", \"severity\": \"warning\", \"target_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Builder\\n@Entity\\n@Table(name = \\\"users\\\")\", \"suggested_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Builder\\n@Entity\\n@Table(name = \\\"users\\\")\\n// @Data 사용 시:\\n// @Data\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private UserDetails userDetails;\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private UserRole role;\"}, {\"type\": \"style\", \"line_number\": 10, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserDetails.java\", \"description\": \"Lombok의 `@Data` 어노테이션은 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`를 포함합니다. 이미 `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor`를 사용하고 있으므로 `@Data`는 중복이며, 특히 양방향 연관 관계에서 `@ToString` 및 `@EqualsAndHashCode`로 인해 StackOverflowError가 발생할 수 있습니다.\", \"suggestion\": \"`@Data` 어노테이션을 제거하고 필요한 Lombok 어노테이션만 명시적으로 사용하거나, `@Data`를 사용하되 연관 관계 필드에 `@ToString.Exclude` 및 `@EqualsAndHashCode.Exclude`를 추가하여 문제를 방지하세요.\", \"severity\": \"warning\", \"target_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Data\\n@Entity\\n@Table(name = \\\"users_details\\\")\", \"suggested_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Entity\\n@Table(name = \\\"users_details\\\")\\n// @Data 사용 시:\\n// @Data\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private User user;\"}, {\"type\": \"style\", \"line_number\": 10, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/entity/UserRole.java\", \"description\": \"Lombok의 `@Data` 어노테이션은 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`를 포함합니다. 이미 `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor`를 사용하고 있으므로 `@Data`는 중복이며, 특히 양방향 연관 관계에서 `@ToString` 및 `@EqualsAndHashCode`로 인해 StackOverflowError가 발생할 수 있습니다.\", \"suggestion\": \"`@Data` 어노테이션을 제거하고 필요한 Lombok 어노테이션만 명시적으로 사용하거나, `@Data`를 사용하되 연관 관계 필드에 `@ToString.Exclude` 및 `@EqualsAndHashCode.Exclude`를 추가하여 문제를 방지하세요.\", \"severity\": \"warning\", \"target_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Data\\n@Entity\\n@Table(name = \\\"user_role\\\")\", \"suggested_code\": \"@Getter\\n@Setter\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@Entity\\n@Table(name = \\\"user_role\\\")\\n// @Data 사용 시:\\n// @Data\\n// @ToString.Exclude\\n// @EqualsAndHashCode.Exclude\\n// private List<User> users;\"}, {\"type\": \"style\", \"line_number\": 25, \"file\": \"user-service/src/test/java/com/hoangtien2k3/userservice/controllertest/UserControllerTest.java\", \"description\": \"JUnit 4 어노테이션(`@Test`, `@RunWith`)이 사용되었습니다. Spring Boot 3.x는 JUnit 5를 기본으로 사용하므로, 테스트 프레임워크를 JUnit 5로 통일하는 것이 좋습니다.\", \"suggestion\": \"JUnit 5 어노테이션(`org.junit.jupiter.api.Test`, `@ExtendWith(SpringExtension.class)`)으로 변경하세요. `SpringRunner` 대신 `SpringExtension`을 사용합니다.\", \"severity\": \"info\", \"target_code\": \"import org.junit.Test;\\nimport org.junit.runner.RunWith;\", \"suggested_code\": \"import org.junit.jupiter.api.Test;\\nimport org.junit.jupiter.api.extension.ExtendWith;\\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\"}, {\"type\": \"style\", \"line_number\": 22, \"file\": \"user-service/src/test/java/com/hoangtien2k3/userservice/servicetest/UserControllerTest.java\", \"description\": \"JUnit 4 어노테이션(`@Test`, `@Before`, `@RunWith`)이 사용되었습니다. Spring Boot 3.x는 JUnit 5를 기본으로 사용하므로, 테스트 프레임워크를 JUnit 5로 통일하는 것이 좋습니다.\", \"suggestion\": \"JUnit 5 어노테이션(`org.junit.jupiter.api.Test`, `org.junit.jupiter.api.BeforeEach`, `@ExtendWith(SpringExtension.class)`)으로 변경하세요. `SpringRunner` 대신 `SpringExtension`을 사용합니다.\", \"severity\": \"info\", \"target_code\": \"import org.junit.Before;\\nimport org.junit.Test;\\nimport org.junit.runner.RunWith;\", \"suggested_code\": \"import org.junit.jupiter.api.BeforeEach;\\nimport org.junit.jupiter.api.Test;\\nimport org.junit.jupiter.api.extension.ExtendWith;\\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\"}, {\"type\": \"style\", \"line_number\": 12, \"file\": \"user-service/pom.xml\", \"description\": \"Spring Boot 3.x는 Jakarta EE 기반이므로 `javax.validation` 대신 `jakarta.validation`을 사용해야 합니다. `spring-boot-starter-validation` 의존성을 사용하면 자동으로 `jakarta.validation-api`와 구현체(Hibernate Validator)가 포함됩니다.\", \"suggestion\": \"`javax.validation:validation-api` 의존성을 제거하세요. `spring-boot-starter-validation`이 이미 Jakarta Validation API를 제공합니다.\", \"severity\": \"warning\", \"target_code\": \"<dependency>\\n\\t\\t\\t<groupId>javax.validation</groupId>\\n\\t\\t\\t<artifactId>validation-api</artifactId>\\n\\t\\t\\t<version>2.0.0.Final</version>\\n\\t\\t</dependency>\", \"suggested_code\": null}, {\"type\": \"style\", \"line_number\": 13, \"file\": \"user-service/pom.xml\", \"description\": \"JUnit 4 의존성(`junit:junit`)이 추가되었습니다. Spring Boot Starter Test는 기본적으로 JUnit 5(Jupiter)를 포함하므로, JUnit 4와 5를 함께 사용하는 것은 혼란을 야기할 수 있습니다. JUnit 5로 테스트 프레임워크를 통일하는 것이 좋습니다.\", \"suggestion\": \"`junit:junit` 의존성을 제거하고 모든 테스트를 JUnit 5로 마이그레이션하세요.\", \"severity\": \"info\", \"target_code\": \"<dependency>\\n\\t\\t\\t<groupId>junit</groupId>\\n\\t\\t\\t<artifactId>junit</artifactId>\\n\\t\\t\\t<scope>test</scope>\\n\\t\\t</dependency>\", \"suggested_code\": null}, {\"type\": \"performance\", \"line_number\": 15, \"file\": \"order-serivce/src/main/resources/application.properties\", \"description\": \"`spring.jpa.ddl-auto=update` 설정은 애플리케이션 시작 시 JPA가 데이터베이스 스키마를 자동으로 업데이트하도록 합니다. 개발 단계에서는 편리하지만, 운영 환경에서는 예상치 못한 스키마 변경이나 데이터 손실을 유발할 수 있어 위험합니다.\", \"suggestion\": \"운영 환경에서는 `spring.jpa.ddl-auto` 설정을 `validate` 또는 `none`으로 변경하고, 스키마 변경은 Flyway나 Liquibase와 같은 마이그레이션 도구를 사용하여 관리하는 것이 안전합니다.\", \"severity\": \"warning\", \"target_code\": \"spring.jpa.ddl-auto=update\", \"suggested_code\": \"spring.jpa.ddl-auto=validate # 또는 none\"}, {\"type\": \"performance\", \"line_number\": 14, \"file\": \"user-service/src/main/resources/application.properties\", \"description\": \"`spring.jpa.hibernate.ddl-auto= update` 설정은 애플리케이션 시작 시 JPA가 데이터베이스 스키마를 자동으로 업데이트하도록 합니다. 개발 단계에서는 편리하지만, 운영 환경에서는 예상치 못한 스키마 변경이나 데이터 손실을 유발할 수 있어 위험합니다.\", \"suggestion\": \"운영 환경에서는 `spring.jpa.hibernate.ddl-auto` 설정을 `validate` 또는 `none`으로 변경하고, 스키마 변경은 Flyway나 Liquibase와 같은 마이그레이션 도구를 사용하여 관리하는 것이 안전합니다.\", \"severity\": \"warning\", \"target_code\": \"spring.jpa.hibernate.ddl-auto= update\", \"suggested_code\": \"spring.jpa.hibernate.ddl-auto= validate # 또는 none\"}, {\"type\": \"bug\", \"line_number\": 13, \"file\": \"user-service/src/main/resources/application.properties\", \"description\": \"`spring.jpa.properties.hibernate=org.hibernate.dialect.MySQLDialect` 속성 키가 잘못되었습니다. 올바른 속성 키는 `spring.jpa.properties.hibernate.dialect`입니다.\", \"suggestion\": \"속성 키를 `spring.jpa.properties.hibernate.dialect`로 수정하세요.\", \"severity\": \"error\", \"target_code\": \"spring.jpa.properties.hibernate=org.hibernate.dialect.MySQLDialect\", \"suggested_code\": \"spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\"}], \"summary\": \"초기 Spring Boot 프로젝트 설정 및 기본 CRUD 기능 구현입니다. 데이터베이스 연결, JPA 엔티티 및 레포지토리, 기본적인 서비스 및 컨트롤러 레이어가 구성되었습니다. Maven Wrapper 및 POM 파일 설정, 애플리케이션 진입점, 속성 파일 설정 등이 포함됩니다. 전반적으로 기본적인 구조는 갖추었으나, 보안, 오류 처리, 의존성 관리, 테스트 코드 등 여러 측면에서 개선이 필요합니다.\", \"score\": 3.0, \"recommendations\": [\"데이터베이스 접속 정보 및 민감한 설정은 환경 변수나 외부 설정 관리 시스템을 사용하세요.\", \"사용자 비밀번호는 반드시 강력한 해싱 알고리즘으로 암호화하여 저장하고, 로그인 시 검증 로직을 추가하세요.\", \"예외 처리를 구체화하고, 로깅 프레임워크를 사용하여 오류를 기록하세요. 클라이언트에게는 상세한 스택 트레이스 대신 일반적인 오류 응답을 제공하세요.\", \"Spring Boot 3.x 환경에 맞게 Jakarta EE 기반의 의존성(예: `jakarta.validation`)을 사용하고, JUnit 5로 테스트 프레임워크를 통일하세요.\", \"JPA `ddl-auto` 설정은 운영 환경에서 `validate` 또는 `none`으로 변경하고, 스키마 변경은 마이그레이션 도구를 사용하세요.\", \"Lombok `@Data` 사용 시 양방향 연관 관계에서 StackOverflowError가 발생하지 않도록 `@ToString.Exclude`, `@EqualsAndHashCode.Exclude`를 사용하거나 `@Data` 대신 필요한 어노테이션만 명시적으로 사용하세요.\", \"`userRepository.getOne` 대신 `userRepository.findById`를 사용하고 `Optional` 결과를 처리하도록 코드를 수정하세요.\", \"테스트 코드를 작성하고 실행하여 코드의 신뢰성을 높이세요. 현재 주석 처리된 테스트 코드를 활성화하고 완성하세요.\", \"컨트롤러에서 빈 목록 응답 시 404 대신 200 OK를 반환하도록 수정하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. 기술 용어나 전문 용어가 사용될 경우, 독자의 이해를 돕기 위해 간결한 용어 해설을 덧붙여주세요. (예: \\\"Hunk: Git diff에서 변경된 코드 덩어리를 의미합니다.\\\")\\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff, run_git_diff\\\\nfrom reviewer.src.llm_gateway import BaseGateway\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff, run_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n```\\\", \\\"line_number\\\": 14, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"before_code\\\": \\\"```python\\\\n    save_review_request(review_request, args.model)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = BaseGateway.create(model=args.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {args.model})\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    save_review_request(review_request, args.model)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=args.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {args.model})\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 472, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/__init__.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .openai_gateway import OpenAIGateway\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"BaseGateway\\\\\\\",\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n    \\\\\\\"get_default_model\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\nfrom .openai_gateway import OpenAIGateway\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"BaseGateway\\\\\\\",\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n    \\\\\\\"get_default_model\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 5, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\nimport abc\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\nfrom . import get_model_info\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport abc\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 5, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n            ReviewResponse: 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            ReviewResponse: 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n```\\\", \\\"line_number\\\": 96, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n)\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import BaseGateway, ClaudeGateway, OpenAIGateway\\\\n\\\\n\\\\nclass TestOpenAIGateway(unittest.TestCase):\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n)\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import ClaudeGateway, GatewayFactory, OpenAIGateway\\\\n\\\\n\\\\nclass TestOpenAIGateway(unittest.TestCase):\\\\n```\\\", \\\"line_number\\\": 8, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 모델명으로 get_llm_gateway 호출 시 실제 OpenAIGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = BaseGateway.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 검증 - 실제 OpenAIGateway 인스턴스인지 확인\\\\n        self.assertIsInstance(gateway, OpenAIGateway)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 모델명으로 get_llm_gateway 호출 시 실제 OpenAIGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 검증 - 실제 OpenAIGateway 인스턴스인지 확인\\\\n        self.assertIsInstance(gateway, OpenAIGateway)\\\\n```\\\", \\\"line_number\\\": 141, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 모델명으로 get_llm_gateway 호출 시 ClaudeGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = BaseGateway.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, ClaudeGateway)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 모델명으로 get_llm_gateway 호출 시 ClaudeGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, ClaudeGateway)\\\\n```\\\", \\\"line_number\\\": 152, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n        mock_openai_gateway.return_value = mock_instance\\\\n\\\\n        # 모델을 지정하지 않고 함수 호출\\\\n        gateway = BaseGateway.create(\\\\\\\"o4-mini\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertEqual(gateway, mock_instance)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        mock_openai_gateway.return_value = mock_instance\\\\n\\\\n        # 모델을 지정하지 않고 함수 호출\\\\n        gateway = GatewayFactory.create(\\\\\\\"\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertEqual(gateway, mock_instance)\\\\n```\\\", \\\"line_number\\\": 167, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"5\\\", \\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n    # UnsupportedModelError 테스트\\\\n    @patch(\\\\n        \\\\\\\"reviewer.src.llm_gateway.base_gateway.get_model_info\\\\\\\",\\\\n        side_effect=UnsupportedModelError(\\\\\\\"unsupported-model\\\\\\\"),\\\\n    )\\\\n    def test_create_gateway_with_unsupported_model(self, mock_get_model_info):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"지원하지 않는 모델명으로 get_llm_gateway 호출 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(UnsupportedModelError) as context:\\\\n            BaseGateway.create(\\\\\\\"unsupported-model\\\\\\\")\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.model_name, \\\\\\\"unsupported-model\\\\\\\")\\\\n        mock_get_model_info.assert_called_once_with(\\\\\\\"unsupported-model\\\\\\\")\\\\n\\\\n    # UnsupportedProviderError 테스트\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.get_model_info\\\\\\\")\\\\n    def test_create_gateway_with_unsupported_provider(self, mock_get_model_info):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"지원하지 않는 제공자를 가진 모델로 get_llm_gateway 호출 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 지원하지 않는 제공자를 가진 모델 정보 반환\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n    # UnsupportedModelError 테스트\\\\n    @patch(\\\\n        \\\\\\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\\\\\",\\\\n        side_effect=UnsupportedModelError(\\\\\\\"unsupported-model\\\\\\\"),\\\\n    )\\\\n    def test_create_gateway_with_unsupported_model(self, mock_get_model_info):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"지원하지 않는 모델명으로 get_llm_gateway 호출 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(UnsupportedModelError) as context:\\\\n            GatewayFactory.create(\\\\\\\"unsupported-model\\\\\\\")\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.model_name, \\\\\\\"unsupported-model\\\\\\\")\\\\n        mock_get_model_info.assert_called_once_with(\\\\\\\"unsupported-model\\\\\\\")\\\\n\\\\n    # UnsupportedProviderError 테스트\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\\\\\")\\\\n    def test_create_gateway_with_unsupported_provider(self, mock_get_model_info):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"지원하지 않는 제공자를 가진 모델로 get_llm_gateway 호출 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 지원하지 않는 제공자를 가진 모델 정보 반환\\\\n```\\\", \\\"line_number\\\": 177, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"6\\\", \\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(UnsupportedProviderError) as context:\\\\n            BaseGateway.create(\\\\\\\"wrong_model_name\\\\\\\")\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.provider, \\\\\\\"unsupported_provider\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(UnsupportedProviderError) as context:\\\\n            GatewayFactory.create(\\\\\\\"wrong_model_name\\\\\\\")\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.provider, \\\\\\\"unsupported_provider\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 205, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"LLM 게이트웨이 생성 로직을 전용 팩토리 클래스(`GatewayFactory`)로 분리하는 리팩토링이 적용되었습니다. `BaseGateway`에서 생성 책임을 제거하고, 클라이언트 코드(`cli.py`, 테스트 코드)에서 `GatewayFactory`를 사용하도록 변경되었습니다.\", \"score\": 10.0, \"recommendations\": [\"이 변경은 게이트웨이 생성 책임을 `BaseGateway`에서 분리하여 코드의 응집도를 높이고 단일 책임 원칙(Single Responsibility Principle)을 따르게 합니다. 전반적으로 코드 구조 개선에 기여하는 좋은 리팩토링입니다.\", \"새로 생성된 `GatewayFactory` 클래스 자체의 구현 코드(제공되지 않음)에 대한 리뷰도 필요합니다. 특히 예외 처리, 모델 정보 조회 로직 등이 올바르게 구현되었는지 확인해야 합니다.\", \"테스트 코드(`tests/test_llm_gateway.py`)에서 `patch` 데코레이터의 타겟 경로를 `base_gateway`에서 `gateway_factory`로 올바르게 변경한 점은 좋습니다.\"]}"
  }
]