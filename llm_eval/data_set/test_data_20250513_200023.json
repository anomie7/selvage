[
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"파일 형식 결정 중 오류 발생: {e}\\\\\\\")\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        file_format = determine_file_format(file_path)\\\\n\\\\n        if file_format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"line_number\\\": 506}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"Design\", \"line_number\": 18, \"file\": \"reviewer/src/ui.py\", \"description\": \"`sys.path`를 직접 수정하는 것은 모듈 임포트 경로를 예측하기 어렵게 만들고, 패키지 관리 시스템(pip 등)과의 충돌을 유발할 수 있습니다. 이 변경은 `sys.path` 수정을 제거하여 더 표준적인 Python 모듈 임포트 방식을 따르게 합니다.\", \"suggestion\": \"이 변경은 좋은 방향입니다. 프로젝트가 패키지로 올바르게 설정되어 있다면, `sys.path` 수정 없이도 내부 모듈 임포트가 잘 작동할 것입니다.\", \"severity\": \"info\", \"original_code\": \"sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\"..\\\")))\", \"improved_code\": \"\"}, {\"type\": \"Style\", \"line_number\": 509, \"file\": \"reviewer/src/ui.py\", \"description\": \"`run_app` 함수 내에서 `os`와 `sys` 모듈을 다시 임포트하고 있습니다. 이 모듈들은 파일 상단에서 이미 임포트되었으므로 함수 내에서의 임포트는 불필요합니다.\", \"suggestion\": \"함수 내 불필요한 중복 임포트를 제거하여 코드를 더 깔끔하게 유지합니다. (이 변경에서 이미 제거됨)\", \"severity\": \"info\", \"original_code\": \"    import os\\n    import subprocess\\n    import sys\", \"improved_code\": \"    import subprocess\"}], \"summary\": \"이 변경사항은 `sys.path` 직접 수정을 제거하고 함수 내 불필요한 중복 임포트를 제거하여 코드의 구조와 스타일을 개선합니다. 이는 더 표준적이고 유지보수하기 쉬운 코드를 만듭니다.\", \"score\": 9.0, \"recommendations\": [\"표준적인 Python 패키징 및 임포트 방식을 계속 따르세요.\", \"불필요하거나 중복되는 코드를 정기적으로 검토하고 제거하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 364}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\\n\\\\n    이 클래스는 리뷰 응답을 마크다운, HTML 등 다양한 출력 형식으로 변환하는 기능을 제공합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def format(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info {  }\\\\\\\",\\\\n            \\\\\\\".warning {  }\\\\\\\",\\\\n            \\\\\\\".error {  }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info {  }\\\\\\\",\\\\n            \\\\\\\".warning {  }\\\\\\\",\\\\n            \\\\\\\".error {  }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 109}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 109, \"file\": \"reviewer/src/utils/review_formatter.py\", \"description\": \"HTML 보고서에서 이슈 심각도(info, warning, error) 및 권장사항 섹션에 대한 주요 시각적 스타일(배경색, 테두리 색상)이 제거되었습니다. 이전에는 각 심각도에 따라 다른 색상의 왼쪽 테두리가 있었고, 이슈 및 권장사항 섹션에는 배경색이 적용되어 가독성을 높였습니다. 이러한 스타일 제거로 인해 사용자가 이슈의 중요도를 한눈에 파악하거나 특정 섹션을 구분하기 어려워졌습니다.\", \"suggestion\": \"HTML 보고서의 가독성 향상을 위해 제거된 스타일(`.issue`의 배경색 및 왼쪽 테두리, `.info`, `.warning`, `.error`의 `border-left-color`, `.recommendations`의 배경색)을 복원하는 것을 권장합니다. 이를 통해 사용자가 정보를 더 쉽게 식별하고 이해할 수 있습니다. 원래 스타일로 되돌리면 시각적 명확성이 향상됩니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n            \\\"<style>\\\",\\n            \\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\",\\n            \\\"h1 { color: #333; }\\\",\\n            \\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\",\\n            \\\"h3 { color: #555; }\\\",\\n            \\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\",\\n            \\\".info { border-left-color: #2196F3; }\\\",\\n            \\\".warning { border-left-color: #FF9800; }\\\",\\n            \\\".error { border-left-color: #F44336; }\\\",\\n            \\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\",\\n            \\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\",\\n            \\\"</style>\\\",\\n            \\\"<style>\\\",\\n            \\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\",\\n            \\\"code { font-family: 'Courier New', Courier, monospace; }\\\",\\n            \\\"</style>\\\",\\n```\", \"improved_code\": \"```python\\n            \\\"<style>\\\",\\n            \\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\",\\n            \\\"h1 { color: #333; }\\\",\\n            \\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\",\\n            \\\"h3 { color: #555; }\\\",\\n            \\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\", // 스타일 복원\\n            \\\".info { border-left-color: #2196F3; }\\\", // 스타일 복원\\n            \\\".warning { border-left-color: #FF9800; }\\\", // 스타일 복원\\n            \\\".error { border-left-color: #F44336; }\\\", // 스타일 복원\\n            \\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\",\\n            \\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\", // 스타일 복원\\n            \\\"</style>\\\",\\n            \\\"<style>\\\",\\n            \\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\",\\n            \\\"code { font-family: 'Courier New', Courier, monospace; }\\\",\\n            \\\"</style>\\\",\\n```\"}, {\"type\": \"설계\", \"line_number\": 364, \"file\": \"reviewer/src/ui.py\", \"description\": \"`display_review_result` 함수에서 리뷰 결과를 기존 HTML(`st.html`) 방식 대신 마크다운(`st.markdown`)으로 표시하도록 변경되었습니다. 이 변경은 `ReviewFormatter.to_markdown` 메서드를 사용하며, 결과적으로 UI에 표시되는 리뷰 내용의 형식이 변경됩니다.\", \"suggestion\": \"마크다운으로의 변경은 일반적으로 내용을 더 간결하게 표시할 수 있지만, HTML이 제공하던 세밀한 스타일링이나 복잡한 구조 표현에는 한계가 있을 수 있습니다. 이 변경이 의도된 기능 개선의 일부이고 마크다운으로 충분한 정보 전달 및 가독성이 확보된다면 문제가 없습니다. 다만, 이전에 HTML 렌더링을 통해 제공되던 특정 시각적 이점(예: `review_formatter.py`에서 변경된 스타일링과 연관된 부분)이 중요했다면, 해당 기능이 의도치 않게 손실될 수 있으므로 검토가 필요합니다. 변경의 영향 범위를 고려하고, 사용자 경험에 부정적인 영향이 없는지 확인하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        return\\n\\n    try:\\n        review_response = ReviewResponse.model_validate(json_data[\\\"review_response\\\"])\\n        formatter = ReviewFormatter()\\n        html_content = formatter.to_html(review_response)\\n        st.html(html_content)\\n    except Exception as e:\\n        st.error(f\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\")\\n        st.json(json_data[\\\"review_response\\\"], expanded=False)\\n\\n\\n```\", \"improved_code\": \"```python\\n        return\\n\\n    try:\\n        review_response = ReviewResponse.model_validate(json_data[\\\"review_response\\\"])\\n        formatter = ReviewFormatter()\\n        html_content = formatter.to_markdown(review_response)\\n        st.markdown(html_content)\\n    except Exception as e:\\n        st.error(f\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\")\\n        st.json(json_data[\\\"review_response\\\"], expanded=False)\\n\\n\\n```\"}], \"summary\": \"코드 변경 사항은 주로 두 가지입니다: 1) `reviewer/src/ui.py`에서 리뷰 결과를 표시하는 방식이 HTML에서 마크다운으로 변경되었습니다. 2) `reviewer/src/utils/review_formatter.py`에서 HTML 형식으로 변환 시 적용되던 일부 CSS 스타일(이슈 심각도별 색상 구분, 섹션 배경색 등)이 제거되어 HTML 출력물의 시각적 표현이 단순화되었습니다. 전반적으로 UI 표시 방식 변경과 그에 따른 포맷터의 HTML 스타일 조정이 이루어졌습니다.\", \"score\": 7.0, \"recommendations\": [\"HTML 보고서 스타일 복원 또는 개선: `review_formatter.py`에서 제거된 HTML 스타일(특히 이슈 심각도별 시각적 구분 및 섹션 배경색)을 복원하거나, 마크다운 출력에서도 유사한 시각적 단서를 제공할 방법을 고려하여 사용자 가독성을 높이는 것이 좋습니다.\", \"UI 변경 영향 검토: `ui.py`에서 리뷰 결과 표시 방식을 HTML에서 마크다운으로 변경한 것의 영향을 종합적으로 검토하세요. 마크다운이 모든 경우에 충분한 표현력을 제공하는지, 기존 HTML 방식이 제공하던 장점 중 유지할 필요가 있는 것은 없는지 확인이 필요합니다.\", \"일관성 있는 사용자 경험 제공: 만약 HTML 출력이 여전히 지원되는 기능이라면, 스타일 단순화로 인해 정보 전달력이 저하되지 않도록 주의해야 합니다. 마크다운과 HTML 출력 간의 사용자 경험 일관성도 고려할 필요가 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n```\\\", \\\"line_number\\\": 9}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 178}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 437}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n```\\\", \\\"line_number\\\": 475}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n```\\\", \\\"line_number\\\": 493}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n\\\\n                    if show_raw_json:\\\\n                        st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n                        data_to_display = copy.deepcopy(json_data)\\\\n                        target_keys_in_order = [\\\\n                            \\\\\\\"prompt\\\\\\\",\\\\n                            \\\\\\\"review_request\\\\\\\",\\\\n                            \\\\\\\"review_response\\\\\\\",\\\\n                        ]\\\\n\\\\n                        for key_to_expand in target_keys_in_order:\\\\n                            if key_to_expand in data_to_display:\\\\n                                value = data_to_display.pop(key_to_expand)\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                                ):\\\\n                                    if key_to_expand == \\\\\\\"prompt\\\\\\\" and isinstance(\\\\n                                        value, list\\\\n                                    ):\\\\n                                        parsed_prompt_list = []\\\\n                                        for p_item in value:\\\\n                                            p_item_copy = copy.deepcopy(p_item)\\\\n                                            if (\\\\n                                                isinstance(p_item_copy, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in p_item_copy\\\\n                                                and isinstance(\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"], str\\\\n                                                )\\\\n                                            ):\\\\n                                                try:\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        p_item_copy[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_list.append(p_item_copy)\\\\n                                        st.json(parsed_prompt_list, expanded=True)\\\\n                                    elif value:  # Check if value is not None or empty\\\\n                                        st.json(value, expanded=True)\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                        if data_to_display:\\\\n                            st.markdown(\\\\\\\"---\\\\\\\")\\\\n                            st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n                            st.json(json_data, expanded=False)\\\\n                    else:\\\\n                        if (\\\\n                            \\\\\\\"review_response\\\\\\\" in json_data\\\\n                            and json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        ):\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            st.markdown(html_content, unsafe_allow_html=True)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n                    target_keys_in_order = [\\\\n                        \\\\\\\"prompt\\\\\\\",\\\\n                        \\\\\\\"review_request\\\\\\\",\\\\n                        \\\\\\\"review_response\\\\\\\",\\\\n                    ]\\\\n\\\\n                    for key_to_expand in target_keys_in_order:\\\\n                        if key_to_expand in data_to_display:\\\\n                            value = data_to_display.pop(key_to_expand)\\\\n                            with st.expander(\\\\n                                f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                            ):\\\\n                                if key_to_expand == \\\\\\\"prompt\\\\\\\":\\\\n                                    parsed_prompt_content = []\\\\n                                    if isinstance(value, list):\\\\n                                        for item_prompt in value:\\\\n                                            item_c = copy.deepcopy(item_prompt)\\\\n                                            if (\\\\n                                                isinstance(item_c, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in item_c\\\\n                                                and isinstance(item_c[\\\\\\\"content\\\\\\\"], str)\\\\n                                            ):\\\\n                                                try:\\\\n                                                    item_c[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        item_c[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_content.append(item_c)\\\\n                                        st.json(parsed_prompt_content, expanded=True)\\\\n                                    else:\\\\n                                        st.json(value, expanded=True)  # Fallback\\\\n                                elif key_to_expand == \\\\\\\"review_response\\\\\\\":\\\\n                                    if value:\\\\n                                        try:\\\\n                                            review_response_obj = (\\\\n                                                ReviewResponse.model_validate(value)\\\\n                                            )\\\\n                                            formatter = ReviewFormatter()\\\\n                                            html_content = formatter.to_html(\\\\n                                                review_response_obj\\\\n                                            )\\\\n                                            st.markdown(\\\\n                                                html_content, unsafe_allow_html=True\\\\n                                            )\\\\n                                            with st.expander(\\\\n                                                f\\\\\\\"{key_to_expand} 원본 JSON 보기\\\\\\\",\\\\n                                                expanded=False,\\\\n                                            ):\\\\n                                                st.json(value, expanded=True)\\\\n                                        except Exception:\\\\n                                            st.json(\\\\n                                                value, expanded=True\\\\n                                            )  # Fallback to raw JSON\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n                                elif (\\\\n                                    value\\\\n                                ):  # For review_request and other potential future keys\\\\n                                    st.json(value, expanded=True)\\\\n                                else:\\\\n                                    st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                    if data_to_display:\\\\n                        st.markdown(\\\\\\\"---\\\\\\\")\\\\n                        st.markdown(\\\\\\\"### 기타 로그 정보\\\\\\\")\\\\n                        st.json(data_to_display, expanded=False)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 506}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 63, \"file\": \"reviewer/src/ui.py\", \"description\": \"`parse_date_from_filename` 함수 내에서 `datetime.strptime` 호출 시 발생하는 `ValueError`가 `pass`로 처리되어, 날짜 형식 파싱 실패가 조용히 무시됩니다. 이는 디버깅을 어렵게 만들고, 사용자가 파일명에 날짜가 있다고 예상했지만 프로그램이 이를 인지하지 못하는 상황을 초래할 수 있습니다.\", \"suggestion\": \"`ValueError` 발생 시 `None`을 반환하기 전에 경고 또는 디버그 로그를 남겨 문제를 인지할 수 있도록 하는 것이 좋습니다. 함수는 이미 여러 패턴을 시도하고 마지막에 `None`을 반환하므로, 로깅 추가가 주된 개선점입니다.\", \"severity\": \"info\", \"original_code\": \"            try:\\n                return datetime.strptime(f\\\"{parts[0]}_{parts[1]}\\\", \\\"%Y%m%d_%H%M%S\\\")\\n            except ValueError:\\n                pass\", \"improved_code\": \"            try:\\n                return datetime.strptime(f\\\"{parts[0]}_{parts[1]}\\\", \\\"%Y%m%d_%H%M%S\\\")\\n            except ValueError:\\n                logger.debug(f\\\"Failed to parse date from parts: {parts[0]}_{parts[1]} in YYYYMMDD_HHMMSS_... pattern\\\")\\n                pass\"}, {\"type\": \"스타일\", \"line_number\": 17, \"file\": \"reviewer/src/ui.py\", \"description\": \"`sys.path.append`를 사용하여 상대 경로 임포트를 처리하고 있습니다. 이는 간단한 스크립트에서는 작동하지만, 프로젝트가 커지거나 다른 환경으로 배포될 때 문제를 일으킬 수 있습니다. Python의 패키징 시스템을 활용하는 것이 더 견고한 방법입니다.\", \"suggestion\": \"프로젝트 루트에 `setup.py` 또는 `pyproject.toml`을 구성하고, `pip install -e .`와 같이 설치하여 모듈을 사용하거나, 실행 시 `PYTHONPATH` 환경 변수를 설정하거나, `python -m reviewer.src.ui`와 같이 모듈로 실행하는 방식을 고려해보세요. 이 경우 코드 변경 없이 실행 방식만 변경될 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\"..\\\")))\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\", \"improved_code\": \"# 프로젝트 구조 및 실행 방식 변경을 통해 sys.path.append 제거 권장\\n# 예: `python -m reviewer.src.ui` 로 실행 시 아래와 같이 직접 임포트 가능\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\"}, {\"type\": \"버그\", \"line_number\": 347, \"file\": \"reviewer/src/ui.py\", \"description\": \"`determine_file_format` 함수는 파일 확장자에 따라 \\\"html\\\" 형식을 반환할 수 있지만, `load_and_display_file_content` 함수에서는 \\\"json\\\"이 아닌 모든 파일 형식을 `st.text(content)`로 처리합니다. 이로 인해 이전 코드에서 지원했던 일반 HTML 파일의 렌더링 기능이 제거되었을 수 있습니다.\", \"suggestion\": \"만약 일반 HTML 파일(리뷰 결과 HTML이 아닌)을 계속해서 HTML로 렌더링해야 한다면, `load_and_display_file_content` 함수에 \\\"html\\\" 형식에 대한 처리 로직을 추가해야 합니다. `st.components.v1.html(content, height=600, scrolling=True)` 또는 `st.markdown(content, unsafe_allow_html=True)` (보안 위험 인지 필요) 사용을 고려할 수 있습니다. `st.html()`은 iframe을 사용하므로 더 안전한 선택입니다.\", \"severity\": \"warning\", \"original_code\": \"        if format == \\\"json\\\":\\n            # ... json handling ...\\n        else:\\n            # 텍스트 파일은 그대로 표시\\n            st.text(content)\", \"improved_code\": \"        if format == \\\"json\\\":\\n            # ... json handling ...\\n        elif format == \\\"html\\\":\\n            st.components.v1.html(content, height=600, scrolling=True) # iframe을 사용한 HTML 렌더링\\n        else: # txt, log 등 기타 텍스트 기반 파일\\n            st.text(content)\"}, {\"type\": \"스타일\", \"line_number\": 120, \"file\": \"reviewer/src/ui.py\", \"description\": \"`determine_file_format` 함수 내 확장자 없는 파일을 처리하는 `try-except Exception` 블록이 너무 광범위한 예외(bare `Exception`)를 잡고 있습니다. 이는 예상치 못한 다른 종류의 오류까지 숨길 수 있어 디버깅을 어렵게 만듭니다.\", \"suggestion\": \"가능한 특정 예외(예: `OSError`, `AttributeError` 등 예상되는 오류)를 명시적으로 잡거나, 최소한 로깅을 추가하여 어떤 종류의 예외가 발생했는지 알 수 있도록 하는 것이 좋습니다. 이를 통해 문제 발생 시 원인 파악이 용이해집니다.\", \"severity\": \"warning\", \"original_code\": \"        except Exception:\\n            return \\\"txt\\\"\", \"improved_code\": \"        except Exception as e:\\n            logger.warning(f\\\"Error determining file format for extensionless file {file_path}: {e}\\\", exc_info=True)\\n            return \\\"txt\\\"\"}], \"summary\": \"코드 변경은 Streamlit UI 애플리케이션의 대대적인 리팩토링을 포함합니다. 많은 내부 로직이 더 작고 관리하기 쉬운 헬퍼 함수로 분리되어 코드의 모듈성과 가독성이 향상되었습니다. 파일명에서 날짜 및 모델 이름을 추출하는 로직, 파일 형식을 결정하는 로직, 다양한 데이터 유형(JSON, 리뷰 결과, LLM 평가 결과)을 표시하는 로직이 개선되고 명확해졌습니다. 사용되지 않는 기능(예: 원시 로그, 개별 요청/프롬프트 파일 보기)이 제거되어 UI가 간소화되었습니다. 전반적으로 코드 품질과 유지보수성이 크게 향상되었습니다.\", \"score\": 8.5, \"recommendations\": [\"파싱 함수 내에서 조용히 넘어가는(pass) 예외 처리 부분에 로깅을 추가하여 디버깅 용이성을 높이세요.\", \"장기적인 유지보수성을 위해 `sys.path.append` 대신 Python 패키징 표준이나 `PYTHONPATH` 설정을 사용하는 것을 고려하세요.\", \"일반 HTML 파일 렌더링 기능이 의도적으로 제거된 것인지 확인하고, 필요하다면 관련 로직을 복원하거나 명확히 하세요.\", \"광범위한 `except Exception:` 사용 시 특정 예외를 명시하거나 로깅을 추가하여 오류 추적을 용이하게 하세요.\", \"큰 함수를 작은 단위로 분리하는 현재의 좋은 리팩토링 관행을 계속 유지하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 원본 JSON 데이터 보기 체크박스 추가\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n\\\\n                    if show_raw_json:\\\\n                        st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n                        data_to_display = copy.deepcopy(json_data)\\\\n                        target_keys_in_order = [\\\\n                            \\\\\\\"prompt\\\\\\\",\\\\n                            \\\\\\\"review_request\\\\\\\",\\\\n                            \\\\\\\"review_response\\\\\\\",\\\\n                        ]\\\\n\\\\n                        for key_to_expand in target_keys_in_order:\\\\n                            if key_to_expand in data_to_display:\\\\n                                value = data_to_display.pop(key_to_expand)\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                                ):\\\\n                                    if key_to_expand == \\\\\\\"prompt\\\\\\\" and isinstance(\\\\n                                        value, list\\\\n                                    ):\\\\n                                        parsed_prompt_list = []\\\\n                                        for p_item in value:\\\\n                                            p_item_copy = copy.deepcopy(p_item)\\\\n                                            if (\\\\n                                                isinstance(p_item_copy, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in p_item_copy\\\\n                                                and isinstance(\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"], str\\\\n                                                )\\\\n                                            ):\\\\n                                                try:\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        p_item_copy[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_list.append(p_item_copy)\\\\n                                        st.json(parsed_prompt_list, expanded=True)\\\\n                                    elif value:  # Check if value is not None or empty\\\\n                                        st.json(value, expanded=True)\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                        if data_to_display:\\\\n                            st.markdown(\\\\\\\"---\\\\\\\")\\\\n                            st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n                            st.json(json_data, expanded=False)\\\\n                    else:\\\\n                        if (\\\\n                            \\\\\\\"review_response\\\\\\\" in json_data\\\\n                            and json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        ):\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            # st.markdown(html_content, unsafe_allow_html=True)\\\\n                            st.html(html_content)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 20}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n```\\\", \\\"line_number\\\": 32}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n```\\\", \\\"line_number\\\": 45}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"line_number\\\": 188}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n```\\\", \\\"line_number\\\": 223}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 원본 JSON 데이터 보기 체크박스 추가\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n```\\\", \\\"line_number\\\": 290}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            st.markdown(html_content, unsafe_allow_html=True)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n                    target_keys_in_order = [\\\\n                        \\\\\\\"prompt\\\\\\\",\\\\n                        \\\\\\\"review_request\\\\\\\",\\\\n                        \\\\\\\"review_response\\\\\\\",\\\\n                    ]\\\\n\\\\n                    for key_to_expand in target_keys_in_order:\\\\n                        if key_to_expand in data_to_display:\\\\n                            value = data_to_display.pop(key_to_expand)\\\\n                            with st.expander(\\\\n                                f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                            ):\\\\n                                if key_to_expand == \\\\\\\"prompt\\\\\\\":\\\\n                                    parsed_prompt_content = []\\\\n                                    if isinstance(value, list):\\\\n                                        for item_prompt in value:\\\\n                                            item_c = copy.deepcopy(item_prompt)\\\\n                                            if (\\\\n                                                isinstance(item_c, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in item_c\\\\n                                                and isinstance(item_c[\\\\\\\"content\\\\\\\"], str)\\\\n                                            ):\\\\n                                                try:\\\\n                                                    item_c[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        item_c[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_content.append(item_c)\\\\n                                        st.json(parsed_prompt_content, expanded=True)\\\\n                                    else:\\\\n                                        st.json(value, expanded=True)  # Fallback\\\\n                                elif key_to_expand == \\\\\\\"review_response\\\\\\\":\\\\n                                    if value:\\\\n                                        try:\\\\n                                            review_response_obj = (\\\\n                                                ReviewResponse.model_validate(value)\\\\n                                            )\\\\n                                            formatter = ReviewFormatter()\\\\n                                            html_content = formatter.to_html(\\\\n                                                review_response_obj\\\\n                                            )\\\\n                                            st.markdown(\\\\n                                                html_content, unsafe_allow_html=True\\\\n                                            )\\\\n                                            with st.expander(\\\\n                                                f\\\\\\\"{key_to_expand} 원본 JSON 보기\\\\\\\",\\\\n                                                expanded=False,\\\\n                                            ):\\\\n                                                st.json(value, expanded=True)\\\\n                                        except Exception:\\\\n                                            st.json(\\\\n                                                value, expanded=True\\\\n                                            )  # Fallback to raw JSON\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n                                elif (\\\\n                                    value\\\\n                                ):  # For review_request and other potential future keys\\\\n                                    st.json(value, expanded=True)\\\\n                                else:\\\\n                                    st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                    if data_to_display:\\\\n                        st.markdown(\\\\\\\"---\\\\\\\")\\\\n                        st.markdown(\\\\\\\"### 기타 로그 정보\\\\\\\")\\\\n                        st.json(data_to_display, expanded=False)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            # st.markdown(html_content, unsafe_allow_html=True)\\\\n                            st.html(html_content)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n```\\\", \\\"line_number\\\": 352}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n```\\\", \\\"line_number\\\": 432}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 482}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 20, \"file\": \"reviewer/src/ui.py\", \"description\": \"불필요한 임포트가 제거되었습니다. 사용하지 않는 함수들(get_default_raw_log_dir, get_default_review_prompt_dir, get_default_review_request_dir)을 임포트하는 것은 불필요합니다.\", \"suggestion\": \"사용하지 않는 임포트는 제거하여 코드를 간결하게 유지하는 것이 좋습니다. 이 변경은 적절합니다.\", \"severity\": \"info\", \"original_code\": \"# 상대 경로 임포트를 위한 경로 설정\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\"..\\\")))\\nfrom reviewer.src.config import (\\n    get_default_raw_log_dir,\\n    get_default_results_dir,\\n    get_default_review_log_dir,\\n    get_default_review_prompt_dir,\\n    get_default_review_request_dir,\\n)\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\", \"improved_code\": \"# 상대 경로 임포트를 위한 경로 설정\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\"..\\\")))\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\"}, {\"type\": \"설계\", \"line_number\": 32, \"file\": \"reviewer/src/ui.py\", \"description\": \"사용하지 않는 함수들(get_default_merged_data_dir, get_result_files, get_log_files, get_review_request_files, get_review_prompt_files)이 제거되었습니다. 이 함수들은 더 이상 필요하지 않으므로 코드 간소화를 위해 제거되었습니다.\", \"suggestion\": \"사용하지 않는 함수는 제거하여 코드 베이스를 간결하게 유지하는 것이 좋습니다. 이 변경은 코드 유지보수성을 향상시킵니다.\", \"severity\": \"info\", \"original_code\": \"def get_default_merged_data_dir() -> Path:\\n    \\\"\\\"\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\"\\\"\\\"\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\n    if sys.platform == \\\"darwin\\\":  # macOS\\n        return (\\n            Path.home() / \\\"Library\\\" / \\\"Application Support\\\" / \\\"reviewer\\\" / \\\"merged_data\\\"\\n        )\\n    elif sys.platform == \\\"win32\\\":  # Windows\\n        return Path(os.getenv(\\\"APPDATA\\\", \\\"\\\")) / \\\"reviewer\\\" / \\\"merged_data\\\"\\n    else:  # Linux 등 기타\\n        return Path.home() / \\\".config\\\" / \\\"reviewer\\\" / \\\"merged_data\\\"\\n\\n\\ndef get_result_files() -> list[Path]:\\n    \\\"\\\"\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\"\\\"\\\"\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\n    logger.warning(\\n        \\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\"\\n    )\\n    return []\\n\\n\\ndef get_log_files() -> list[Path]:\\n    \\\"\\\"\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\"\\\"\\\"\\n    log_dir = get_default_raw_log_dir()\\n    if not log_dir.exists():\\n        return []\\n\\n    log_files = list(log_dir.glob(\\\"*.json\\\"))\\n    # 수정 시간 기준으로 정렬 (최신순)\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\n    return log_files\\n\\n\\ndef get_review_request_files() -> list[Path]:\\n    \\\"\\\"\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\"\\\"\\\"\\n    request_dir = get_default_review_request_dir()\\n    if not request_dir.exists():\\n        return []\\n\\n    request_files = list(request_dir.glob(\\\"*.json\\\"))\\n    # 수정 시간 기준으로 정렬 (최신순)\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\n    return request_files\\n\\n\\ndef get_review_prompt_files() -> list[Path]:\\n    \\\"\\\"\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\"\\\"\\\"\\n    prompt_dir = get_default_review_prompt_dir()\\n    if not prompt_dir.exists():\\n        return []\\n\\n    prompt_files = list(prompt_dir.glob(\\\"*.json\\\"))\\n    # 수정 시간 기준으로 정렬 (최신순)\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\n    return prompt_files\", \"improved_code\": \"# 불필요한 함수들이 제거되었습니다.\"}, {\"type\": \"설계\", \"line_number\": 45, \"file\": \"reviewer/src/ui.py\", \"description\": \"사용하지 않는 함수 get_merged_data_files()가 제거되었습니다. 이 함수는 더 이상 필요하지 않으므로 코드 간소화를 위해 제거되었습니다.\", \"suggestion\": \"사용하지 않는 함수는 제거하여 코드 베이스를 간결하게 유지하는 것이 좋습니다. 이 변경은 코드 유지보수성을 향상시킵니다.\", \"severity\": \"info\", \"original_code\": \"def get_merged_data_files() -> list[Path]:\\n    \\\"\\\"\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\"\\\"\\\"\\n    merged_data_dir = get_default_merged_data_dir()\\n    if not merged_data_dir.exists():\\n        return []\\n\\n    merged_files = list(merged_data_dir.glob(\\\"*.json\\\"))\\n    # 수정 시간 기준으로 정렬 (최신순)\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\n    return merged_files\", \"improved_code\": \"# 불필요한 함수가 제거되었습니다.\"}, {\"type\": \"설계\", \"line_number\": 188, \"file\": \"reviewer/src/ui.py\", \"description\": \"사용하지 않는 디렉토리 정보 표시 및 보기 유형 옵션이 제거되었습니다. 이제 필요한 디렉토리 정보만 표시하고, 보기 유형도 '리뷰 결과'와 'llm_eval 결과'만 남겨두었습니다.\", \"suggestion\": \"사용자 인터페이스를 간소화하여 필요한 기능만 제공하는 것이 좋습니다. 이 변경은 사용자 경험을 개선하고 인터페이스를 더 직관적으로 만듭니다.\", \"severity\": \"info\", \"original_code\": \"# 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\nresults_dir = get_default_results_dir()\\nlog_dir = get_default_raw_log_dir()\\nreview_log_dir = get_default_review_log_dir()\\nrequest_dir = get_default_review_request_dir()\\nprompt_dir = get_default_review_prompt_dir()\\nst.sidebar.markdown(f\\\"**결과 저장 위치**: {results_dir}\\\")\\nst.sidebar.markdown(f\\\"**로그 저장 위치**: {log_dir}\\\")\\nst.sidebar.markdown(f\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\")\\nst.sidebar.markdown(f\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\")\\nst.sidebar.markdown(f\\\"**프롬프트 저장 위치**: {prompt_dir}\\\")\\nst.sidebar.markdown(\\n    f\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\"\\n)\\n\\n# 결과/로그/리뷰요청/프롬프트 선택\\nview_type = st.sidebar.selectbox(\\n    \\\"보기 유형:\\\",\\n    [\\n        \\\"리뷰 결과\\\",\\n        \\\"응답 로그\\\",\\n        \\\"reviewRequest\\\",\\n        \\\"프롬프트\\\",\\n        \\\"review log\\\",\\n        \\\"llm_eval 결과\\\",\\n    ],\\n    index=0,\\n)\", \"improved_code\": \"# 결과 디렉토리 표시\\nresults_dir = get_default_results_dir()\\nreview_log_dir = get_default_review_log_dir()\\nst.sidebar.markdown(f\\\"**결과 저장 위치**: {results_dir}\\\")\\nst.sidebar.markdown(f\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\")\\nst.sidebar.markdown(\\n    f\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\"\\n)\\n\\n# 결과 선택\\nview_type = st.sidebar.selectbox(\\n    \\\"보기 유형:\\\",\\n    [\\n        \\\"리뷰 결과\\\",\\n        \\\"llm_eval 결과\\\",\\n    ],\\n    index=0,\\n)\"}, {\"type\": \"설계\", \"line_number\": 223, \"file\": \"reviewer/src/ui.py\", \"description\": \"사용하지 않는 보기 유형에 대한 조건문이 제거되었습니다. 이제 '리뷰 결과'와 'llm_eval 결과' 두 가지 유형만 처리합니다.\", \"suggestion\": \"사용하지 않는 조건문을 제거하여 코드를 간결하게 유지하는 것이 좋습니다. 이 변경은 코드 가독성과 유지보수성을 향상시킵니다.\", \"severity\": \"info\", \"original_code\": \"elif view_type == \\\"응답 로그\\\":\\n    files = get_log_files()\\n    if not files:\\n        st.info(\\\"저장된 응답 로그가 없습니다.\\\")\\n        return\\nelif view_type == \\\"reviewRequest\\\":\\n    files = get_review_request_files()\\n    if not files:\\n        st.info(\\\"저장된 리뷰 요청이 없습니다.\\\")\\n        return\\nelif view_type == \\\"프롬프트\\\":\\n    files = get_review_prompt_files()\\n    if not files:\\n        st.info(\\\"저장된 프롬프트가 없습니다.\\\")\\n        return\\nelif view_type == \\\"review log\\\":\\n    files = get_review_log_files()\\n    if not files:\\n        st.info(\\\"저장된 review log가 없습니다.\\\")\\n        return\\nelse:  # llm_eval 결과\", \"improved_code\": \"else:  # llm_eval 결과\"}, {\"type\": \"설계\", \"line_number\": 352, \"file\": \"reviewer/src/ui.py\", \"description\": \"사용하지 않는 보기 유형에 대한 처리 로직이 제거되었습니다. 또한 HTML 렌더링 방식이 변경되었습니다. st.markdown(html_content, unsafe_allow_html=True) 대신 st.html(html_content)를 사용하도록 변경되었습니다.\", \"suggestion\": \"Streamlit의 st.html() 함수를 사용하는 것이 unsafe_allow_html=True 옵션을 사용하는 것보다 더 안전하고 권장되는 방식입니다. 이 변경은 보안성을 향상시킵니다.\", \"severity\": \"warning\", \"original_code\": \"html_content = formatter.to_html(review_response)\\nst.markdown(html_content, unsafe_allow_html=True)\\nelse:\\n    st.warning(\\\"리뷰 응답 데이터가 없습니다.\\\")\\nelif view_type == \\\"응답 로그\\\":\\n    st.markdown(\\\"## 응답 로그 내용\\\")\\n    st.json(json_data, expanded=False)\\nelif view_type == \\\"reviewRequest\\\":\\n    st.markdown(\\\"## reviewRequest 내용\\\")\\n    st.json(json_data, expanded=False)\\nelif view_type == \\\"프롬프트\\\":\\n    st.markdown(\\\"## 프롬프트 내용\\\")\\n    if isinstance(json_data, list):\\n        for item in json_data:\\n            if (\\n                isinstance(item, dict)\\n                and \\\"content\\\" in item\\n                and isinstance(item[\\\"content\\\"], str)\\n            ):\\n                try:\\n                    item[\\\"content\\\"] = json.loads(item[\\\"content\\\"])\\n                except json.JSONDecodeError:\\n                    pass\\n    st.json(json_data, expanded=False)\\nelif view_type == \\\"review log\\\":\\n    st.markdown(\\\"## review log\\\")\\n    data_to_display = copy.deepcopy(json_data)\\n\\n    target_keys_in_order = [\\n        \\\"prompt\\\",\\n        \\\"review_request\\\",\\n        \\\"review_response\\\",\\n    ]\\n\\n    for key_to_expand in target_keys_in_order:\\n        if key_to_expand in data_to_display:\\n            value = data_to_display.pop(key_to_expand)\\n            with st.expander(\\n                f\\\"{key_to_expand} 내용 보기\\\", expanded=False\\n            ):\\n                if key_to_expand == \\\"prompt\\\":\\n                    parsed_prompt_content = []\\n                    if isinstance(value, list):\\n                        for item_prompt in value:\\n                            item_c = copy.deepcopy(item_prompt)\\n                            if (\\n                                isinstance(item_c, dict)\\n                                and \\\"content\\\" in item_c\\n                                and isinstance(item_c[\\\"content\\\"], str)\\n                            ):\\n                                try:\\n                                    item_c[\\\"content\\\"] = json.loads(\\n                                        item_c[\\\"content\\\"]\\n                                    )\\n                                except json.JSONDecodeError:\\n                                    pass\\n                            parsed_prompt_content.append(item_c)\\n                        st.json(parsed_prompt_content, expanded=True)\\n                    else:\\n                        st.json(value, expanded=True)  # Fallback\\n                elif key_to_expand == \\\"review_response\\\":\\n                    if value:\\n                        try:\\n                            review_response_obj = (\\n                                ReviewResponse.model_validate(value)\\n                            )\\n                            formatter = ReviewFormatter()\\n                            html_content = formatter.to_html(\\n                                review_response_obj\\n                            )\\n                            st.markdown(\\n                                html_content, unsafe_allow_html=True\\n                            )\\n                            with st.expander(\\n                                f\\\"{key_to_expand} 원본 JSON 보기\\\",\\n                                expanded=False,\\n                            ):\\n                                st.json(value, expanded=True)\\n                        except Exception:\\n                            st.json(\\n                                value, expanded=True\\n                            )  # Fallback to raw JSON\\n                    else:\\n                        st.write(\\\"내용 없음\\\")\\n                elif (\\n                    value\\n                ):  # For review_request and other potential future keys\\n                    st.json(value, expanded=True)\\n                else:\\n                    st.write(\\\"내용 없음\\\")\\n\\n    if data_to_display:\\n        st.markdown(\\\"---\\\")\\n        st.markdown(\\\"### 기타 로그 정보\\\")\\n        st.json(data_to_display, expanded=False)\", \"improved_code\": \"html_content = formatter.to_html(review_response)\\n# st.markdown(html_content, unsafe_allow_html=True)\\nst.html(html_content)\\nelse:\\n    st.warning(\\\"리뷰 응답 데이터가 없습니다.\\\")\"}, {\"type\": \"설계\", \"line_number\": 432, \"file\": \"reviewer/src/ui.py\", \"description\": \"불필요한 주석이 제거되었습니다. 코드 가독성을 향상시키기 위해 불필요한 설명이 제거되었습니다.\", \"suggestion\": \"불필요한 주석은 제거하여 코드를 간결하게 유지하는 것이 좋습니다. 이 변경은 코드 가독성을 향상시킵니다.\", \"severity\": \"info\", \"original_code\": \"count_caption_text = f\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\"\\nelse:\\n    # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\n    # 어차피 매번 json_data의 deepcopy로 시작함.\\n    count_caption_text = f\\\"(총 {num_total_cases}건)\\\"\", \"improved_code\": \"count_caption_text = f\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\"\\nelse:\\n    count_caption_text = f\\\"(총 {num_total_cases}건)\\\"\"}, {\"type\": \"설계\", \"line_number\": 482, \"file\": \"reviewer/src/ui.py\", \"description\": \"HTML 및 기타 형식 파일 처리 로직이 제거되었습니다. 이제 JSON 파일만 처리하도록 간소화되었습니다.\", \"suggestion\": \"사용하지 않는 파일 형식 처리 로직을 제거하여 코드를 간결하게 유지하는 것이 좋습니다. 이 변경은 코드 유지보수성을 향상시킵니다.\", \"severity\": \"info\", \"original_code\": \"# JSON 파싱 실패 시 일반 텍스트로 표시\\nst.text(content)\\nelif format == \\\"html\\\":\\n    # HTML은 iframe으로 표시\\n    # st.html(content, height=600, scrolling=True) # 이전 코드\\n    # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\n    html_content_with_style = f\\\"\\\"\\\"\\n    <div style=\\\"height: 600px; overflow-y: scroll;\\\">\\n        {content}\\n    </div>\\n    \\\"\\\"\\\"\\n    # st.html(html_content_with_style, height=610) # 이전 코드\\n    st.markdown(html_content_with_style, unsafe_allow_html=True)\\nelse:\\n    # 마크다운 또는 다른 형식은 마크다운으로 표시\\n    st.markdown(content, unsafe_allow_html=True)\", \"improved_code\": \"# JSON 파싱 실패 시 일반 텍스트로 표시\\nst.text(content)\"}, {\"type\": \"스타일\", \"line_number\": 290, \"file\": \"reviewer/src/ui.py\", \"description\": \"주석이 추가되어 코드의 목적을 명확히 설명하고 있습니다. '원본 JSON 데이터 보기 체크박스 추가'라는 주석이 추가되어 해당 코드 블록의 목적을 명확히 합니다.\", \"suggestion\": \"코드의 목적을 설명하는 주석을 추가하는 것은 코드 가독성을 향상시킵니다. 이 변경은 적절합니다.\", \"severity\": \"info\", \"original_code\": \"if view_type == \\\"리뷰 결과\\\":\\n    if \\\"show_raw_json\\\" not in st.session_state:\\n        st.session_state.show_raw_json = False\\n    show_raw_json = st.checkbox(\\n        \\\"원본 JSON 데이터 보기\\\", key=\\\"show_raw_json\\\"\\n    )\", \"improved_code\": \"if view_type == \\\"리뷰 결과\\\":\\n    # 원본 JSON 데이터 보기 체크박스 추가\\n    if \\\"show_raw_json\\\" not in st.session_state:\\n        st.session_state.show_raw_json = False\\n    show_raw_json = st.checkbox(\\n        \\\"원본 JSON 데이터 보기\\\", key=\\\"show_raw_json\\\"\\n    )\"}], \"summary\": \"이 코드 변경은 Streamlit을 사용한 웹 인터페이스 모듈(ui.py)을 간소화하고 최적화하는 작업입니다. 주요 변경 사항은 다음과 같습니다:\\n\\n1. 사용하지 않는 임포트와 함수들이 제거되었습니다.\\n2. 사용자 인터페이스가 간소화되어 '리뷰 결과'와 'llm_eval 결과' 두 가지 보기 유형만 제공합니다.\\n3. 불필요한 디렉토리 정보 표시가 제거되었습니다.\\n4. HTML 렌더링 방식이 st.markdown(unsafe_allow_html=True)에서 st.html()로 변경되어 보안성이 향상되었습니다.\\n5. 불필요한 주석과 코드가 제거되어 전반적인 코드 가독성과 유지보수성이 향상되었습니다.\\n\\n이러한 변경은 코드베이스를 더 간결하고 유지보수하기 쉽게 만들었으며, 사용자 인터페이스를 더 직관적으로 개선했습니다.\", \"score\": 8.5, \"recommendations\": [\"불필요한 코드와 기능을 제거하는 리팩토링을 계속 진행하여 코드베이스를 간결하게 유지하세요.\", \"st.markdown(unsafe_allow_html=True) 대신 st.html()과 같은 더 안전한 Streamlit API를 사용하는 방식을 다른 부분에도 적용하세요.\", \"주요 함수와 클래스에 더 자세한 docstring을 추가하여 코드 문서화를 개선하세요.\", \"get_file_info() 함수는 복잡한 파일명 파싱 로직을 포함하고 있으므로, 이를 더 작은 함수들로 분리하여 가독성과 유지보수성을 향상시키는 것을 고려하세요.\", \"파일 형식 감지 로직(get_file_info 함수 내)이 복잡하므로, 이를 별도의 함수로 분리하거나 단순화하는 것을 고려하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_model_info, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (사용되지 않음, 하위 호환성을 위해 유지됨)\\\\\\\",\\\\n        deprecated=True,\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\nclass ReviewStatus(Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 상태를 나타내는 열거형 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    SUCCESS = \\\\\\\"SUCCESS\\\\\\\"\\\\n    FAILED = \\\\\\\"FAILED\\\\\\\"\\\\n\\\\n\\\\ndef save_review_log(\\\\n    prompt: ReviewPrompt | ReviewPromptWithFileContent | None,\\\\n    review_request: ReviewRequest,\\\\n    review_response: ReviewResponse | None,\\\\n    status: ReviewStatus,\\\\n    error: Exception | None = None,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    now = datetime.now()\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n        \\\\\\\"prompt\\\\\\\": prompt_data,\\\\n        \\\\\\\"review_request\\\\\\\": review_request.model_dump(mode=\\\\\\\"json\\\\\\\"),\\\\n        \\\\\\\"review_response\\\\\\\": response_data,\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    formatted = now.strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    file_name = f\\\\\\\"{formatted}_{model_name}_review_log\\\\\\\"\\\\n    file_path = log_dir / f\\\\\\\"{file_name}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    try:\\\\n        # 리뷰 요청 생성\\\\n        review_request = ReviewRequest(\\\\n            diff_content=diff_content,\\\\n            processed_diff=diff_result,\\\\n            file_paths=[file.filename for file in diff_result.files],\\\\n            use_full_context=use_full_context,\\\\n            model=args.model,\\\\n            repo_path=repo_path,\\\\n        )\\\\n\\\\n        # 리뷰 요청 저장\\\\n        save_review_request(review_request)\\\\n\\\\n        # LLM 게이트웨이 가져오기\\\\n        llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n        # 코드 리뷰 수행\\\\n        logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n        review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n        review_response = llm_gateway.review_code(review_prompt)\\\\n        save_review_log(\\\\n            review_prompt, review_request, review_response, ReviewStatus.SUCCESS\\\\n        )\\\\n\\\\n        logger.info(\\\\\\\"코드 리뷰가 완료되었습니다. 리뷰 로그가 저장되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"코드 리뷰 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        save_review_log(\\\\n            review_prompt,\\\\n            review_request,\\\\n            None,\\\\n            ReviewStatus.FAILED,\\\\n            error=e,\\\\n        )\\\\n        return\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    now = datetime.now()\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n```\\\", \\\"line_number\\\": 512}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    file_path = log_dir / f\\\\\\\"{log_id}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    formatted = now.strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    file_name = f\\\\\\\"{formatted}_{model_name}_review_log\\\\\\\"\\\\n    file_path = log_dir / f\\\\\\\"{file_name}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n```\\\", \\\"line_number\\\": 540}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 리뷰 로그에서 review_response 데이터 가져오기\\\\n                    if \\\\\\\"review_response\\\\\\\" in json_data and json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n                        # 딕셔너리를 ReviewResponse 객체로 변환\\\\n                        review_response = ReviewResponse.model_validate(\\\\n                            json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        )\\\\n\\\\n                        # ReviewFormatter를 사용하여 HTML로 변환\\\\n                        formatter = ReviewFormatter()\\\\n                        html_content = formatter.to_html(review_response)\\\\n\\\\n                        # HTML 내용을 Streamlit에 표시\\\\n                        html_content_with_style = html_content\\\\n                        st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n                    else:\\\\n                        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                        st.json(json_data)\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    # 프롬프트 데이터 (최상위가 리스트인 경우) 처리\\\\n                    # 각 항목의 'content'가 문자열화된 JSON이면 파싱\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**통합 JSON 저장 위치**: {get_default_merged_data_dir()}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"line_number\\\": 276}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"통합 JSON\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"line_number\\\": 288}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n        files = get_merged_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 통합 JSON 데이터가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 325}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n```\\\", \\\"line_number\\\": 349}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 통합 JSON 내용\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"line_number\\\": 438}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 512, \"file\": \"reviewer/cli.py\", \"description\": \"코드 순서가 논리적 흐름에 맞지 않습니다. 프롬프트와 응답 직렬화 코드가 로그 ID 생성 코드보다 먼저 위치하고 있어 가독성이 떨어집니다. 관련 코드 블록은 함께 그룹화하는 것이 좋습니다.\", \"suggestion\": \"관련 코드 블록을 함께 그룹화하여 논리적 흐름을 개선하세요. 모델 정보와 로그 디렉토리 설정 후, 시간 정보와 ID 생성, 그 다음 직렬화 작업 순으로 배치하는 것이 자연스러운 흐름입니다.\", \"severity\": \"info\", \"original_code\": \"    \\\"\\\"\\\"리뷰 로그를 저장합니다.\\\"\\\"\\\"\\n    model_info = get_model_info(review_request.model)\\n    log_dir = get_default_review_log_dir()\\n    log_dir.mkdir(parents=True, exist_ok=True)\\n\\n    # 프롬프트 직렬화\\n    prompt_data = None\\n    if prompt:\\n        prompt_data = prompt.to_messages()\\n\\n    # 응답 직렬화\\n    response_data = None\\n    if review_response:\\n        response_data = review_response.model_dump(mode=\\\"json\\\")\\n\\n    now = datetime.now()\\n    provider = model_info.get(\\\"provider\\\", \\\"unknown\\\")\\n    model_name = model_info.get(\\\"full_name\\\", review_request.model)\\n    log_id = f\\\"{provider}-{model_name}-{int(now.timestamp())}\\\"\", \"improved_code\": \"    \\\"\\\"\\\"리뷰 로그를 저장합니다.\\\"\\\"\\\"\\n    model_info = get_model_info(review_request.model)\\n    log_dir = get_default_review_log_dir()\\n    log_dir.mkdir(parents=True, exist_ok=True)\\n\\n    # 시간 정보와 ID 생성\\n    now = datetime.now()\\n    provider = model_info.get(\\\"provider\\\", \\\"unknown\\\")\\n    model_name = model_info.get(\\\"full_name\\\", review_request.model)\\n    log_id = f\\\"{provider}-{model_name}-{int(now.timestamp())}\\\"\\n    \\n    # 프롬프트 직렬화\\n    prompt_data = None\\n    if prompt:\\n        prompt_data = prompt.to_messages()\\n\\n    # 응답 직렬화\\n    response_data = None\\n    if review_response:\\n        response_data = review_response.model_dump(mode=\\\"json\\\")\"}, {\"type\": \"설계\", \"line_number\": 540, \"file\": \"reviewer/cli.py\", \"description\": \"파일 이름 생성 방식이 변경되었습니다. 기존에는 log_id를 파일명으로 사용했으나, 새로운 코드에서는 날짜와 모델명을 조합한 형식을 사용합니다. 이 변경은 좋은 개선이지만, 기존 log_id 변수가 여전히 생성되고 있어 불필요한 코드가 남아있습니다.\", \"suggestion\": \"log_id 변수가 파일명 생성에 더 이상 사용되지 않으므로, 파일명 생성 로직을 명확히 하고 불필요한 변수 생성을 제거하거나 주석을 추가하여 log_id의 용도를 명확히 하세요.\", \"severity\": \"warning\", \"original_code\": \"    # 파일 저장\\n    formatted = now.strftime(\\\"%Y%m%d_%H%M%S\\\")\\n    file_name = f\\\"{formatted}_{model_name}_review_log\\\"\\n    file_path = log_dir / f\\\"{file_name}.json\\\"\\n    with open(file_path, \\\"w\\\", encoding=\\\"utf-8\\\") as f:\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\", \"improved_code\": \"    # log_id는 로그 내용의 고유 식별자로만 사용하고, 파일명은 날짜 기반으로 생성\\n    formatted = now.strftime(\\\"%Y%m%d_%H%M%S\\\")\\n    file_name = f\\\"{formatted}_{model_name}_review_log\\\"\\n    file_path = log_dir / f\\\"{file_name}.json\\\"\\n    with open(file_path, \\\"w\\\", encoding=\\\"utf-8\\\") as f:\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\"}, {\"type\": \"설계\", \"line_number\": 276, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 사이드바에서 '통합 JSON 저장 위치' 항목이 제거되었습니다. 이는 관련 기능이 제거되었거나 변경되었을 가능성이 있습니다. 그러나 get_default_merged_data_dir() 함수는 여전히 코드에 남아있어 일관성이 없습니다.\", \"suggestion\": \"관련 기능이 제거되었다면 get_default_merged_data_dir() 함수와 get_merged_data_files() 함수도 함께 제거하거나, 해당 기능이 여전히 필요하다면 UI에 다시 추가하세요. 코드의 일관성을 유지하는 것이 중요합니다.\", \"severity\": \"warning\", \"original_code\": \"    st.sidebar.markdown(f\\\"**결과 저장 위치**: {results_dir}\\\")\\n    st.sidebar.markdown(f\\\"**로그 저장 위치**: {log_dir}\\\")\\n    st.sidebar.markdown(f\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\")\\n    st.sidebar.markdown(f\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\")\\n    st.sidebar.markdown(f\\\"**프롬프트 저장 위치**: {prompt_dir}\\\")\\n    st.sidebar.markdown(\\n        f\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\"\\n    )\", \"improved_code\": \"    st.sidebar.markdown(f\\\"**결과 저장 위치**: {results_dir}\\\")\\n    st.sidebar.markdown(f\\\"**로그 저장 위치**: {log_dir}\\\")\\n    st.sidebar.markdown(f\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\")\\n    st.sidebar.markdown(f\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\")\\n    st.sidebar.markdown(f\\\"**프롬프트 저장 위치**: {prompt_dir}\\\")\\n    st.sidebar.markdown(f\\\"**통합 JSON 저장 위치**: {get_default_merged_data_dir()}\\\")\\n    st.sidebar.markdown(\\n        f\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\"\\n    )\"}, {\"type\": \"설계\", \"line_number\": 288, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI의 보기 유형 선택 옵션에서 '통합 JSON'이 '리뷰 로그(review log)'로 변경되었습니다. 이는 기능 변경을 의미하지만, 관련 함수 이름(get_merged_data_files)과 일치하지 않아 혼란을 줄 수 있습니다.\", \"suggestion\": \"기능 이름과 함수 이름을 일관되게 유지하세요. '통합 JSON'에서 '리뷰 로그'로 변경했다면, 관련 함수명도 get_merged_data_files()에서 get_review_log_files()로 변경하거나, 아니면 UI 레이블을 함수명과 일치하도록 조정하세요.\", \"severity\": \"warning\", \"original_code\": \"        [\\n            \\\"리뷰 결과\\\",\\n            \\\"응답 로그\\\",\\n            \\\"reviewRequest\\\",\\n            \\\"프롬프트\\\",\\n            \\\"review log\\\",\\n            \\\"llm_eval 결과\\\",\\n        ],\\n        index=0,\", \"improved_code\": \"        [\\n            \\\"리뷰 결과\\\",\\n            \\\"응답 로그\\\",\\n            \\\"reviewRequest\\\",\\n            \\\"프롬프트\\\",\\n            \\\"통합 JSON\\\",\\n            \\\"llm_eval 결과\\\",\\n        ],\\n        index=0,\"}, {\"type\": \"설계\", \"line_number\": 325, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI의 보기 유형 처리 로직에서 '통합 JSON'이 '리뷰 로그(review log)'로 변경되었지만, 실제로는 get_review_log_files() 함수를 호출하고 있습니다. 이는 '리뷰 결과'와 '리뷰 로그'가 동일한 함수를 사용하게 되어 중복이 발생합니다.\", \"suggestion\": \"기능 중복을 피하고 명확한 구분을 위해, '리뷰 결과'와 '리뷰 로그'가 다른 데이터를 표시한다면 각각 다른 함수를 사용하도록 수정하세요. 만약 동일한 데이터를 표시한다면 UI 옵션을 통합하는 것이 좋습니다.\", \"severity\": \"warning\", \"original_code\": \"    elif view_type == \\\"프롬프트\\\":\\n        files = get_review_prompt_files()\\n        if not files:\\n            st.info(\\\"저장된 프롬프트가 없습니다.\\\")\\n            return\\n    elif view_type == \\\"review log\\\":\\n        files = get_review_log_files()\\n        if not files:\\n            st.info(\\\"저장된 review log가 없습니다.\\\")\\n            return\\n    else:  # llm_eval 결과\\n        files = get_llm_eval_data_files()\\n        if not files:\\n            st.info(\\\"저장된 llm_eval 결과가 없습니다.\\\")\", \"improved_code\": \"    elif view_type == \\\"프롬프트\\\":\\n        files = get_review_prompt_files()\\n        if not files:\\n            st.info(\\\"저장된 프롬프트가 없습니다.\\\")\\n            return\\n    elif view_type == \\\"통합 JSON\\\":\\n        files = get_merged_data_files()\\n        if not files:\\n            st.info(\\\"저장된 통합 JSON 데이터가 없습니다.\\\")\\n            return\\n    else:  # llm_eval 결과\\n        files = get_llm_eval_data_files()\\n        if not files:\\n            st.info(\\\"저장된 llm_eval 결과가 없습니다.\\\")\"}, {\"type\": \"설계\", \"line_number\": 349, \"file\": \"reviewer/src/ui.py\", \"description\": \"파일 정렬 로직이 mtime(수정 시간)에서 date(파일 정보에서 추출한 날짜)로 변경되었습니다. 이는 파일명에서 추출한 날짜를 우선시하는 좋은 변경이지만, 일부 파일에서 날짜 추출에 실패할 경우 일관성 없는 정렬 결과가 발생할 수 있습니다.\", \"suggestion\": \"date 필드가 없거나 유효하지 않은 경우 mtime을 대체값으로 사용하는 안전장치를 추가하세요. 이렇게 하면 모든 파일이 일관되게 정렬됩니다.\", \"severity\": \"info\", \"original_code\": \"    # 정렬 적용\\n    if sort_option == \\\"최신순\\\":\\n        file_infos.sort(key=lambda x: x[\\\"date\\\"], reverse=True)\\n    elif sort_option == \\\"오래된순\\\":\\n        file_infos.sort(key=lambda x: x[\\\"date\\\"])\\n    elif sort_option == \\\"파일명\\\":\\n        file_infos.sort(key=lambda x: x[\\\"name\\\"])\\n    elif sort_option == \\\"모델명\\\":\\n        file_infos.sort(key=lambda x: x[\\\"model\\\"])\", \"improved_code\": \"    # 정렬 적용\\n    if sort_option == \\\"최신순\\\":\\n        file_infos.sort(key=lambda x: x.get(\\\"date\\\", x.get(\\\"mtime\\\")), reverse=True)\\n    elif sort_option == \\\"오래된순\\\":\\n        file_infos.sort(key=lambda x: x.get(\\\"date\\\", x.get(\\\"mtime\\\")))\\n    elif sort_option == \\\"파일명\\\":\\n        file_infos.sort(key=lambda x: x[\\\"name\\\"])\\n    elif sort_option == \\\"모델명\\\":\\n        file_infos.sort(key=lambda x: x[\\\"model\\\"])\"}, {\"type\": \"설계\", \"line_number\": 438, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI의 JSON 데이터 표시 로직에서 '통합 JSON'이 '리뷰 로그(review log)'로 변경되었지만, 처리 로직은 동일합니다. 이는 기능 이름만 변경되고 실제 기능은 동일하게 유지되었음을 의미합니다.\", \"suggestion\": \"기능 이름 변경이 의도적이라면 관련 함수명과 변수명도 일관되게 변경하세요. 예를 들어 get_merged_data_files()를 get_review_log_files()로 변경하고, 관련 디렉토리 함수도 일관되게 수정하세요.\", \"severity\": \"info\", \"original_code\": \"                elif view_type == \\\"review log\\\":\\n                    st.markdown(\\\"## review log\\\")\\n                    if \\\"prompt\\\" in json_data and isinstance(json_data[\\\"prompt\\\"], list):\\n                        for i, item in enumerate(json_data[\\\"prompt\\\"]):\\n                            if \\\"content\\\" in item and isinstance(item[\\\"content\\\"], str):\\n                                try:\\n                                    item[\\\"content\\\"] = json.loads(item[\\\"content\\\"])\", \"improved_code\": \"                elif view_type == \\\"통합 JSON\\\":\\n                    st.markdown(\\\"## 통합 JSON 내용\\\")\\n                    if \\\"prompt\\\" in json_data and isinstance(json_data[\\\"prompt\\\"], list):\\n                        for i, item in enumerate(json_data[\\\"prompt\\\"]):\\n                            if \\\"content\\\" in item and isinstance(item[\\\"content\\\"], str):\\n                                try:\\n                                    item[\\\"content\\\"] = json.loads(item[\\\"content\\\"])\"}], \"summary\": \"이 코드 변경은 주로 리뷰 로그 저장 방식과 UI 표시 방식에 관련된 수정을 포함하고 있습니다. \\n\\nreviewer/cli.py 파일에서는 리뷰 로그 저장 함수의 코드 구조가 변경되었습니다. 프롬프트와 응답 직렬화 코드의 위치가 변경되었고, 파일 저장 방식이 log_id 기반에서 날짜와 모델명을 조합한 형식으로 변경되었습니다. 이는 파일명을 더 직관적으로 만들어 관리하기 쉽게 하는 개선입니다.\\n\\nreviewer/src/ui.py 파일에서는 UI 관련 변경이 있었습니다. '통합 JSON' 옵션이 '리뷰 로그(review log)'로 이름이 변경되었고, 파일 정렬 로직이 mtime에서 date 기반으로 변경되었습니다. 그러나 이 변경 과정에서 일부 일관성 문제가 발생했습니다. 특히 함수명과 UI 레이블 간의 불일치, 그리고 '리뷰 결과'와 '리뷰 로그' 옵션이 동일한 함수를 사용하는 중복 문제가 있습니다.\\n\\n전반적으로 코드 변경은 사용자 경험을 개선하고 파일 관리를 더 직관적으로 만드는 방향으로 이루어졌지만, 일부 설계 일관성 문제가 있습니다.\", \"score\": 7.5, \"recommendations\": [\"코드 구조를 논리적 흐름에 맞게 재배치하여 가독성을 높이세요. 특히 reviewer/cli.py의 save_review_log 함수에서 관련 코드 블록을 함께 그룹화하는 것이 좋습니다.\", \"변수와 함수의 용도를 명확히 하는 주석을 추가하세요. 특히 log_id와 같이 생성되지만 이전과 다른 용도로 사용되는 변수에 대한 설명이 필요합니다.\", \"UI 레이블과 함수명 간의 일관성을 유지하세요. '통합 JSON'에서 '리뷰 로그'로 변경했다면 관련 함수명도 일관되게 변경해야 합니다.\", \"중복 기능을 제거하거나 명확히 구분하세요. '리뷰 결과'와 '리뷰 로그'가 동일한 함수를 사용한다면 UI 옵션을 통합하거나, 다른 데이터를 표시한다면 각각 다른 함수를 사용해야 합니다.\", \"사용하지 않는 코드는 제거하세요. get_default_merged_data_dir()와 같이 UI에서 제거된 기능과 관련된 함수는 함께 제거하거나 다시 활성화해야 합니다.\", \"파일 정렬 로직에 안전장치를 추가하세요. date 필드가 없거나 유효하지 않은 경우 mtime을 대체값으로 사용하는 방식으로 일관된 정렬을 보장해야 합니다.\", \"코드 변경 시 관련된 모든 부분을 일관되게 수정하세요. 한 부분만 변경하고 다른 부분은 그대로 두면 혼란과 버그의 원인이 됩니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_model_info, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (사용되지 않음, 하위 호환성을 위해 유지됨)\\\\\\\",\\\\n        deprecated=True,\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\nclass ReviewStatus(Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 상태를 나타내는 열거형 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    SUCCESS = \\\\\\\"SUCCESS\\\\\\\"\\\\n    FAILED = \\\\\\\"FAILED\\\\\\\"\\\\n\\\\n\\\\ndef save_review_log(\\\\n    prompt: ReviewPrompt | ReviewPromptWithFileContent | None,\\\\n    review_request: ReviewRequest,\\\\n    review_response: ReviewResponse | None,\\\\n    status: ReviewStatus,\\\\n    error: Exception | None = None,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    now = datetime.now()\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n        \\\\\\\"prompt\\\\\\\": prompt_data,\\\\n        \\\\\\\"review_request\\\\\\\": review_request.model_dump(mode=\\\\\\\"json\\\\\\\"),\\\\n        \\\\\\\"review_response\\\\\\\": response_data,\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    formatted = now.strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    file_name = f\\\\\\\"{formatted}-{model_name}_review_log\\\\\\\"\\\\n    file_path = log_dir / f\\\\\\\"{file_name}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    try:\\\\n        # 리뷰 요청 생성\\\\n        review_request = ReviewRequest(\\\\n            diff_content=diff_content,\\\\n            processed_diff=diff_result,\\\\n            file_paths=[file.filename for file in diff_result.files],\\\\n            use_full_context=use_full_context,\\\\n            model=args.model,\\\\n            repo_path=repo_path,\\\\n        )\\\\n\\\\n        # 리뷰 요청 저장\\\\n        save_review_request(review_request)\\\\n\\\\n        # LLM 게이트웨이 가져오기\\\\n        llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n        # 코드 리뷰 수행\\\\n        logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n        review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n        review_response = llm_gateway.review_code(review_prompt)\\\\n        save_review_log(\\\\n            review_prompt, review_request, review_response, ReviewStatus.SUCCESS\\\\n        )\\\\n\\\\n        logger.info(\\\\\\\"코드 리뷰가 완료되었습니다. 리뷰 로그가 저장되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"코드 리뷰 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        save_review_log(\\\\n            review_prompt,\\\\n            review_request,\\\\n            None,\\\\n            ReviewStatus.FAILED,\\\\n            error=e,\\\\n        )\\\\n        return\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    now = datetime.now()\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n```\\\", \\\"line_number\\\": 512}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    file_path = log_dir / f\\\\\\\"{log_id}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    formatted = now.strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    file_name = f\\\\\\\"{formatted}-{model_name}_review_log\\\\\\\"\\\\n    file_path = log_dir / f\\\\\\\"{file_name}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n```\\\", \\\"line_number\\\": 540}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 리뷰 로그에서 review_response 데이터 가져오기\\\\n                    if \\\\\\\"review_response\\\\\\\" in json_data and json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n                        # 딕셔너리를 ReviewResponse 객체로 변환\\\\n                        review_response = ReviewResponse.model_validate(\\\\n                            json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        )\\\\n\\\\n                        # ReviewFormatter를 사용하여 HTML로 변환\\\\n                        formatter = ReviewFormatter()\\\\n                        html_content = formatter.to_html(review_response)\\\\n\\\\n                        # HTML 내용을 Streamlit에 표시\\\\n                        html_content_with_style = html_content\\\\n                        st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n                    else:\\\\n                        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                        st.json(json_data)\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    # 프롬프트 데이터 (최상위가 리스트인 경우) 처리\\\\n                    # 각 항목의 'content'가 문자열화된 JSON이면 파싱\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**통합 JSON 저장 위치**: {get_default_merged_data_dir()}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"line_number\\\": 276}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"통합 JSON\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"line_number\\\": 288}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n        files = get_merged_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 통합 JSON 데이터가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 325}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 통합 JSON 내용\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"line_number\\\": 438}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 288, \"file\": \"reviewer/src/ui.py\", \"description\": \"Streamlit UI에서 '리뷰 결과'와 'review log' 두 가지 보기 유형이 동일한 `get_review_log_files()` 함수를 사용하여 파일을 가져오고, 유사한 방식으로 내용을 표시합니다. 이는 사용자에게 혼란을 줄 수 있으며 코드 중복을 야기합니다.\", \"suggestion\": \"'리뷰 결과'와 'review log' 보기 유형을 '리뷰 로그' 또는 '코드 리뷰 결과'와 같이 하나의 명확한 이름으로 통합하고, 해당 로직을 단일 코드 블록으로 관리하여 중복을 제거하세요.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    view_type = st.sidebar.selectbox(\\n        \\\"보기 유형:\\\",\\n        [\\n            \\\"리뷰 결과\\\",\\n            \\\"응답 로그\\\",\\n            \\\"reviewRequest\\\",\\n            \\\"프롬프트\\\",\\n            \\\"통합 JSON\\\",\\n            \\\"llm_eval 결과\\\",\\n        ],\\n        index=0,\\n    )\\n\\n    # 파일 목록 가져오기\\n    if view_type == \\\"리뷰 결과\\\":\\n        files = get_review_log_files()\\n        if not files:\\n            st.info(\\\"저장된 리뷰 로그가 없습니다.\\\")\\n            st.markdown(\\\"\\\"\\\"\\n            ### 리뷰 생성 방법\\n            \\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\n            ```bash\\n            reviewer review\\n            ```\\n            \\n            자세한 사용법은 README.md 파일을 참조하세요.\\n            \\\"\\\"\\\")\\n            return\\n    elif view_type == \\\"응답 로그\\\":\\n        files = get_log_files()\\n        if not files:\\n            st.info(\\\"저장된 응답 로그가 없습니다.\\\")\\n            return\\n    elif view_type == \\\"reviewRequest\\\":\\n        files = get_review_request_files()\\n        if not files:\\n            st.info(\\\"저장된 리뷰 요청이 없습니다.\\\")\\n            return\\n    elif view_type == \\\"프롬프트\\\":\\n        files = get_review_prompt_files()\\n        if not files:\\n            st.info(\\\"저장된 프롬프트가 없습니다.\\\")\\n            return\\n    elif view_type == \\\"통합 JSON\\\":\\n        files = get_merged_data_files()\\n        if not files:\\n            st.info(\\\"저장된 통합 JSON 데이터가 없습니다.\\\")\\n            return\\n    else:  # llm_eval 결과\\n        files = get_llm_eval_data_files()\\n        if not files:\\n            st.info(\\\"저장된 llm_eval 결과가 없습니다.\\\")\\n```\", \"improved_code\": \"```python\\n    view_type = st.sidebar.selectbox(\\n        \\\"보기 유형:\\\",\\n        [\\n            \\\"리뷰 로그\\\", # '리뷰 결과'와 'review log' 통합\\n            \\\"응답 로그\\\",\\n            \\\"reviewRequest\\\",\\n            \\\"프롬프트\\\",\\n            \\\"llm_eval 결과\\\",\\n        ],\\n        index=0,\\n    )\\n\\n    # 파일 목록 가져오기\\n    if view_type == \\\"리뷰 로그\\\":\\n        files = get_review_log_files()\\n        if not files:\\n            st.info(\\\"저장된 리뷰 로그가 없습니다.\\\")\\n            st.markdown(\\\"\\\"\\\"\\n            ### 리뷰 생성 방법\\n            \\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\n            ```bash\\n            reviewer review\\n            ```\\n            \\n            자세한 사용법은 README.md 파일을 참조하세요.\\n            \\\"\\\"\\\")\\n            return\\n    elif view_type == \\\"응답 로그\\\":\\n        files = get_log_files()\\n        if not files:\\n            st.info(\\\"저장된 응답 로그가 없습니다.\\\")\\n            return\\n    elif view_type == \\\"reviewRequest\\\":\\n        files = get_review_request_files()\\n        if not files:\\n            st.info(\\\"저장된 리뷰 요청이 없습니다.\\\")\\n            return\\n    elif view_type == \\\"프롬프트\\\":\\n        files = get_review_prompt_files()\\n        if not files:\\n            st.info(\\\"저장된 프롬프트가 없습니다.\\\")\\n            return\\n    else:  # llm_eval 결과\\n        files = get_llm_eval_data_files()\\n        if not files:\\n            st.info(\\\"저장된 llm_eval 결과가 없습니다.\\\")\\n```\"}, {\"type\": \"스타일\", \"line_number\": 40, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI에서 '통합 JSON' 보기 유형이 제거되었지만, `get_default_merged_data_dir` 및 `get_merged_data_files` 함수는 코드에 남아 있습니다. 이는 사용되지 않는 데드 코드입니다.\", \"suggestion\": \"더 이상 사용되지 않는 `get_default_merged_data_dir` 및 `get_merged_data_files` 함수를 제거하여 코드를 정리하세요.\", \"severity\": \"info\", \"original_code\": \"```python\\ndef get_default_merged_data_dir() -> Path:\\n    \\\"\\\"\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\"\\\"\\\"\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\n    if sys.platform == \\\"darwin\\\":  # macOS\\n        return (\\n            Path.home() / \\\"Library\\\" / \\\"Application Support\\\" / \\\"reviewer\\\" / \\\"merged_data\\\"\\n        )\\n    elif sys.platform == \\\"win32\\\":  # Windows\\n        return Path(os.getenv(\\\"APPDATA\\\", \\\"\\\")) / \\\"reviewer\\\" / \\\"merged_data\\\"\\n    else:  # Linux 등 기타\\n        return Path.home() / \\\".config\\\" / \\\"reviewer\\\" / \\\"merged_data\\\"\\n\\n\\ndef get_result_files() -> list[Path]:\\n    \\\"\\\"\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\"\\\"\\\"\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\n    logger.warning(\\n        \\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\"\\n    )\\n    return []\\n\\n\\ndef get_log_files() -> list[Path]:\\n```\", \"improved_code\": \"```python\\n# get_default_merged_data_dir 함수 제거\\n# get_merged_data_files 함수 제거\\n\\ndef get_result_files() -> list[Path]:\\n    \\\"\\\"\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\"\\\"\\\"\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\n    logger.warning(\\n        \\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\"\\n    )\\n    return []\\n\\n\\ndef get_log_files() -> list[Path]:\\n```\"}, {\"type\": \"설계\", \"line_number\": 116, \"file\": \"reviewer/src/ui.py\", \"description\": \"`get_file_info` 함수는 파일명에서 날짜와 모델 이름을 파싱하기 위해 여러 가지 형식을 시도하는 복잡한 로직을 포함하고 있습니다. 이는 파일명 형식에 대한 의존성을 높이고 유지보수를 어렵게 만들 수 있습니다.\", \"suggestion\": \"애플리케이션 전체에서 로그 및 결과 파일의 파일명 형식을 표준화하고, `get_file_info` 함수는 표준화된 형식만 파싱하도록 단순화하거나, 파싱 실패 시 오류 처리를 명확히 하세요. `cli.py`에서 로그 파일명 형식을 개선한 것처럼, 다른 파일들도 일관된 규칙을 따르도록 합니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\ndef get_file_info(file: Path) -> dict[str, Any]:\\n    \\\"\\\"\\\"파일 정보를 가져옵니다.\\\"\\\"\\\"\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\n    size = file.stat().st_size\\n    size_str = f\\\"{size / 1024:.1f}KB\\\" if size >= 1024 else f\\\"{size}B\\\"\\n\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\n    model_name_candidate = \\\"\\\"\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\n\\n    try:\\n        parts = file.stem.split(\\\"_\\\")\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\n        if len(parts) >= 3:\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\n            if (\\n                parts[0].isdigit()\\n                and len(parts[0]) == 8\\n                and parts[1].isdigit()\\n                and len(parts[1]) == 6\\n            ):\\n                date_str = f\\\"{parts[0]}_{parts[1]}\\\"\\n                date_candidate = datetime.strptime(date_str, \\\"%Y%m%d_%H%M%S\\\")\\n                model_name_candidate = \\\"_\\\".join(parts[2:])\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\n            elif (\\n                parts[-2].isdigit()\\n                and len(parts[-2]) == 8\\n                and parts[-1].isdigit()\\n                and len(parts[-1]) == 6\\n            ):\\n                date_str = f\\\"{parts[-2]}_{parts[-1]}\\\"\\n                date_candidate = datetime.strptime(date_str, \\\"%Y%m%d_%H%M%S\\\")\\n                model_name_candidate = \\\"_\\\".join(parts[:-2])\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\n                model_name_candidate = parts[-1]\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\n                if (\\n                    len(parts) >= 3\\n                    and parts[-2].isdigit()\\n                    and len(parts[-2]) == 6\\n                    and parts[-3].isdigit()\\n                    and len(parts[-3]) == 8\\n                ):\\n                    date_str = f\\\"{parts[-3]}_{parts[-2]}\\\"\\n                    try:\\n                        date_candidate = datetime.strptime(date_str, \\\"%Y%m%d_%H%M%S\\\")\\n                    except ValueError:\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\n        elif (\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\n            model_name_candidate = file.stem\\n        elif (\\n            len(parts) == 1 and not parts[0].isdigit()\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\n            model_name_candidate = parts[0]\\n\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\n        pass  # model_name_candidate = \\\"\\\", date_candidate = mtime 유지\\n\\n    file_suffix = file.suffix.lstrip(\\\".\\\").lower()\\n\\n    # 확장자가 없는 파일 처리 로직\\n    if not file_suffix:\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\n        try:\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\n\\n            # 경로 비교를 위해 절대 경로로 변환\\n            file_parent_resolved = file.parent.resolve()\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\n\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\n            file_parent_str = str(file_parent_resolved)\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\n\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\n\\n            # 2. 날짜 형식의 파일명인지 확인\\n            has_date_format = (\\n                len(parts) >= 2\\n                and parts[0].isdigit()\\n                and len(parts[0]) == 8\\n                and parts[1].isdigit()\\n                and len(parts[1]) == 6\\n            )\\n\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\n            if is_in_llm_eval_dir:\\n                # deepeval 파일은 무조건 JSON으로 처리\\n                file_format = \\\"json\\\"\\n            elif has_date_format:\\n                # 날짜 형식은 JSON으로 처리\\n                file_format = \\\"json\\\"\\n            else:\\n                file_format = \\\"txt\\\"\\n        except Exception:\\n            # 예외 발생시 안전하게 txt로 처리\\n            file_format = \\\"txt\\\"\\n    elif file_suffix in [\\\"json\\\", \\\"log\\\", \\\"html\\\", \\\"txt\\\"]:\\n        file_format = file_suffix\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\n        file_format = \\\"txt\\\"\\n\\n    return {\\n        \\\"path\\\": file,\\n        \\\"name\\\": file.name,\\n        \\\"model\\\": model_name_candidate,\\n        \\\"date\\\": date_candidate,\\n        \\\"mtime\\\": mtime,\\n        \\\"size\\\": size,\\n        \\\"size_str\\\": size_str,\\n        \\\"format\\\": file_format,\\n    }\\n```\", \"improved_code\": \"```python\\ndef get_file_info(file: Path) -> dict[str, Any]:\\n    \\\"\\\"\\\"파일 정보를 가져옵니다.\\\"\\\"\\\"\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\n    size = file.stat().st_size\\n    size_str = f\\\"{size / 1024:.1f}KB\\\" if size >= 1024 else f\\\"{size}B\\\"\\n\\n    model_name_candidate = \\\"\\\"\\n    date_candidate = mtime\\n    file_format = file.suffix.lstrip(\\\".\\\").lower() or \\\"txt\\\"\\n\\n    # 표준 파일명 형식 (예: YYYYMMDD_HHMMSS-ModelName_review_log.json) 파싱 시도\\n    try:\\n        parts = file.stem.split('-')\\n        if len(parts) >= 2:\\n            date_model_part = parts[0]\\n            other_parts = parts[1:]\\n\\n            date_model_subparts = date_model_part.split('_')\\n            if len(date_model_subparts) >= 2:\\n                 # YYYYMMDD_HHMMSS 형식 체크\\n                if (\\n                    date_model_subparts[0].isdigit()\\n                    and len(date_model_subparts[0]) == 8\\n                    and date_model_subparts[1].isdigit()\\n                    and len(date_model_subparts[1]) == 6\\n                ):\\n                    date_str = f\\\"{date_model_subparts[0]}_{date_model_subparts[1]}\\\"\\n                    date_candidate = datetime.strptime(date_str, \\\"%Y%m%d_%H%M%S\\\")\\n                    model_name_candidate = '-'.join(other_parts).split('_review_log')[0] # 예시 파싱\\n\\n    except Exception:\\n        pass # 파싱 실패 시 기본값 유지\\n\\n    # llm_eval 디렉토리 내 파일은 무조건 JSON으로 처리\\n    try:\\n        llm_eval_dir = get_default_llm_eval_data_dir()\\n        if file.parent.resolve().startswith(llm_eval_dir.resolve()):\\n             file_format = \\\"json\\\"\\n    except Exception:\\n        pass\\n\\n    # 알려진 확장자 처리\\n    if file_format not in [\\\"json\\\", \\\"log\\\", \\\"html\\\", \\\"txt\\\"]:\\n         file_format = \\\"txt\\\"\\n\\n    return {\\n        \\\"path\\\": file,\\n        \\\"name\\\": file.name,\\n        \\\"model\\\": model_name_candidate,\\n        \\\"date\\\": date_candidate,\\n        \\\"mtime\\\": mtime,\\n        \\\"size\\\": size,\\n        \\\"size_str\\\": size_str,\\n        \\\"format\\\": file_format,\\n    }\\n```\"}, {\"type\": \"스타일\", \"line_number\": 428, \"file\": \"reviewer/src/ui.py\", \"description\": \"JSON 데이터 내부에 문자열화된 JSON이 포함된 경우 (예: 프롬프트, llm_eval 결과의 input/actualOutput) 이를 파싱하는 로직이 여러 곳에서 반복되고 중첩되어 있습니다. 이는 코드의 가독성과 유지보수성을 저해합니다.\", \"suggestion\": \"문자열화된 JSON을 재귀적으로 파싱하는 별도의 헬퍼 함수를 생성하고, 이 함수를 필요한 곳에서 호출하여 코드 중복을 제거하고 로직을 단순화하세요.\", \"severity\": \"info\", \"original_code\": \"```python\\n                elif view_type == \\\"프롬프트\\\":\\n                    # 프롬프트 데이터 (최상위가 리스트인 경우) 처리\\n                    # 각 항목의 'content'가 문자열화된 JSON이면 파싱\\n                    st.markdown(\\\"## 프롬프트 내용\\\")\\n                    if isinstance(json_data, list):\\n                        for item in json_data:\\n                            if (\\n                                isinstance(item, dict)\\n                                and \\\"content\\\" in item\\n                                and isinstance(item[\\\"content\\\"], str)\\n                            ):\\n                                try:\\n                                    item[\\\"content\\\"] = json.loads(item[\\\"content\\\"])\\n                                except json.JSONDecodeError:\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\n                    st.json(json_data)\\n                elif view_type == \\\"통합 JSON\\\":\\n                    st.markdown(\\\"## 통합 JSON 내용\\\")\\n                    if \\\"prompt\\\" in json_data and isinstance(json_data[\\\"prompt\\\"], list):\\n                        for i, item in enumerate(json_data[\\\"prompt\\\"]):\\n                            if \\\"content\\\" in item and isinstance(item[\\\"content\\\"], str):\\n                                try:\\n                                    item[\\\"content\\\"] = json.loads(item[\\\"content\\\"])\\n```\", \"improved_code\": \"```python\\ndef parse_nested_json_strings(data: Any) -> Any:\\n    \\\"\\\"\\\"데이터 구조 내에서 문자열화된 JSON을 파싱합니다.\\\"\\\"\\\"\\n    if isinstance(data, dict):\\n        for key, value in data.items():\\n            if isinstance(value, str):\\n                try:\\n                    data[key] = json.loads(value)\\n                    # 재귀적으로 파싱된 내용 안에서도 다시 파싱 시도\\n                    data[key] = parse_nested_json_strings(data[key])\\n                except json.JSONDecodeError:\\n                    pass # 파싱 실패 시 문자열 유지\\n            else:\\n                data[key] = parse_nested_json_strings(value)\\n    elif isinstance(data, list):\\n        data = [parse_nested_json_strings(item) for item in data]\\n    return data\\n\\n# ... (중략) ...\\n\\n                elif view_type == \\\"프롬프트\\\":\\n                    st.markdown(\\\"## 프롬프트 내용\\\")\\n                    # 헬퍼 함수를 사용하여 파싱\\n                    parsed_data = parse_nested_json_strings(json_data)\\n                    st.json(parsed_data)\\n                elif view_type == \\\"review log\\\": # 통합된 '리뷰 로그' 또는 유사 이름 사용 권장\\n                    st.markdown(\\\"## review log\\\")\\n                    # 헬퍼 함수를 사용하여 파싱\\n                    parsed_data = parse_nested_json_strings(json_data)\\n                    st.json(parsed_data)\\n                elif view_type == \\\"llm_eval 결과\\\":\\n                    st.markdown(\\\"## llm_eval 결과 내용\\\")\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\n                    display_data = copy.deepcopy(json_data)\\n\\n                    # 헬퍼 함수를 사용하여 input/actualOutput 등 파싱\\n                    if isinstance(display_data, dict) and \\\"testCases\\\" in display_data:\\n                         if isinstance(display_data[\\\"testCases\\\"], list):\\n                              display_data[\\\"testCases\\\"] = [parse_nested_json_strings(tc) for tc in display_data[\\\"testCases\\\"]]\\n\\n                    # ... (나머지 llm_eval 필터링/표시 로직)\\n                    st.json(display_data)\\n```\"}], \"summary\": \"이 변경사항은 코드 리뷰 로그 파일명을 더 읽기 쉽게 변경하고(cli.py), Streamlit UI에서 '통합 JSON' 보기 옵션을 제거하며 'review log' 보기 옵션을 추가합니다(ui.py). UI 변경으로 인해 '리뷰 결과'와 'review log' 보기 유형이 동일한 파일을 가리키게 되어 중복이 발생했습니다. 또한, 사용되지 않는 '통합 JSON' 관련 함수가 남아있고, UI의 파일명 파싱 및 중첩 JSON 파싱 로직이 복잡합니다.\", \"score\": 7.0, \"recommendations\": [\"Streamlit UI에서 '리뷰 결과'와 'review log' 보기 유형을 하나로 통합하여 사용자 혼란을 줄이고 코드 중복을 제거하세요.\", \"더 이상 사용되지 않는 '통합 JSON' 관련 함수(`get_default_merged_data_dir`, `get_merged_data_files`)를 제거하여 코드를 정리하세요.\", \"로그 및 결과 파일의 파일명 형식을 표준화하고, UI의 `get_file_info` 함수 파싱 로직을 단순화하여 견고성을 높이세요.\", \"UI에서 JSON 데이터 내 문자열화된 JSON을 파싱하는 로직을 헬퍼 함수로 추출하여 코드 가독성과 유지보수성을 개선하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_model_info, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (사용되지 않음, 하위 호환성을 위해 유지됨)\\\\\\\",\\\\n        deprecated=True,\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\nclass ReviewStatus(Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 상태를 나타내는 열거형 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    SUCCESS = \\\\\\\"SUCCESS\\\\\\\"\\\\n    FAILED = \\\\\\\"FAILED\\\\\\\"\\\\n\\\\n\\\\ndef save_review_log(\\\\n    prompt: ReviewPrompt | ReviewPromptWithFileContent | None,\\\\n    review_request: ReviewRequest,\\\\n    review_response: ReviewResponse | None,\\\\n    status: ReviewStatus,\\\\n    error: Exception | None = None,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n    formatted = now.strftime(\\\\\\\"%Y-%m-%d %H:%M:%S\\\\\\\")\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{formatted}-{provider}-{model_name}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n        \\\\\\\"prompt\\\\\\\": prompt_data,\\\\n        \\\\\\\"review_request\\\\\\\": review_request.model_dump(mode=\\\\\\\"json\\\\\\\"),\\\\n        \\\\\\\"review_response\\\\\\\": response_data,\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    file_path = log_dir / f\\\\\\\"{log_id}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    try:\\\\n        # 리뷰 요청 생성\\\\n        review_request = ReviewRequest(\\\\n            diff_content=diff_content,\\\\n            processed_diff=diff_result,\\\\n            file_paths=[file.filename for file in diff_result.files],\\\\n            use_full_context=use_full_context,\\\\n            model=args.model,\\\\n            repo_path=repo_path,\\\\n        )\\\\n\\\\n        # 리뷰 요청 저장\\\\n        save_review_request(review_request)\\\\n\\\\n        # LLM 게이트웨이 가져오기\\\\n        llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n        # 코드 리뷰 수행\\\\n        logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n        review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n        review_response = llm_gateway.review_code(review_prompt)\\\\n        save_review_log(\\\\n            review_prompt, review_request, review_response, ReviewStatus.SUCCESS\\\\n        )\\\\n\\\\n        logger.info(\\\\\\\"코드 리뷰가 완료되었습니다. 리뷰 로그가 저장되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"코드 리뷰 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        save_review_log(\\\\n            review_prompt,\\\\n            review_request,\\\\n            None,\\\\n            ReviewStatus.FAILED,\\\\n            error=e,\\\\n        )\\\\n        return\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n    formatted = now.strftime(\\\\\\\"%Y-%m-%d %H:%M:%S\\\\\\\")\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{formatted}-{provider}-{model_name}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n```\\\", \\\"line_number\\\": 514}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 리뷰 로그에서 review_response 데이터 가져오기\\\\n                    if \\\\\\\"review_response\\\\\\\" in json_data and json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n                        # 딕셔너리를 ReviewResponse 객체로 변환\\\\n                        review_response = ReviewResponse.model_validate(\\\\n                            json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        )\\\\n\\\\n                        # ReviewFormatter를 사용하여 HTML로 변환\\\\n                        formatter = ReviewFormatter()\\\\n                        html_content = formatter.to_html(review_response)\\\\n\\\\n                        # HTML 내용을 Streamlit에 표시\\\\n                        html_content_with_style = html_content\\\\n                        st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n                    else:\\\\n                        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                        st.json(json_data)\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    # 프롬프트 데이터 (최상위가 리스트인 경우) 처리\\\\n                    # 각 항목의 'content'가 문자열화된 JSON이면 파싱\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**통합 JSON 저장 위치**: {get_default_merged_data_dir()}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"line_number\\\": 276}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"통합 JSON\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"line_number\\\": 288}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n        files = get_merged_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 통합 JSON 데이터가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 325}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 통합 JSON 내용\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"line_number\\\": 438}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 288, \"file\": \"reviewer/src/ui.py\", \"description\": \"UI 사이드바의 '보기 유형' 선택지에 '리뷰 결과'와 'review log'가 모두 포함되어 있습니다. 두 옵션 모두 내부적으로 `get_review_log_files()` 함수를 사용하여 동일한 로그 파일 목록을 불러옵니다. '리뷰 결과'는 로그 파일의 `review_response` 부분을 포맷하여 보여주는 반면, 'review log'는 로그 파일 전체의 원본 JSON 내용을 보여줍니다. 동일한 파일 소스를 다른 이름으로 제공하는 것이 사용자에게 혼동을 줄 수 있습니다.\", \"suggestion\": \"'review log' 옵션의 이름을 'Raw 리뷰 로그 JSON' 또는 이와 유사하게 변경하여 원본 JSON 데이터를 보여준다는 것을 명확히 하거나, '리뷰 결과' 보기 내에서 포맷된 결과와 원본 JSON을 전환할 수 있는 기능을 제공하는 것을 고려해볼 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    view_type = st.sidebar.selectbox(\\n        \\\"보기 유형:\\\",\\n        [\\n            \\\"리뷰 결과\\\",\\n            \\\"응답 로그\\\",\\n            \\\"reviewRequest\\\",\\n            \\\"프롬프트\\\",\\n            \\\"review log\\\",\\n            \\\"llm_eval 결과\\\",\\n        ],\\n        index=0,\\n    )\\n```\", \"improved_code\": \"```python\\n    view_type = st.sidebar.selectbox(\\n        \\\"보기 유형:\\\",\\n        [\\n            \\\"리뷰 결과 (포맷됨)\\\", # 또는 \\\"포맷된 리뷰 결과\\\"\\n            \\\"응답 로그\\\",\\n            \\\"reviewRequest\\\",\\n            \\\"프롬프트\\\",\\n            \\\"리뷰 로그 (원본 JSON)\\\", # 또는 \\\"Raw 리뷰 로그\\\"\\n            \\\"llm_eval 결과\\\",\\n        ],\\n        index=0,\\n    )\\n```\"}], \"summary\": \"reviewer/cli.py 파일에서 리뷰 로그 파일명 형식을 타임스탬프 기반에서 날짜/시간 기반으로 변경하여 가독성을 높였습니다. reviewer/src/ui.py 파일에서는 UI 사이드바의 보기 유형에서 '통합 JSON' 옵션을 제거하고 'review log' 옵션을 추가했습니다. 'review log' 옵션은 '리뷰 결과' 옵션과 동일한 로그 파일을 사용하지만, 원본 JSON 내용을 보여줍니다.\", \"score\": 8.0, \"recommendations\": [\"UI의 '보기 유형' 옵션 이름을 더 명확하게 변경하여 사용자가 각 옵션의 목적을 쉽게 이해할 수 있도록 합니다.\", \"가능하다면 '리뷰 결과' 보기 내에서 포맷된 결과와 원본 JSON 보기를 전환하는 기능을 통합하여 UI 복잡성을 줄이는 것을 고려합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_model_info, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (사용되지 않음, 하위 호환성을 위해 유지됨)\\\\\\\",\\\\n        deprecated=True,\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\nclass ReviewStatus(Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 상태를 나타내는 열거형 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    SUCCESS = \\\\\\\"SUCCESS\\\\\\\"\\\\n    FAILED = \\\\\\\"FAILED\\\\\\\"\\\\n\\\\n\\\\ndef save_review_log(\\\\n    prompt: ReviewPrompt | ReviewPromptWithFileContent | None,\\\\n    review_request: ReviewRequest,\\\\n    review_response: ReviewResponse | None,\\\\n    status: ReviewStatus,\\\\n    error: Exception | None = None,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{now.isoformat()}-{provider}-{model_name}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n        \\\\\\\"prompt\\\\\\\": prompt_data,\\\\n        \\\\\\\"review_request\\\\\\\": review_request.model_dump(mode=\\\\\\\"json\\\\\\\"),\\\\n        \\\\\\\"review_response\\\\\\\": response_data,\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    file_path = log_dir / f\\\\\\\"{log_id}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    try:\\\\n        # 리뷰 요청 생성\\\\n        review_request = ReviewRequest(\\\\n            diff_content=diff_content,\\\\n            processed_diff=diff_result,\\\\n            file_paths=[file.filename for file in diff_result.files],\\\\n            use_full_context=use_full_context,\\\\n            model=args.model,\\\\n            repo_path=repo_path,\\\\n        )\\\\n\\\\n        # 리뷰 요청 저장\\\\n        save_review_request(review_request)\\\\n\\\\n        # LLM 게이트웨이 가져오기\\\\n        llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n        # 코드 리뷰 수행\\\\n        logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n        review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n        review_response = llm_gateway.review_code(review_prompt)\\\\n        save_review_log(\\\\n            review_prompt, review_request, review_response, ReviewStatus.SUCCESS\\\\n        )\\\\n\\\\n        logger.info(\\\\\\\"코드 리뷰가 완료되었습니다. 리뷰 로그가 저장되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"코드 리뷰 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        save_review_log(\\\\n            review_prompt,\\\\n            review_request,\\\\n            None,\\\\n            ReviewStatus.FAILED,\\\\n            error=e,\\\\n        )\\\\n        return\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{now.isoformat()}-{provider}-{model_name}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n```\\\", \\\"line_number\\\": 518}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 리뷰 로그에서 review_response 데이터 가져오기\\\\n                    if \\\\\\\"review_response\\\\\\\" in json_data and json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n                        # 딕셔너리를 ReviewResponse 객체로 변환\\\\n                        review_response = ReviewResponse.model_validate(\\\\n                            json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        )\\\\n\\\\n                        # ReviewFormatter를 사용하여 HTML로 변환\\\\n                        formatter = ReviewFormatter()\\\\n                        html_content = formatter.to_html(review_response)\\\\n\\\\n                        # HTML 내용을 Streamlit에 표시\\\\n                        html_content_with_style = html_content\\\\n                        st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n                    else:\\\\n                        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                        st.json(json_data)\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    # 프롬프트 데이터 (최상위가 리스트인 경우) 처리\\\\n                    # 각 항목의 'content'가 문자열화된 JSON이면 파싱\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**통합 JSON 저장 위치**: {get_default_merged_data_dir()}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"line_number\\\": 276}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"통합 JSON\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"line_number\\\": 288}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n        files = get_merged_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 통합 JSON 데이터가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 325}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 통합 JSON 내용\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"line_number\\\": 438}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"제공된 diff는 주로 두 가지 변경 사항을 포함합니다. 첫째, `reviewer/cli.py` 파일에서 리뷰 로그 ID 생성 형식을 타임스탬프 기반에서 ISO 형식의 날짜/시간, 제공자, 모델 이름을 포함하는 형식으로 변경했습니다. 둘째, `reviewer/src/ui.py` 파일에서 Streamlit UI의 보기 유형 목록에서 '통합 JSON' 옵션을 제거하고 'review log' 옵션으로 대체했습니다. 이 변경은 UI에서 표시되는 로그 유형을 명확히 하고, 백엔드 로그 저장 방식과 일관성을 맞추기 위한 것으로 보입니다. 전반적으로 코드 품질은 양호하며, 변경 사항은 의도된 기능을 개선하거나 명확히 하는 방향으로 이루어졌습니다.\", \"score\": 9.0, \"recommendations\": [\"변경 사항이 잘 적용되었습니다. 현재의 코드 품질과 일관성을 유지하는 것이 좋습니다.\", \"로그 파일명 및 UI 표시 유형 변경에 대한 문서 업데이트를 고려해 볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"pyproject.toml\\\", \\\"file_content\\\": \\\"[build-system]\\\\nrequires = [\\\\\\\"setuptools>=42\\\\\\\", \\\\\\\"wheel\\\\\\\"]\\\\nbuild-backend = \\\\\\\"setuptools.build_meta\\\\\\\"\\\\n\\\\n[project]\\\\nname = \\\\\\\"reviewer\\\\\\\"\\\\ndynamic = [\\\\\\\"version\\\\\\\", \\\\\\\"scripts\\\\\\\", \\\\\\\"dependencies\\\\\\\"]\\\\ndescription = \\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\"\\\\nreadme = \\\\\\\"README.md\\\\\\\"\\\\nrequires-python = \\\\\\\">=3.6\\\\\\\"\\\\nlicense = {file = \\\\\\\"LICENSE\\\\\\\"}\\\\nauthors = [\\\\n    {name = \\\\\\\"Reviewer 팀\\\\\\\", email = \\\\\\\"yourmail@example.com\\\\\\\"}\\\\n]\\\\nclassifiers = [\\\\n    \\\\\\\"Programming Language :: Python :: 3\\\\\\\",\\\\n    \\\\\\\"License :: OSI Approved :: MIT License\\\\\\\",\\\\n    \\\\\\\"Operating System :: OS Independent\\\\\\\",\\\\n] \\\\n\\\\n[tool.ruff]\\\\nline-length = 88\\\\nselect = [\\\\\\\"E\\\\\\\", \\\\\\\"F\\\\\\\", \\\\\\\"I\\\\\\\", \\\\\\\"B\\\\\\\", \\\\\\\"C4\\\\\\\", \\\\\\\"ARG\\\\\\\", \\\\\\\"N\\\\\\\", \\\\\\\"UP\\\\\\\", \\\\\\\"ANN\\\\\\\", \\\\\\\"S\\\\\\\", \\\\\\\"A\\\\\\\", \\\\\\\"ANN401\\\\\\\"]\\\\n\\\\n[tool.ruff.lint.per-file-ignores]\\\\n\\\\\\\"tests/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n\\\\\\\"llm_eval/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\nline-length = 88\\\\nselect = [\\\\\\\"E\\\\\\\", \\\\\\\"F\\\\\\\", \\\\\\\"I\\\\\\\", \\\\\\\"B\\\\\\\", \\\\\\\"C4\\\\\\\", \\\\\\\"ARG\\\\\\\", \\\\\\\"N\\\\\\\", \\\\\\\"UP\\\\\\\", \\\\\\\"ANN\\\\\\\", \\\\\\\"S\\\\\\\", \\\\\\\"A\\\\\\\", \\\\\\\"ANN401\\\\\\\"]\\\\n\\\\n[tool.ruff.lint.per-file-ignores]\\\\n\\\\\\\"tests/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\nline-length = 88\\\\nselect = [\\\\\\\"E\\\\\\\", \\\\\\\"F\\\\\\\", \\\\\\\"I\\\\\\\", \\\\\\\"B\\\\\\\", \\\\\\\"C4\\\\\\\", \\\\\\\"ARG\\\\\\\", \\\\\\\"N\\\\\\\", \\\\\\\"UP\\\\\\\", \\\\\\\"ANN\\\\\\\", \\\\\\\"S\\\\\\\", \\\\\\\"A\\\\\\\", \\\\\\\"ANN401\\\\\\\"]\\\\n\\\\n[tool.ruff.lint.per-file-ignores]\\\\n\\\\\\\"tests/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n\\\\\\\"llm_eval/**/*.py\\\\\\\" = [\\\\\\\"S101\\\\\\\", \\\\\\\"ANN201\\\\\\\", \\\\\\\"ANN001\\\\\\\", \\\\\\\"ARG002\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 22}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root, is_ignore_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt_v1.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_ignore_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not review_request.use_full_context:\\\\n            raise ValueError(\\\\\\\"full context 플래그가 켜져있어야 합니다.\\\\\\\")\\\\n\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_ignore_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                if not request.file_content:\\\\n                    logger.warning(\\\\n                        f\\\\\\\"파일 내용이 없습니다. 파일 경로: {request.filename}\\\\\\\"\\\\n                    )\\\\n                    file_content = \\\\\\\"\\\\\\\"\\\\n                else:\\\\n                    file_content = request.file_content\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt_v1.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 32}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 22, \"file\": \"pyproject.toml\", \"description\": \"llm_eval 디렉토리 내 파일에 대해 특정 Ruff 린트 규칙(S101, ANN201, ANN001, ARG002)을 무시하도록 설정했습니다. 이는 해당 디렉토리의 코드에 대한 린트 검사를 완화합니다.\", \"suggestion\": \"llm_eval 디렉토리의 목적(예: 실험 코드, 스크립트 등)이 명확하다면 이러한 설정은 허용될 수 있습니다. 하지만 코드 품질 일관성을 위해 가능하다면 린트 규칙을 준수하는 것이 좋습니다. 필요하다면 특정 라인에 `# noqa` 주석을 사용하는 것을 고려할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"[tool.ruff.lint.per-file-ignores]\\n\\\"tests/**/*.py\\\" = [\\\"S101\\\", \\\"ANN201\\\", \\\"ANN001\\\", \\\"ARG002\\\"]\\n\", \"improved_code\": \"[tool.ruff.lint.per-file-ignores]\\n\\\"tests/**/*.py\\\" = [\\\"S101\\\", \\\"ANN201\\\", \\\"ANN001\\\", \\\"ARG002\\\"]\\n\\\"llm_eval/**/*.py\\\" = [\\\"S101\\\", \\\"ANN201\\\", \\\"ANN001\\\", \\\"ARG002\\\"]\\n\"}, {\"type\": \"info\", \"line_number\": 32, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"시스템 프롬프트 파일 경로가 `code_review_system_prompt.txt`에서 `code_review_system_prompt_v1.txt`로 변경되었습니다. 이는 프롬프트 버전을 관리하기 위한 변경으로 보입니다.\", \"suggestion\": \"특별한 개선 사항은 없습니다. 프롬프트 파일 버전 관리가 의도된 것이라면 이 변경은 적절합니다.\", \"severity\": \"info\", \"original_code\": \"        prompt_path = (\\n            project_root\\n            / \\\"resources\\\"\\n            / \\\"prompt\\\"\\n            / \\\"v1\\\"\\n            / \\\"code_review_system_prompt.txt\\\"\\n        )\\n\", \"improved_code\": \"        prompt_path = (\\n            project_root\\n            / \\\"resources\\\"\\n            / \\\"prompt\\\"\\n            / \\\"v1\\\"\\n            / \\\"code_review_system_prompt_v1.txt\\\"\\n        )\\n\"}], \"summary\": \"pyproject.toml 파일에 llm_eval 디렉토리에 대한 Ruff 린트 규칙 무시 설정이 추가되었고, 프롬프트 생성기에서 사용하는 시스템 프롬프트 파일 경로가 업데이트되었습니다.\", \"score\": 9.5, \"recommendations\": [\"llm_eval 디렉토리의 코드 품질 기준에 대해 팀 내에서 논의하고, 필요하다면 린트 규칙 무시 범위를 조정하거나 특정 라인에 `# noqa` 주석을 사용하는 것을 고려하세요.\", \"프롬프트 파일 버전 관리 전략을 문서화하여 팀원들이 이해하고 따를 수 있도록 하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    formatter = ReviewFormatter()\\\\n    output_content = formatter.format(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 18}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_formatter.py\\\", \\\"file_content\\\": \\\"삭제된 파일\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\\n\\\\n    이 클래스는 리뷰 응답을 마크다운, HTML 등 다양한 출력 형식으로 변환하는 기능을 제공합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def format(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n`​``\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n`​``\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n`​``\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n`​``\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter 테스트 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom unittest.mock import patch\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef complex_review_response() -> ReviewResponse:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"복잡한 형태의 ReviewResponse 객체를 생성하는 픽스처입니다.\\\\n\\\\n    Returns:\\\\n        ReviewResponse: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return ReviewResponse(\\\\n        issues=[\\\\n            ReviewIssue(\\\\n                type=\\\\\\\"버그\\\\\\\",\\\\n                line_number=10,\\\\n                file=\\\\\\\"main.py\\\\\\\",\\\\n                description=\\\\\\\"잠재적인 널 참조 오류\\\\\\\",\\\\n                suggestion=\\\\\\\"None 체크 추가\\\\\\\",\\\\n                severity=\\\\\\\"error\\\\\\\",\\\\n                original_code=\\\\\\\"data = user.get_data()\\\\\\\",\\\\n                improved_code=\\\\\\\"if user is not None:\\\\\\\\n    data = user.get_data()\\\\\\\\nelse:\\\\\\\\n    data = None\\\\\\\",\\\\n            ),\\\\n            ReviewIssue(\\\\n                type=\\\\\\\"성능\\\\\\\",\\\\n                line_number=25,\\\\n                file=\\\\\\\"utils.py\\\\\\\",\\\\n                description=\\\\\\\"비효율적인 루프 사용\\\\\\\",\\\\n                suggestion=\\\\\\\"리스트 컴프리헨션 사용\\\\\\\",\\\\n                severity=\\\\\\\"warning\\\\\\\",\\\\n                original_code=\\\\\\\"result = []\\\\\\\\nfor item in items:\\\\\\\\n    result.append(item.value)\\\\\\\",\\\\n                improved_code=\\\\\\\"result = [item.value for item in items]\\\\\\\",\\\\n            ),\\\\n        ],\\\\n        summary=\\\\\\\"코드에 몇 가지 개선이 필요합니다.\\\\\\\",\\\\n        score=7.5,\\\\n        recommendations=[\\\\\\\"변수명 명확히 하기\\\\\\\", \\\\\\\"주석 추가하기\\\\\\\"],\\\\n    )\\\\n\\\\n\\\\ndef test_formatter_to_markdown(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter의 to_markdown 메서드를 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 마크다운 형식 변환 테스트\\\\n    formatter = ReviewFormatter()\\\\n    markdown = formatter.to_markdown(complex_review_response)\\\\n\\\\n    # 기본 구조 검증\\\\n    assert \\\\\\\"# 코드 리뷰 결과\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 요약\\\\\\\" in markdown\\\\n    assert \\\\\\\"코드에 몇 가지 개선이 필요합니다.\\\\\\\" in markdown\\\\n    assert \\\\\\\"**점수**: 7.5/10\\\\\\\" in markdown\\\\n\\\\n    # 이슈 검증\\\\n    assert \\\\\\\"## 발견된 이슈\\\\\\\" in markdown\\\\n    assert \\\\\\\"### 1. 🛑 버그\\\\\\\" in markdown\\\\n    assert \\\\\\\"**파일**: `main.py`, **라인**: 10\\\\\\\" in markdown\\\\n    assert \\\\\\\"잠재적인 널 참조 오류\\\\\\\" in markdown\\\\n    assert \\\\\\\"None 체크 추가\\\\\\\" in markdown\\\\n\\\\n    # 코드 블록 검증\\\\n    assert \\\\\\\"```\\\\\\\\ndata = user.get_data()\\\\\\\\n```\\\\\\\" in markdown\\\\n    assert \\\\\\\"```\\\\\\\\nif user is not None:\\\\\\\" in markdown\\\\n\\\\n    # 두 번째 이슈 검증\\\\n    assert \\\\\\\"### 2. ⚠️ 성능\\\\\\\" in markdown\\\\n\\\\n    # 권장사항 검증\\\\n    assert \\\\\\\"## 권장사항\\\\\\\" in markdown\\\\n    assert \\\\\\\"1. 변수명 명확히 하기\\\\\\\" in markdown\\\\n    assert \\\\\\\"2. 주석 추가하기\\\\\\\" in markdown\\\\n\\\\n\\\\ndef test_formatter_to_html(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter의 to_html 메서드를 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # HTML 형식 변환 테스트\\\\n    formatter = ReviewFormatter()\\\\n    html = formatter.to_html(complex_review_response)\\\\n\\\\n    # 기본 구조 검증\\\\n    assert \\\\\\\"<!DOCTYPE html>\\\\\\\" in html\\\\n    assert \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\" in html\\\\n    assert \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\" in html\\\\n\\\\n    # 요약 및 점수 검증\\\\n    assert \\\\\\\"<h2>요약</h2>\\\\\\\" in html\\\\n    assert \\\\\\\"<p>코드에 몇 가지 개선이 필요합니다.</p>\\\\\\\" in html\\\\n    assert \\\\\\\"<p><strong>점수</strong>: 7.5/10</p>\\\\\\\" in html\\\\n\\\\n    # 이슈 및 코드 블록 검증\\\\n    assert \\\\\\\"<div class='issue error'>\\\\\\\" in html\\\\n    assert \\\\\\\"<pre><code>\\\\\\\" in html\\\\n    assert html.count(\\\\\\\"<pre><code>\\\\\\\") == 4  # 4개의 코드 블록 (2개 이슈 x 원본/개선 코드)\\\\n\\\\n    # CSS 스타일 포함 검증\\\\n    assert \\\\\\\"<style>\\\\\\\" in html\\\\n\\\\n\\\\ndef test_formatter_empty_review() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter가 빈 리뷰 응답을 올바르게 처리하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 빈 리뷰 응답 테스트\\\\n    empty_review = ReviewResponse(\\\\n        issues=[], summary=\\\\\\\"No issues found.\\\\\\\", score=10.0, recommendations=[]\\\\n    )\\\\n\\\\n    formatter = ReviewFormatter()\\\\n    markdown = formatter.to_markdown(empty_review)\\\\n\\\\n    assert \\\\\\\"# 코드 리뷰 결과\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 요약\\\\\\\" in markdown\\\\n    assert \\\\\\\"No issues found.\\\\\\\" in markdown\\\\n    assert \\\\\\\"**점수**: 10.0/10\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 발견된 이슈\\\\\\\" not in markdown  # 이슈가 없으므로 섹션이 없어야 함\\\\n    assert \\\\\\\"## 권장사항\\\\\\\" not in markdown  # 권장사항이 없으므로 섹션이 없어야 함\\\\n\\\\n\\\\n# format 메서드에 대한 테스트 추가\\\\ndef test_formatter_format_markdown(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 마크다운 형식으로 올바르게 변환하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # format 메서드 호출 (기본값: markdown)\\\\n    markdown_result = formatter.format(complex_review_response)\\\\n\\\\n    # to_markdown 메서드의 결과와 비교\\\\n    expected_result = formatter.to_markdown(complex_review_response)\\\\n    assert markdown_result == expected_result\\\\n\\\\n\\\\ndef test_formatter_format_html(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 HTML 형식으로 올바르게 변환하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # format 메서드 호출 (html 형식 지정)\\\\n    html_result = formatter.format(complex_review_response, output_format=\\\\\\\"html\\\\\\\")\\\\n\\\\n    # to_html 메서드의 결과와 비교\\\\n    expected_result = formatter.to_html(complex_review_response)\\\\n    assert html_result == expected_result\\\\n\\\\n\\\\ndef test_formatter_format_invalid() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 지원하지 않는 형식에 대해 예외를 발생시키는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n    review = ReviewResponse(issues=[], summary=\\\\\\\"테스트용 리뷰\\\\\\\", recommendations=[])\\\\n\\\\n    # 지원하지 않는 형식으로 호출시 ValueError 발생 확인\\\\n    with pytest.raises(ValueError) as excinfo:\\\\n        formatter.format(review, output_format=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # 예외 메시지 검증\\\\n    assert \\\\\\\"지원하지 않는 출력 형식\\\\\\\" in str(excinfo.value)\\\\n\\\\n\\\\n# 모킹을 사용한 format 메서드 테스트\\\\ndef test_formatter_format_calls_correct_method(\\\\n    complex_review_response: ReviewResponse,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 출력 형식에 따라 올바른 메서드를 호출하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # to_markdown 메서드 모킹\\\\n    with patch.object(formatter, \\\\\\\"to_markdown\\\\\\\") as mock_to_markdown:\\\\n        formatter.format(complex_review_response)\\\\n        # to_markdown이 호출되었는지 확인\\\\n        mock_to_markdown.assert_called_once_with(complex_review_response)\\\\n\\\\n    # to_html 메서드 모킹\\\\n    with patch.object(formatter, \\\\\\\"to_html\\\\\\\") as mock_to_html:\\\\n        formatter.format(complex_review_response, output_format=\\\\\\\"html\\\\\\\")\\\\n        # to_html이 호출되었는지 확인\\\\n        mock_to_html.assert_called_once_with(complex_review_response)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\nfrom unittest.mock import patch\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef complex_review_response() -> ReviewResponse:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\nfrom unittest.mock import patch\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef complex_review_response() -> ReviewResponse:\\\\n```\\\", \\\"line_number\\\": 2}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"ReviewFormatter 모듈이 `reviewer.src`에서 `reviewer.src.utils`로 이동되었으며, 관련 import 경로가 수정되었습니다. 이는 코드 구조를 개선하기 위한 리팩토링 변경입니다.\", \"score\": 10.0, \"recommendations\": [\"ReviewFormatter 모듈이 새로운 위치(`reviewer/src/utils/review_formatter.py`)에 올바르게 이동되었는지 확인하십시오 (이 diff에는 새 파일 생성이 포함되지 않았으므로 확인 필요).\", \"`utils` 디렉토리가 ReviewFormatter와 같은 유틸리티성 클래스를 포함하기에 적절한 위치인지 프로젝트 구조 관점에서 검토하십시오.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter 테스트 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom unittest.mock import patch\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef complex_review_response() -> ReviewResponse:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"복잡한 형태의 ReviewResponse 객체를 생성하는 픽스처입니다.\\\\n\\\\n    Returns:\\\\n        ReviewResponse: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return ReviewResponse(\\\\n        issues=[\\\\n            ReviewIssue(\\\\n                type=\\\\\\\"버그\\\\\\\",\\\\n                line_number=10,\\\\n                file=\\\\\\\"main.py\\\\\\\",\\\\n                description=\\\\\\\"잠재적인 널 참조 오류\\\\\\\",\\\\n                suggestion=\\\\\\\"None 체크 추가\\\\\\\",\\\\n                severity=\\\\\\\"error\\\\\\\",\\\\n                original_code=\\\\\\\"data = user.get_data()\\\\\\\",\\\\n                improved_code=\\\\\\\"if user is not None:\\\\\\\\n    data = user.get_data()\\\\\\\\nelse:\\\\\\\\n    data = None\\\\\\\",\\\\n            ),\\\\n            ReviewIssue(\\\\n                type=\\\\\\\"성능\\\\\\\",\\\\n                line_number=25,\\\\n                file=\\\\\\\"utils.py\\\\\\\",\\\\n                description=\\\\\\\"비효율적인 루프 사용\\\\\\\",\\\\n                suggestion=\\\\\\\"리스트 컴프리헨션 사용\\\\\\\",\\\\n                severity=\\\\\\\"warning\\\\\\\",\\\\n                original_code=\\\\\\\"result = []\\\\\\\\nfor item in items:\\\\\\\\n    result.append(item.value)\\\\\\\",\\\\n                improved_code=\\\\\\\"result = [item.value for item in items]\\\\\\\",\\\\n            ),\\\\n        ],\\\\n        summary=\\\\\\\"코드에 몇 가지 개선이 필요합니다.\\\\\\\",\\\\n        score=7.5,\\\\n        recommendations=[\\\\\\\"변수명 명확히 하기\\\\\\\", \\\\\\\"주석 추가하기\\\\\\\"],\\\\n    )\\\\n\\\\n\\\\ndef test_formatter_to_markdown(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter의 to_markdown 메서드를 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 마크다운 형식 변환 테스트\\\\n    formatter = ReviewFormatter()\\\\n    markdown = formatter.to_markdown(complex_review_response)\\\\n\\\\n    # 기본 구조 검증\\\\n    assert \\\\\\\"# 코드 리뷰 결과\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 요약\\\\\\\" in markdown\\\\n    assert \\\\\\\"코드에 몇 가지 개선이 필요합니다.\\\\\\\" in markdown\\\\n    assert \\\\\\\"**점수**: 7.5/10\\\\\\\" in markdown\\\\n\\\\n    # 이슈 검증\\\\n    assert \\\\\\\"## 발견된 이슈\\\\\\\" in markdown\\\\n    assert \\\\\\\"### 1. 🛑 버그\\\\\\\" in markdown\\\\n    assert \\\\\\\"**파일**: `main.py`, **라인**: 10\\\\\\\" in markdown\\\\n    assert \\\\\\\"잠재적인 널 참조 오류\\\\\\\" in markdown\\\\n    assert \\\\\\\"None 체크 추가\\\\\\\" in markdown\\\\n\\\\n    # 코드 블록 검증\\\\n    assert \\\\\\\"```\\\\\\\\ndata = user.get_data()\\\\\\\\n```\\\\\\\" in markdown\\\\n    assert \\\\\\\"```\\\\\\\\nif user is not None:\\\\\\\" in markdown\\\\n\\\\n    # 두 번째 이슈 검증\\\\n    assert \\\\\\\"### 2. ⚠️ 성능\\\\\\\" in markdown\\\\n\\\\n    # 권장사항 검증\\\\n    assert \\\\\\\"## 권장사항\\\\\\\" in markdown\\\\n    assert \\\\\\\"1. 변수명 명확히 하기\\\\\\\" in markdown\\\\n    assert \\\\\\\"2. 주석 추가하기\\\\\\\" in markdown\\\\n\\\\n\\\\ndef test_formatter_to_html(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter의 to_html 메서드를 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # HTML 형식 변환 테스트\\\\n    formatter = ReviewFormatter()\\\\n    html = formatter.to_html(complex_review_response)\\\\n\\\\n    # 기본 구조 검증\\\\n    assert \\\\\\\"<!DOCTYPE html>\\\\\\\" in html\\\\n    assert \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\" in html\\\\n    assert \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\" in html\\\\n\\\\n    # 요약 및 점수 검증\\\\n    assert \\\\\\\"<h2>요약</h2>\\\\\\\" in html\\\\n    assert \\\\\\\"<p>코드에 몇 가지 개선이 필요합니다.</p>\\\\\\\" in html\\\\n    assert \\\\\\\"<p><strong>점수</strong>: 7.5/10</p>\\\\\\\" in html\\\\n\\\\n    # 이슈 및 코드 블록 검증\\\\n    assert \\\\\\\"<div class='issue error'>\\\\\\\" in html\\\\n    assert \\\\\\\"<pre><code>\\\\\\\" in html\\\\n    assert html.count(\\\\\\\"<pre><code>\\\\\\\") == 4  # 4개의 코드 블록 (2개 이슈 x 원본/개선 코드)\\\\n\\\\n    # CSS 스타일 포함 검증\\\\n    assert \\\\\\\"<style>\\\\\\\" in html\\\\n\\\\n\\\\ndef test_formatter_empty_review() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter가 빈 리뷰 응답을 올바르게 처리하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 빈 리뷰 응답 테스트\\\\n    empty_review = ReviewResponse(\\\\n        issues=[], summary=\\\\\\\"No issues found.\\\\\\\", score=10.0, recommendations=[]\\\\n    )\\\\n\\\\n    formatter = ReviewFormatter()\\\\n    markdown = formatter.to_markdown(empty_review)\\\\n\\\\n    assert \\\\\\\"# 코드 리뷰 결과\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 요약\\\\\\\" in markdown\\\\n    assert \\\\\\\"No issues found.\\\\\\\" in markdown\\\\n    assert \\\\\\\"**점수**: 10.0/10\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 발견된 이슈\\\\\\\" not in markdown  # 이슈가 없으므로 섹션이 없어야 함\\\\n    assert \\\\\\\"## 권장사항\\\\\\\" not in markdown  # 권장사항이 없으므로 섹션이 없어야 함\\\\n\\\\n\\\\n# format 메서드에 대한 테스트 추가\\\\ndef test_formatter_format_markdown(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 마크다운 형식으로 올바르게 변환하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # format 메서드 호출 (기본값: markdown)\\\\n    markdown_result = formatter.format(complex_review_response)\\\\n\\\\n    # to_markdown 메서드의 결과와 비교\\\\n    expected_result = formatter.to_markdown(complex_review_response)\\\\n    assert markdown_result == expected_result\\\\n\\\\n\\\\ndef test_formatter_format_html(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 HTML 형식으로 올바르게 변환하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # format 메서드 호출 (html 형식 지정)\\\\n    html_result = formatter.format(complex_review_response, output_format=\\\\\\\"html\\\\\\\")\\\\n\\\\n    # to_html 메서드의 결과와 비교\\\\n    expected_result = formatter.to_html(complex_review_response)\\\\n    assert html_result == expected_result\\\\n\\\\n\\\\ndef test_formatter_format_invalid() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 지원하지 않는 형식에 대해 예외를 발생시키는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n    review = ReviewResponse(issues=[], summary=\\\\\\\"테스트용 리뷰\\\\\\\", recommendations=[])\\\\n\\\\n    # 지원하지 않는 형식으로 호출시 ValueError 발생 확인\\\\n    with pytest.raises(ValueError) as excinfo:\\\\n        formatter.format(review, output_format=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # 예외 메시지 검증\\\\n    assert \\\\\\\"지원하지 않는 출력 형식\\\\\\\" in str(excinfo.value)\\\\n\\\\n\\\\n# 모킹을 사용한 format 메서드 테스트\\\\ndef test_formatter_format_calls_correct_method(\\\\n    complex_review_response: ReviewResponse,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 출력 형식에 따라 올바른 메서드를 호출하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # to_markdown 메서드 모킹\\\\n    with patch.object(formatter, \\\\\\\"to_markdown\\\\\\\") as mock_to_markdown:\\\\n        formatter.format(complex_review_response)\\\\n        # to_markdown이 호출되었는지 확인\\\\n        mock_to_markdown.assert_called_once_with(complex_review_response)\\\\n\\\\n    # to_html 메서드 모킹\\\\n    with patch.object(formatter, \\\\\\\"to_html\\\\\\\") as mock_to_html:\\\\n        formatter.format(complex_review_response, output_format=\\\\\\\"html\\\\\\\")\\\\n        # to_html이 호출되었는지 확인\\\\n        mock_to_html.assert_called_once_with(complex_review_response)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter 테스트 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom unittest.mock import patch\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef complex_review_response() -> ReviewResponse:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"복잡한 형태의 ReviewResponse 객체를 생성하는 픽스처입니다.\\\\n\\\\n    Returns:\\\\n        ReviewResponse: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return ReviewResponse(\\\\n        issues=[\\\\n            ReviewIssue(\\\\n                type=\\\\\\\"버그\\\\\\\",\\\\n                line_number=10,\\\\n                file=\\\\\\\"main.py\\\\\\\",\\\\n                description=\\\\\\\"잠재적인 널 참조 오류\\\\\\\",\\\\n                suggestion=\\\\\\\"None 체크 추가\\\\\\\",\\\\n                severity=\\\\\\\"error\\\\\\\",\\\\n                original_code=\\\\\\\"data = user.get_data()\\\\\\\",\\\\n                improved_code=\\\\\\\"if user is not None:\\\\\\\\n    data = user.get_data()\\\\\\\\nelse:\\\\\\\\n    data = None\\\\\\\",\\\\n            ),\\\\n            ReviewIssue(\\\\n                type=\\\\\\\"성능\\\\\\\",\\\\n                line_number=25,\\\\n                file=\\\\\\\"utils.py\\\\\\\",\\\\n                description=\\\\\\\"비효율적인 루프 사용\\\\\\\",\\\\n                suggestion=\\\\\\\"리스트 컴프리헨션 사용\\\\\\\",\\\\n                severity=\\\\\\\"warning\\\\\\\",\\\\n                original_code=\\\\\\\"result = []\\\\\\\\nfor item in items:\\\\\\\\n    result.append(item.value)\\\\\\\",\\\\n                improved_code=\\\\\\\"result = [item.value for item in items]\\\\\\\",\\\\n            ),\\\\n        ],\\\\n        summary=\\\\\\\"코드에 몇 가지 개선이 필요합니다.\\\\\\\",\\\\n        score=7.5,\\\\n        recommendations=[\\\\\\\"변수명 명확히 하기\\\\\\\", \\\\\\\"주석 추가하기\\\\\\\"],\\\\n    )\\\\n\\\\n\\\\ndef test_formatter_to_markdown(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter의 to_markdown 메서드를 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 마크다운 형식 변환 테스트\\\\n    formatter = ReviewFormatter()\\\\n    markdown = formatter.to_markdown(complex_review_response)\\\\n\\\\n    # 기본 구조 검증\\\\n    assert \\\\\\\"# 코드 리뷰 결과\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 요약\\\\\\\" in markdown\\\\n    assert \\\\\\\"코드에 몇 가지 개선이 필요합니다.\\\\\\\" in markdown\\\\n    assert \\\\\\\"**점수**: 7.5/10\\\\\\\" in markdown\\\\n\\\\n    # 이슈 검증\\\\n    assert \\\\\\\"## 발견된 이슈\\\\\\\" in markdown\\\\n    assert \\\\\\\"### 1. 🛑 버그\\\\\\\" in markdown\\\\n    assert \\\\\\\"**파일**: `main.py`, **라인**: 10\\\\\\\" in markdown\\\\n    assert \\\\\\\"잠재적인 널 참조 오류\\\\\\\" in markdown\\\\n    assert \\\\\\\"None 체크 추가\\\\\\\" in markdown\\\\n\\\\n    # 코드 블록 검증\\\\n    assert \\\\\\\"`​``\\\\\\\\ndata = user.get_data()\\\\\\\\n`​``\\\\\\\" in markdown\\\\n    assert \\\\\\\"`​``\\\\\\\\nif user is not None:\\\\\\\" in markdown\\\\n\\\\n    # 두 번째 이슈 검증\\\\n    assert \\\\\\\"### 2. ⚠️ 성능\\\\\\\" in markdown\\\\n\\\\n    # 권장사항 검증\\\\n    assert \\\\\\\"## 권장사항\\\\\\\" in markdown\\\\n    assert \\\\\\\"1. 변수명 명확히 하기\\\\\\\" in markdown\\\\n    assert \\\\\\\"2. 주석 추가하기\\\\\\\" in markdown\\\\n\\\\n\\\\ndef test_formatter_to_html(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter의 to_html 메서드를 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # HTML 형식 변환 테스트\\\\n    formatter = ReviewFormatter()\\\\n    html = formatter.to_html(complex_review_response)\\\\n\\\\n    # 기본 구조 검증\\\\n    assert \\\\\\\"<!DOCTYPE html>\\\\\\\" in html\\\\n    assert \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\" in html\\\\n    assert \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\" in html\\\\n\\\\n    # 요약 및 점수 검증\\\\n    assert \\\\\\\"<h2>요약</h2>\\\\\\\" in html\\\\n    assert \\\\\\\"<p>코드에 몇 가지 개선이 필요합니다.</p>\\\\\\\" in html\\\\n    assert \\\\\\\"<p><strong>점수</strong>: 7.5/10</p>\\\\\\\" in html\\\\n\\\\n    # 이슈 및 코드 블록 검증\\\\n    assert \\\\\\\"<div class='issue error'>\\\\\\\" in html\\\\n    assert \\\\\\\"<pre><code>\\\\\\\" in html\\\\n    assert html.count(\\\\\\\"<pre><code>\\\\\\\") == 4  # 4개의 코드 블록 (2개 이슈 x 원본/개선 코드)\\\\n\\\\n    # CSS 스타일 포함 검증\\\\n    assert \\\\\\\"<style>\\\\\\\" in html\\\\n\\\\n\\\\ndef test_formatter_empty_review() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter가 빈 리뷰 응답을 올바르게 처리하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 빈 리뷰 응답 테스트\\\\n    empty_review = ReviewResponse(\\\\n        issues=[], summary=\\\\\\\"No issues found.\\\\\\\", score=10.0, recommendations=[]\\\\n    )\\\\n\\\\n    formatter = ReviewFormatter()\\\\n    markdown = formatter.to_markdown(empty_review)\\\\n\\\\n    assert \\\\\\\"# 코드 리뷰 결과\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 요약\\\\\\\" in markdown\\\\n    assert \\\\\\\"No issues found.\\\\\\\" in markdown\\\\n    assert \\\\\\\"**점수**: 10.0/10\\\\\\\" in markdown\\\\n    assert \\\\\\\"## 발견된 이슈\\\\\\\" not in markdown  # 이슈가 없으므로 섹션이 없어야 함\\\\n    assert \\\\\\\"## 권장사항\\\\\\\" not in markdown  # 권장사항이 없으므로 섹션이 없어야 함\\\\n\\\\n\\\\n# format 메서드에 대한 테스트 추가\\\\ndef test_formatter_format_markdown(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 마크다운 형식으로 올바르게 변환하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # format 메서드 호출 (기본값: markdown)\\\\n    markdown_result = formatter.format(complex_review_response)\\\\n\\\\n    # to_markdown 메서드의 결과와 비교\\\\n    expected_result = formatter.to_markdown(complex_review_response)\\\\n    assert markdown_result == expected_result\\\\n\\\\n\\\\ndef test_formatter_format_html(complex_review_response: ReviewResponse) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 HTML 형식으로 올바르게 변환하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # format 메서드 호출 (html 형식 지정)\\\\n    html_result = formatter.format(complex_review_response, output_format=\\\\\\\"html\\\\\\\")\\\\n\\\\n    # to_html 메서드의 결과와 비교\\\\n    expected_result = formatter.to_html(complex_review_response)\\\\n    assert html_result == expected_result\\\\n\\\\n\\\\ndef test_formatter_format_invalid() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 지원하지 않는 형식에 대해 예외를 발생시키는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n    review = ReviewResponse(issues=[], summary=\\\\\\\"테스트용 리뷰\\\\\\\", recommendations=[])\\\\n\\\\n    # 지원하지 않는 형식으로 호출시 ValueError 발생 확인\\\\n    with pytest.raises(ValueError) as excinfo:\\\\n        formatter.format(review, output_format=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # 예외 메시지 검증\\\\n    assert \\\\\\\"지원하지 않는 출력 형식\\\\\\\" in str(excinfo.value)\\\\n\\\\n\\\\n# 모킹을 사용한 format 메서드 테스트\\\\ndef test_formatter_format_calls_correct_method(\\\\n    complex_review_response: ReviewResponse,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"format 메서드가 출력 형식에 따라 올바른 메서드를 호출하는지 테스트합니다.\\\\n\\\\n    Args:\\\\n        complex_review_response: 테스트용 복잡한 리뷰 응답 객체\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    formatter = ReviewFormatter()\\\\n\\\\n    # to_markdown 메서드 모킹\\\\n    with patch.object(formatter, \\\\\\\"to_markdown\\\\\\\") as mock_to_markdown:\\\\n        formatter.format(complex_review_response)\\\\n        # to_markdown이 호출되었는지 확인\\\\n        mock_to_markdown.assert_called_once_with(complex_review_response)\\\\n\\\\n    # to_html 메서드 모킹\\\\n    with patch.object(formatter, \\\\\\\"to_html\\\\\\\") as mock_to_html:\\\\n        formatter.format(complex_review_response, output_format=\\\\\\\"html\\\\\\\")\\\\n        # to_html이 호출되었는지 확인\\\\n        mock_to_html.assert_called_once_with(complex_review_response)\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 60, \"file\": \"tests/test_review_formatter.py\", \"description\": \"마크다운 코드 블록을 검증하는 테스트 코드에서 비표준 문자열(`​`)이 포함된 백틱(` ``` `)을 사용하고 있습니다. 이는 실제 마크다운 렌더링 결과와 다를 수 있으며, 테스트의 정확성을 저해할 수 있습니다.\", \"suggestion\": \"표준 마크다운 코드 블록 표현인 세 개의 백틱(` ``` `)을 사용하여 검증 문자열을 수정해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"assert \\\"`​``\\\\ndata = user.get_data()\\\\n`​``\\\" in markdown\\nassert \\\"`​``\\\\nif user is not None:\\\" in markdown\", \"improved_code\": \"assert \\\"```\\\\ndata = user.get_data()\\\\n```\\\" in markdown\\nassert \\\"```\\\\nif user is not None:\\\" in markdown\"}], \"summary\": \"ReviewFormatter 테스트 코드에 대한 리뷰입니다. 전반적으로 잘 작성되었으며 다양한 케이스를 커버하고 있습니다. 마크다운 코드 블록 검증 문자열에 대한 사소한 수정이 필요합니다.\", \"score\": 9.0, \"recommendations\": [\"마크다운 코드 블록 검증 시 표준 문자열 사용\", \"테스트 커버리지 보고서 생성 및 확인\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    formatter = ReviewFormatter()\\\\n    output_content = formatter.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_converter import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    formatter = ReviewFormatter()\\\\n    output_content = formatter.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"line_number\\\": 584}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_converter.py\\\", \\\"file_content\\\": \\\"삭제된 파일\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"line_number\\\": 6}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/file_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n    \\\\\\\".exe\\\\\\\",\\\\n    \\\\\\\".dll\\\\\\\",\\\\n    \\\\\\\".so\\\\\\\",\\\\n    \\\\\\\".dylib\\\\\\\",\\\\n    \\\\\\\".bin\\\\\\\",\\\\n    \\\\\\\".o\\\\\\\",\\\\n    \\\\\\\".obj\\\\\\\",\\\\n    \\\\\\\".a\\\\\\\",\\\\n    \\\\\\\".lib\\\\\\\",\\\\n    # 압축 파일\\\\n    \\\\\\\".zip\\\\\\\",\\\\n    \\\\\\\".tar\\\\\\\",\\\\n    \\\\\\\".gz\\\\\\\",\\\\n    \\\\\\\".bz2\\\\\\\",\\\\n    \\\\\\\".xz\\\\\\\",\\\\n    \\\\\\\".jar\\\\\\\",\\\\n    \\\\\\\".war\\\\\\\",\\\\n    \\\\\\\".ear\\\\\\\",\\\\n    \\\\\\\".aar\\\\\\\",\\\\n    # 이미지 파일\\\\n    \\\\\\\".jpg\\\\\\\",\\\\n    \\\\\\\".jpeg\\\\\\\",\\\\n    \\\\\\\".png\\\\\\\",\\\\n    \\\\\\\".gif\\\\\\\",\\\\n    \\\\\\\".bmp\\\\\\\",\\\\n    \\\\\\\".tiff\\\\\\\",\\\\n    \\\\\\\".ico\\\\\\\",\\\\n    \\\\\\\".webp\\\\\\\",\\\\n    # 비디오/오디오 파일\\\\n    \\\\\\\".mp3\\\\\\\",\\\\n    \\\\\\\".mp4\\\\\\\",\\\\n    \\\\\\\".wav\\\\\\\",\\\\n    \\\\\\\".avi\\\\\\\",\\\\n    \\\\\\\".mov\\\\\\\",\\\\n    \\\\\\\".mkv\\\\\\\",\\\\n    \\\\\\\".flac\\\\\\\",\\\\n    \\\\\\\".ogg\\\\\\\",\\\\n    # 문서 파일\\\\n    \\\\\\\".pdf\\\\\\\",\\\\n    \\\\\\\".doc\\\\\\\",\\\\n    \\\\\\\".docx\\\\\\\",\\\\n    \\\\\\\".ppt\\\\\\\",\\\\n    \\\\\\\".pptx\\\\\\\",\\\\n    \\\\\\\".xls\\\\\\\",\\\\n    \\\\\\\".xlsx\\\\\\\",\\\\n    # 기타 바이너리 파일\\\\n    \\\\\\\".class\\\\\\\",\\\\n    \\\\\\\".pyc\\\\\\\",\\\\n    \\\\\\\".pyo\\\\\\\",\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 바이너리 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n}\\\\n\\\\n# 무시할 텍스트 파일 이름 목록\\\\nIGNORE_FILENAMES = {\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n    \\\\\\\".env.local\\\\\\\",\\\\n    \\\\\\\".env.development\\\\\\\",\\\\n    \\\\\\\".env.production\\\\\\\",\\\\n    \\\\\\\".env.test\\\\\\\",\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_ignore_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 무시해야 할 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 무시해야 할 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 무시해야 할 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return (\\\\n        ext in BINARY_EXTENSIONS\\\\n        or base_name in BINARY_FILENAMES\\\\n        or base_name in IGNORE_FILENAMES\\\\n    )\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            # 삭제된 파일은 빈 문자열로 반환, 오류 발생 방지\\\\n            # 경로로 검색했을 때 존재하지 않는 경우는 삭제된 것으로 암묵적으로 간주\\\\n            # TODO: 명시적으로 삭제된 파일 처리 로직 추가\\\\n            return \\\\\\\"삭제된 파일\\\\\\\"\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[제외 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(\\\\n        f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다. 탐색 완료 경로: {current_dir}\\\\\\\"\\\\n    )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            # 삭제된 파일은 빈 문자열로 반환, 오류 발생 방지\\\\n            # 경로로 검색했을 때 존재하지 않는 경우는 삭제된 것으로 암묵적으로 간주\\\\n            # TODO: 명시적으로 삭제된 파일 처리 로직 추가\\\\n            return \\\\\\\"삭제된 파일\\\\\\\"\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n```\\\", \\\"line_number\\\": 144}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 18, \"file\": \"reviewer/cli.py\", \"description\": \"ReviewConverter 클래스가 ReviewFormatter로 변경되었으나, import 문만 변경되고 실제 사용 코드에서는 변수명이 일관되게 변경되지 않았습니다. 이는 코드의 일관성을 해치고 혼란을 줄 수 있습니다.\", \"suggestion\": \"변수명을 클래스명과 일치하도록 'formatter'로 통일하여 사용하세요. 이미 584번 라인에서는 'formatter'로 변경되었지만, 다른 곳에서도 일관되게 사용해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"from reviewer.src.review_converter import ReviewConverter\", \"improved_code\": \"from reviewer.src.review_formatter import ReviewFormatter\"}, {\"type\": \"설계\", \"line_number\": 584, \"file\": \"reviewer/cli.py\", \"description\": \"ReviewConverter 클래스가 ReviewFormatter로 변경되면서 변수명도 processor에서 formatter로 변경되었습니다. 이는 좋은 변경이지만, 이러한 변경이 코드베이스 전체에 일관되게 적용되었는지 확인해야 합니다.\", \"suggestion\": \"코드베이스 전체에서 ReviewConverter와 관련된 모든 참조를 ReviewFormatter로 변경하고, 변수명도 일관되게 'formatter'로 사용하세요.\", \"severity\": \"info\", \"original_code\": \"    # 리뷰 결과 처리\\n    processor = ReviewConverter()\\n    output_content = processor.convert(review_response, args.output_format)\", \"improved_code\": \"    # 리뷰 결과 처리\\n    formatter = ReviewFormatter()\\n    output_content = formatter.convert(review_response, args.output_format)\"}, {\"type\": \"설계\", \"line_number\": 6, \"file\": \"reviewer/src/review_formatter.py\", \"description\": \"ReviewFormatter 클래스에 convert 메서드가 추가되었습니다. 이전에는 ReviewConverter 클래스가 이 기능을 담당했으나, 이제 ReviewFormatter 클래스가 직접 변환 기능을 수행합니다. 이는 클래스 책임의 변화를 의미합니다.\", \"suggestion\": \"클래스 책임이 변경되었으므로 클래스 문서화 주석을 업데이트하여 이 클래스가 이제 변환 기능도 담당한다는 것을 명확히 하세요.\", \"severity\": \"info\", \"original_code\": \"class ReviewFormatter:\\n    \\\"\\\"\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\"\\\"\\\"\", \"improved_code\": \"class ReviewFormatter:\\n    \\\"\\\"\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\n    \\n    이 클래스는 리뷰 응답을 마크다운, HTML 등 다양한 출력 형식으로 변환하는 기능을 제공합니다.\\n    이전에는 ReviewConverter 클래스가 담당했던 변환 기능이 이 클래스로 통합되었습니다.\\n    \\\"\\\"\\\"\"}, {\"type\": \"설계\", \"line_number\": 144, \"file\": \"reviewer/src/utils/file_utils.py\", \"description\": \"파일이 존재하지 않을 때 예외를 발생시키는 대신 \\\"삭제된 파일\\\"이라는 문자열을 반환하도록 변경되었습니다. 이는 예외 처리 방식의 변경으로, 함수의 계약(contract)이 변경된 것입니다. 이러한 변경은 함수를 호출하는 모든 코드에 영향을 줄 수 있습니다.\", \"suggestion\": \"함수 문서화 주석을 업데이트하여 파일이 존재하지 않을 때의 새로운 동작을 명확히 설명하세요. 또한 TODO 주석은 구체적인 작업 항목과 이유를 포함하도록 개선하세요.\", \"severity\": \"warning\", \"original_code\": \"        if not os.path.exists(file_path):\\n            raise FileNotFoundError(f\\\"파일을 찾을 수 없습니다: {file_path}\\\")\", \"improved_code\": \"        if not os.path.exists(file_path):\\n            # 삭제된 파일은 오류 대신 특수 문자열을 반환하여 처리 흐름 유지\\n            # 이는 git diff에서 삭제된 파일을 처리할 때 예외 발생을 방지합니다\\n            # TODO: 삭제된 파일을 명시적으로 식별하고 처리하는 메커니즘 구현 (이슈 #123)\"}, {\"type\": \"버그\", \"line_number\": 144, \"file\": \"reviewer/src/utils/file_utils.py\", \"description\": \"파일이 존재하지 않을 때 \\\"삭제된 파일\\\"이라는 문자열을 반환하는 방식은 실제 파일 내용과 구분하기 어려울 수 있습니다. 파일 내용이 정확히 \\\"삭제된 파일\\\"이라는 텍스트인 경우와 구분할 방법이 없습니다.\", \"suggestion\": \"특수 상태를 나타내기 위해 문자열 대신 None을 반환하거나, 예외를 발생시키되 호출자가 적절히 처리하도록 하는 것이 더 명확합니다. 또는 삭제된 파일임을 명확히 나타내는 특수 클래스나 데이터 구조를 사용하세요.\", \"severity\": \"error\", \"original_code\": \"        if not os.path.exists(file_path):\\n            # 삭제된 파일은 빈 문자열로 반환, 오류 발생 방지\\n            # 경로로 검색했을 때 존재하지 않는 경우는 삭제된 것으로 암묵적으로 간주\\n            # TODO: 명시적으로 삭제된 파일 처리 로직 추가\\n            return \\\"삭제된 파일\\\"\", \"improved_code\": \"        if not os.path.exists(file_path):\\n            # 삭제된 파일은 None을 반환하여 실제 파일 내용과 명확히 구분\\n            # 호출자는 None 체크를 통해 삭제된 파일을 식별할 수 있음\\n            # TODO: 삭제된 파일을 위한 FileStatus 열거형 또는 클래스 도입 검토\\n            return None\"}], \"summary\": \"이번 코드 변경은 주로 코드 리뷰 결과 처리 로직의 구조 개선에 초점을 맞추고 있습니다. 주요 변경 사항은 다음과 같습니다:\\n\\n1. `ReviewConverter` 클래스가 삭제되고 해당 기능이 `ReviewFormatter` 클래스로 통합되었습니다. 이는 코드 중복을 줄이고 책임을 명확히 하는 긍정적인 변화입니다.\\n\\n2. `ReviewFormatter` 클래스에 `convert` 메서드가 추가되어 출력 형식에 따라 적절한 변환 메서드를 호출하는 역할을 담당합니다.\\n\\n3. `load_file_content` 함수의 동작이 변경되어 파일이 존재하지 않을 때 예외를 발생시키는 대신 \\\"삭제된 파일\\\"이라는 문자열을 반환합니다. 이는 예외 처리 방식의 변화로, 함수의 계약이 변경된 것입니다.\\n\\n전반적으로 코드 구조가 개선되었지만, 일부 일관성 문제와 함수 동작 변경에 따른 문서화 부족 등의 문제가 있습니다. 특히 파일이 존재하지 않을 때 문자열을 반환하는 방식은 실제 파일 내용과 구분하기 어려운 잠재적 버그를 포함하고 있습니다.\", \"score\": 7.5, \"recommendations\": [\"클래스 이름 변경 시 관련된 모든 참조와 변수명을 일관되게 변경하세요. 특히 ReviewConverter에서 ReviewFormatter로의 변경이 코드베이스 전체에 일관되게 적용되었는지 확인하세요.\", \"함수나 클래스의 동작이 변경될 때는 문서화 주석(docstring)을 반드시 업데이트하여 새로운 동작을 명확히 설명하세요.\", \"특수 상태(예: 파일이 존재하지 않음)를 나타낼 때는 일반 문자열보다 None이나 전용 열거형, 예외 처리 등 더 명확한 방법을 사용하세요.\", \"TODO 주석은 구체적인 작업 항목, 이유, 가능하면 관련 이슈 번호를 포함하도록 작성하세요.\", \"함수의 계약(반환 값, 예외 처리 등)을 변경할 때는 해당 함수를 호출하는 모든 코드를 검토하여 호환성 문제가 없는지 확인하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_converter import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"line_number\\\": 18, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    formatter = ReviewFormatter()\\\\n    output_content = formatter.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"line_number\\\": 584, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/review_converter.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/review_formatter.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"line_number\\\": 6, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 6, \"file\": \"reviewer/src/review_formatter.py\", \"description\": \"ReviewConverter 클래스가 제거되고 그 기능이 ReviewFormatter 클래스로 통합되었습니다. 이는 중간 레이어를 제거하여 코드 구조를 단순화하는 리팩토링입니다. 이 변경은 적절하지만, 클래스 이름과 메서드 이름이 더 명확하게 설계될 수 있습니다.\", \"suggestion\": \"ReviewFormatter 클래스의 convert 메서드 이름이 format으로 변경되면 클래스 이름과 더 일관성이 있을 것입니다. 또한 메서드 이름이 실제 동작을 더 정확히 반영할 것입니다.\", \"severity\": \"info\", \"original_code\": \"def convert(self, review: ReviewResponse, output_format: str = \\\"markdown\\\") -> str:\\n    \\\"\\\"\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\n\\n    Args:\\n        review: 리뷰 응답 객체\\n        output_format: 출력 형식 (markdown, html)\\n\\n    Returns:\\n        str: 변환된 리뷰 결과\\n\\n    Raises:\\n        ValueError: 지원하지 않는 출력 형식인 경우\\n    \\\"\\\"\\\"\", \"improved_code\": \"def format(self, review: ReviewResponse, output_format: str = \\\"markdown\\\") -> str:\\n    \\\"\\\"\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\n\\n    Args:\\n        review: 리뷰 응답 객체\\n        output_format: 출력 형식 (markdown, html)\\n\\n    Returns:\\n        str: 변환된 리뷰 결과\\n\\n    Raises:\\n        ValueError: 지원하지 않는 출력 형식인 경우\\n    \\\"\\\"\\\"\"}, {\"type\": \"설계\", \"line_number\": 584, \"file\": \"reviewer/cli.py\", \"description\": \"ReviewConverter 클래스가 ReviewFormatter로 변경되었지만, 변수명은 여전히 'processor'로 되어 있어 일관성이 떨어집니다. 변수명이 클래스 이름과 일치하도록 수정하는 것이 좋습니다.\", \"suggestion\": \"변수명을 'processor'에서 'formatter'로 변경하여 클래스 이름과 일치시키세요. 이렇게 하면 코드의 일관성이 향상됩니다.\", \"severity\": \"info\", \"original_code\": \"# 리뷰 결과 처리\\nprocessor = ReviewConverter()\\noutput_content = processor.convert(review_response, args.output_format)\", \"improved_code\": \"# 리뷰 결과 처리\\nformatter = ReviewFormatter()\\noutput_content = formatter.convert(review_response, args.output_format)\"}], \"summary\": \"이 코드 변경은 리뷰 결과 처리 로직을 단순화하는 리팩토링을 수행했습니다. 주요 변경 사항은 다음과 같습니다:\\n\\n1. `ReviewConverter` 클래스가 완전히 제거되고, 그 기능이 `ReviewFormatter` 클래스로 통합되었습니다.\\n2. `ReviewFormatter` 클래스에 `convert` 메서드가 추가되어 이전에 `ReviewConverter`가 수행하던 역할을 대신합니다.\\n3. 관련 import 문과 클래스 사용 부분이 모두 업데이트되었습니다.\\n\\n이 리팩토링은 중간 레이어를 제거하여 코드 구조를 단순화하고, 불필요한 위임(delegation)을 제거하는 긍정적인 변화입니다. 코드의 책임 분리가 더 명확해졌으며, 유지보수성이 향상되었습니다.\", \"score\": 8.0, \"recommendations\": [\"메서드 이름을 기능에 맞게 명확하게 지정하세요. 'convert' 대신 'format'이 더 적절할 수 있습니다.\", \"변수명을 클래스 이름과 일치시켜 코드의 일관성을 유지하세요.\", \"리팩토링 후에는 관련된 모든 테스트 코드도 업데이트하여 기능이 정상적으로 작동하는지 확인하세요.\", \"코드 변경 시 문서화(주석, 독스트링)도 함께 업데이트하여 일관성을 유지하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_converter import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"line_number\\\": 584}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_converter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport html\\\\nimport json\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_json(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 JSON 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: JSON 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return json.dumps(review.model_dump(), indent=2, ensure_ascii=False)\\\\n\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, list[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n                if issue.file not in file_issues:\\\\n                    file_issues[issue.file] = []\\\\n                file_issues[issue.file].append(issue)\\\\n\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> list[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            list[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n        )\\\\n\\\\n        return sorted_issues[:limit]\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html, json)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n        return {\\\\n            \\\\\\\"summary\\\\\\\": review.summary,\\\\n            \\\\\\\"score\\\\\\\": review.score,\\\\n            \\\\\\\"total_issues\\\\\\\": len(review.issues),\\\\n            \\\\\\\"severity_counts\\\\\\\": severity_counts,\\\\n            \\\\\\\"type_counts\\\\\\\": type_counts,\\\\n            \\\\\\\"most_critical_issues\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"type\\\\\\\": issue.type,\\\\n                    \\\\\\\"severity\\\\\\\": issue.severity,\\\\n                    \\\\\\\"description\\\\\\\": issue.description,\\\\n                }\\\\n                for issue in most_critical\\\\n            ],\\\\n            \\\\\\\"recommendations\\\\\\\": review.recommendations,\\\\n        }\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n```\\\", \\\"line_number\\\": 165}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 10, \"file\": \"reviewer/src/review_converter.py\", \"description\": \"새로 추가된 `ReviewConverter` 클래스는 `ReviewFormatter` 클래스를 인스턴스화하고 `convert` 메서드만 호출하는 단순 래퍼 역할을 합니다. 이는 불필요한 추상화 계층을 추가하며, `cli.py`에서 `ReviewFormatter`를 직접 사용하거나 두 클래스를 통합하는 것이 코드 구조를 더 간결하게 만들 수 있습니다.\", \"suggestion\": \"`ReviewConverter` 클래스를 제거하고 `cli.py`에서 `ReviewFormatter`를 직접 사용하도록 코드를 수정하거나, `ReviewConverter`에 `ReviewFormatter` 이상의 의미 있는 로직을 추가하여 역할을 명확히 합니다.\", \"severity\": \"warning\", \"original_code\": \"class ReviewConverter:\\n    \\\"\\\"\\\"리뷰 후처리기 클래스\\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.formatter = ReviewFormatter()\\n\\n    def convert(self, review: ReviewResponse, output_format: str = \\\"markdown\\\") -> str:\\n        \\\"\\\"\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\n\\n        Args:\\n            review: 리뷰 응답 객체\\n            output_format: 출력 형식 (markdown, html)\\n\\n        Returns:\\n            str: 변환된 리뷰 결과\\n        \\\"\\\"\\\"\\n        if output_format == \\\"markdown\\\":\\n            return self.formatter.to_markdown(review)\\n        elif output_format == \\\"html\\\":\\n            return self.formatter.to_html(review)\\n        else:\\n            raise ValueError(f\\\"지원하지 않는 출력 형식: {output_format}\\\")\", \"improved_code\": \"# ReviewConverter 클래스를 제거하고 ReviewFormatter를 직접 사용하거나 통합합니다.\"}, {\"type\": \"기능 변경\", \"line_number\": 165, \"file\": \"reviewer/src/review_formatter.py\", \"description\": \"이전 `ReviewPostProcessor`에 포함되어 있던 `ReviewAnalyzer` 클래스와 그 기능(심각도/유형별 이슈 집계, 중요 이슈 추출 등)이 코드에서 완전히 제거되었습니다. 이 분석 기능이 더 이상 필요 없는 것인지, 아니면 다른 곳으로 이동된 것인지 명확하지 않습니다. 만약 이 기능이 사용자에게 유용했다면, 제거는 기능 퇴보로 이어질 수 있습니다.\", \"suggestion\": \"`ReviewAnalyzer` 기능 제거의 필요성을 검토하고, 필요하다면 해당 기능을 복원하거나 다른 적절한 위치로 이동시킵니다. 기능 제거가 의도된 것이라면, 변경 사항을 명확히 문서화합니다.\", \"severity\": \"warning\", \"original_code\": \"class ReviewAnalyzer:\\n    \\\"\\\"\\\"리뷰 결과를 분석하는 클래스\\\"\\\"\\\"\\n\\n    @staticmethod\\n    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\\n        \\\"\\\"\\\"심각도별 이슈 수를 계산합니다.\\\"\\\"\\\"\\n        counts = {\\\"info\\\": 0, \\\"warning\\\": 0, \\\"error\\\": 0}\\n\\n        for issue in review.issues:\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\n\\n        return counts\\n\\n    @staticmethod\\n    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\\n        \\\"\\\"\\\"유형별 이슈 수를 계산합니다.\\\"\\\"\\\"\\n        counts = {}\\n\\n        for issue in review.issues:\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\n\\n        return counts\\n\\n    @staticmethod\\n    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\\n        \\\"\\\"\\\"파일별 이슈 목록을 반환합니다.\\\"\\\"\\\"\\n        file_issues = {}\\n\\n        for issue in review.issues:\\n            if issue.file:\\n                if issue.file not in file_issues:\\n                    file_issues[issue.file] = []\\n                file_issues[issue.file].append(issue)\\n\\n        return file_issues\\n\\n    @staticmethod\\n    def get_most_critical_issues(\\n        review: ReviewResponse, limit: int = 3\\n    ) -> list[ReviewIssue]:\\n        \\\"\\\"\\\"가장 중요한 이슈 목록을 반환합니다.\\\"\\\"\\\"\\n        # 심각도 순으로 정렬 (error > warning > info)\\n        severity_order = {\\\"error\\\": 0, \\\"warning\\\": 1, \\\"info\\\": 2}\\n        sorted_issues = sorted(\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\n        )\\n\\n        return sorted_issues[:limit]\\n\\n\\nclass ReviewPostProcessor:\\n    \\\"\\\"\\\"리뷰 후처리기 클래스\\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.formatter = ReviewFormatter()\\n        self.analyzer = ReviewAnalyzer()\\n\\n    def process_review(\\n        self, review: ReviewResponse, output_format: str = \\\"markdown\\\"\\n    ) -> str:\\n        \\\"\\\"\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\n\\n        Args:\\n            review: 리뷰 응답 객체\\n            output_format: 출력 형식 (markdown, html, json)\\n\\n        Returns:\\n            str: 변환된 리뷰 결과\\n        \\\"\\\"\\\"\\n        if output_format == \\\"markdown\\\":\\n            return self.formatter.to_markdown(review)\\n        elif output_format == \\\"html\\\":\\n            return self.formatter.to_html(review)\\n        else:\\n            raise ValueError(f\\\"지원하지 않는 출력 형식: {output_format}\\\")\\n\\n    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\\n        \\\"\\\"\\\"리뷰 결과의 요약 정보를 반환합니다.\\n\\n        Args:\\n            review: 리뷰 응답 객체\\n\\n        Returns:\\n            dict[str, Any]: 리뷰 요약 정보\\n        \\\"\\\"\\\"\\n        severity_counts = self.analyzer.get_severity_counts(review)\\n        type_counts = self.analyzer.get_type_counts(review)\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\n\\n        return {\\n            \\\"summary\\\": review.summary,\\n            \\\"score\\\": review.score,\\n            \\\"total_issues\\\": len(review.issues),\\n            \\\"severity_counts\\\": severity_counts,\\n            \\\"type_counts\\\": type_counts,\\n            \\\"most_critical_issues\\\": [\\n                {\\n                    \\\"type\\\": issue.type,\\n                    \\\"severity\\\": issue.severity,\\n                    \\\"description\\\": issue.description,\\n                }\\n                for issue in most_critical\\n            ],\\n            \\\"recommendations\\\": review.recommendations,\\n        }\", \"improved_code\": \"# ReviewAnalyzer 클래스 및 관련 기능이 제거되었습니다.\\n# 필요에 따라 복원하거나 다른 곳으로 이전해야 합니다.\"}, {\"type\": \"기능 변경\", \"line_number\": 165, \"file\": \"reviewer/src/review_formatter.py\", \"description\": \"`ReviewFormatter` 클래스에서 JSON 형식으로 변환하는 `to_json` 정적 메서드가 제거되었습니다. CLI의 `--output-format` 옵션에는 JSON이 포함되어 있지 않으므로 CLI 사용성 측면에서는 문제가 없지만, 내부적으로 JSON 출력이 필요한 다른 부분이 있었다면 해당 기능이 누락될 수 있습니다.\", \"suggestion\": \"JSON 출력 형식이 더 이상 필요 없는지 확인하고, 필요하다면 `ReviewConverter` 또는 다른 적절한 위치에 JSON 변환 로직을 다시 추가합니다.\", \"severity\": \"info\", \"original_code\": \"@staticmethod\\n    def to_json(review: ReviewResponse) -> str:\\n        \\\"\\\"\\\"리뷰 결과를 JSON 형식으로 변환합니다.\\n\\n        Args:\\n            review: 리뷰 응답 객체\\n\\n        Returns:\\n            str: JSON 형식의 리뷰 결과\\n        \\\"\\\"\\\"\\n        return json.dumps(review.model_dump(), indent=2, ensure_ascii=False)\", \"improved_code\": \"# JSON 출력이 필요하다면 해당 메서드를 복원하거나 다른 곳에 구현합니다.\"}], \"summary\": \"`ReviewPostProcessor` 클래스가 `ReviewConverter`로 이름이 변경되고, 리뷰 결과 분석을 담당하던 `ReviewAnalyzer` 클래스와 JSON 출력 기능(`to_json` 메서드)이 제거되었습니다. `cli.py` 파일은 변경된 클래스 이름과 메서드 호출에 맞춰 업데이트되었습니다. 전반적으로 리뷰 후처리 로직이 단순화되었으나, 분석 기능의 제거는 의도 확인이 필요합니다.\", \"score\": 6.5, \"recommendations\": [\"리뷰 결과 분석 기능(`ReviewAnalyzer`) 제거의 의도를 명확히 하고, 필요하다면 해당 기능을 복원하거나 다른 모듈로 이전하는 것을 고려하십시오.\", \"`ReviewConverter` 클래스가 `ReviewFormatter`를 단순히 감싸는 구조의 필요성을 재검토하고, 코드 구조를 더 간결하게 개선할 수 있는지 확인하십시오.\", \"JSON 출력 형식 제거가 애플리케이션의 요구사항과 일치하는지 확인하고, 필요하다면 해당 기능을 복원하십시오.\", \"주요 기능(분석 기능)이 제거된 경우, 변경 사항을 문서화하여 다른 개발자들이 이해할 수 있도록 하십시오.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewConverter\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewConverter()\\\\n    output_content = processor.convert(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n```\\\", \\\"line_number\\\": 584}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewConverter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def convert(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n```\\\", \\\"line_number\\\": 2}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 `ReviewPostProcessor` 클래스의 이름을 `ReviewConverter`로 변경하고, 해당 클래스의 주요 메서드인 `process_review`를 `convert`로 변경하는 리팩토링입니다. 이는 클래스의 역할(리뷰 결과를 다른 형식으로 변환)을 더 명확하게 반영하기 위한 네이밍 개선으로 보입니다. 관련 파일(`cli.py`와 `review_processor.py`)에서 해당 클래스와 메서드에 대한 모든 참조가 올바르게 업데이트되었습니다.\", \"score\": 9.5, \"recommendations\": [\"코드의 목적을 더 잘 나타내는 이름으로 리팩토링하는 것은 좋은 관행입니다. 이러한 개선을 계속 진행하세요.\", \"리팩토링 후에는 관련 테스트 케이스가 여전히 통과하는지 확인하여 변경사항이 예상대로 작동함을 보증하는 것이 중요합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport html\\\\nimport json\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n`​``\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n`​``\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n`​``\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n`​``\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_json(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 JSON 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: JSON 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return json.dumps(review.model_dump(), indent=2, ensure_ascii=False)\\\\n\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, list[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n                if issue.file not in file_issues:\\\\n                    file_issues[issue.file] = []\\\\n                file_issues[issue.file].append(issue)\\\\n\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> list[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            list[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n        )\\\\n\\\\n        return sorted_issues[:limit]\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html, json)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n        return {\\\\n            \\\\\\\"summary\\\\\\\": review.summary,\\\\n            \\\\\\\"score\\\\\\\": review.score,\\\\n            \\\\\\\"total_issues\\\\\\\": len(review.issues),\\\\n            \\\\\\\"severity_counts\\\\\\\": severity_counts,\\\\n            \\\\\\\"type_counts\\\\\\\": type_counts,\\\\n            \\\\\\\"most_critical_issues\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"type\\\\\\\": issue.type,\\\\n                    \\\\\\\"severity\\\\\\\": issue.severity,\\\\n                    \\\\\\\"description\\\\\\\": issue.description,\\\\n                }\\\\n                for issue in most_critical\\\\n            ],\\\\n            \\\\\\\"recommendations\\\\\\\": review.recommendations,\\\\n        }\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"ReviewPostProcessor: 리뷰 결과를 후처리하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 11, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"ReviewAnalyzer 클래스와 get_review_summary 메서드가 ReviewPostProcessor에서 제거되었습니다. 이로 인해 리뷰 결과를 분석하는 기능(예: 심각도/유형별 이슈 수 계산, 중요 이슈 찾기)이 사라졌습니다. 만약 이 분석 기능이 여전히 필요하다면, 다른 곳에서 재구현하거나 처리해야 합니다. 이 변경은 ReviewPostProcessor의 목적과 기능을 크게 변화시킵니다.\", \"suggestion\": \"분석 기능이 여전히 필요하다면 ReviewAnalyzer와 get_review_summary 메서드를 유지하거나, 분석 로직을 ReviewResponse를 사용하는 다른 모듈/클래스로 이동시키는 것을 고려하세요. 기능이 의도적으로 제거된 것이라면, 커밋 메시지와 문서를 통해 이 변경 사항을 명확히 알리세요.\", \"severity\": \"warning\", \"original_code\": \"class ReviewPostProcessor:\\n    \\\"\\\"\\\"리뷰 후처리기 클래스\\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.formatter = ReviewFormatter()\\n        self.analyzer = ReviewAnalyzer()\", \"improved_code\": \"class ReviewPostProcessor:\\n    \\\"\\\"\\\"리뷰 후처리기 클래스\\\"\\\"\\\"\\n\\n    def __init__(self) -> None:\\n        self.formatter = ReviewFormatter()\"}, {\"type\": \"설계\", \"line_number\": 25, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"process_review 메서드에서 'json' 출력 형식 지원이 제거되었습니다. 이로 인해 해당 클래스를 사용하는 코드가 JSON 출력을 기대하고 있었다면 호환성이 깨질 수 있습니다.\", \"suggestion\": \"'json' 출력이 여전히 필요한 기능이라면 process_review 메서드에 'json' 케이스를 복원하고 docstring을 업데이트하세요. 의도적으로 제거된 것이라면, 이 변경 사항을 문서화하세요.\", \"severity\": \"warning\", \"original_code\": \"    def process_review(\\n        self, review: ReviewResponse, output_format: str = \\\"markdown\\\"\\n    ) -> str:\\n        \\\"\\\"\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\n\\n        Args:\\n            review: 리뷰 응답 객체\\n            output_format: 출력 형식 (markdown, html, json)\\n\\n        Returns:\\n            str: 변환된 리뷰 결과\\n        \\\"\\\"\\\"\\n        if output_format == \\\"markdown\\\":\\n            return self.formatter.to_markdown(review)\\n        elif output_format == \\\"html\\\":\\n            return self.formatter.to_html(review)\\n        elif output_format == \\\"json\\\":\\n            return self.formatter.to_json(review)\\n        else:\\n            raise ValueError(f\\\"지원하지 않는 출력 형식: {output_format}\\\")\", \"improved_code\": \"    def process_review(\\n        self, review: ReviewResponse, output_format: str = \\\"markdown\\\"\\n    ) -> str:\\n        \\\"\\\"\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\n\\n        Args:\\n            review: 리뷰 응답 객체\\n            output_format: 출력 형식 (markdown, html)\\n\\n        Returns:\\n            str: 변환된 리뷰 결과\\n        \\\"\\\"\\\"\\n        if output_format == \\\"markdown\\\":\\n            return self.formatter.to_markdown(review)\\n        elif output_format == \\\"html\\\":\\n            return self.formatter.to_html(review)\\n        else:\\n            raise ValueError(f\\\"지원하지 않는 출력 형식: {output_format}\\\")\"}], \"summary\": \"ReviewPostProcessor 클래스에서 ReviewAnalyzer 의존성 및 관련 분석 기능(get_review_summary 메서드)과 JSON 출력 형식이 제거되었습니다. 이는 클래스의 기능을 단순화하지만, 기존에 해당 기능을 사용하던 코드에 영향을 줄 수 있는 주요 변경 사항입니다.\", \"score\": 7.0, \"recommendations\": [\"제거된 분석 기능과 JSON 출력 형식이 더 이상 필요 없는지 확인하고, 필요하다면 다른 곳에서 처리하도록 변경하세요.\", \"이 변경 사항이 하위 호환성을 깨뜨릴 수 있으므로, 관련 문서와 커밋 메시지에 명확히 기록하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"file_content\\\": \\\"import html\\\\nimport json\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_json(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 JSON 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: JSON 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return json.dumps(review.model_dump(), indent=2, ensure_ascii=False)\\\\n\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, list[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n                if issue.file not in file_issues:\\\\n                    file_issues[issue.file] = []\\\\n                file_issues[issue.file].append(issue)\\\\n\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> list[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            list[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n        )\\\\n\\\\n        return sorted_issues[:limit]\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html, json)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n        return {\\\\n            \\\\\\\"summary\\\\\\\": review.summary,\\\\n            \\\\\\\"score\\\\\\\": review.score,\\\\n            \\\\\\\"total_issues\\\\\\\": len(review.issues),\\\\n            \\\\\\\"severity_counts\\\\\\\": severity_counts,\\\\n            \\\\\\\"type_counts\\\\\\\": type_counts,\\\\n            \\\\\\\"most_critical_issues\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"type\\\\\\\": issue.type,\\\\n                    \\\\\\\"severity\\\\\\\": issue.severity,\\\\n                    \\\\\\\"description\\\\\\\": issue.description,\\\\n                }\\\\n                for issue in most_critical\\\\n            ],\\\\n            \\\\\\\"recommendations\\\\\\\": review.recommendations,\\\\n        }\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport html\\\\nimport json\\\\nfrom typing import Any, Dict, List\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport html\\\\nimport json\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> Dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> Dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> Dict[str, List[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, List[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, list[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n```\\\", \\\"line_number\\\": 183}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> List[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            List[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> list[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            list[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n```\\\", \\\"line_number\\\": 239}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self):\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self) -> None:\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 261}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> Dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n```\\\", \\\"line_number\\\": 284}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 187, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"Python 3.9+에서는 `typing.Dict` 대신 내장 타입인 `dict`를 사용하여 타입 힌트를 지정하는 것이 권장됩니다 (PEP 585).\", \"suggestion\": \"내장 `dict` 타입을 사용하도록 변경하세요.\", \"severity\": \"info\", \"original_code\": \"    def get_severity_counts(review: ReviewResponse) -> Dict[str, int]:\", \"improved_code\": \"    def get_severity_counts(review: ReviewResponse) -> dict[str, int]:\"}, {\"type\": \"style\", \"line_number\": 203, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"Python 3.9+에서는 `typing.Dict` 대신 내장 타입인 `dict`를 사용하여 타입 힌트를 지정하는 것이 권장됩니다 (PEP 585).\", \"suggestion\": \"내장 `dict` 타입을 사용하도록 변경하세요.\", \"severity\": \"info\", \"original_code\": \"    def get_type_counts(review: ReviewResponse) -> Dict[str, int]:\", \"improved_code\": \"    def get_type_counts(review: ReviewResponse) -> dict[str, int]:\"}, {\"type\": \"style\", \"line_number\": 219, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"Python 3.9+에서는 `typing.Dict` 및 `typing.List` 대신 내장 타입인 `dict`와 `list`를 사용하여 타입 힌트를 지정하는 것이 권장됩니다 (PEP 585).\", \"suggestion\": \"내장 `dict` 및 `list` 타입을 사용하도록 변경하세요.\", \"severity\": \"info\", \"original_code\": \"    def get_file_issues(review: ReviewResponse) -> Dict[str, List[ReviewIssue]]:\", \"improved_code\": \"    def get_file_issues(review: ReviewResponse) -> dict[str, list[ReviewIssue]]:\"}, {\"type\": \"style\", \"line_number\": 242, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"Python 3.9+에서는 `typing.List` 대신 내장 타입인 `list`를 사용하여 타입 힌트를 지정하는 것이 권장됩니다 (PEP 585).\", \"suggestion\": \"내장 `list` 타입을 사용하도록 변경하세요.\", \"severity\": \"info\", \"original_code\": \"    ) -> List[ReviewIssue]:\", \"improved_code\": \"    ) -> list[ReviewIssue]:\"}, {\"type\": \"style\", \"line_number\": 264, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"생성자(`__init__`)는 일반적으로 값을 반환하지 않으므로, 명시적으로 반환 타입 힌트 `-> None`을 추가하는 것이 좋습니다.\", \"suggestion\": \"메서드 시그니처에 `-> None`을 추가하여 반환 타입이 없음을 명시하세요.\", \"severity\": \"info\", \"original_code\": \"    def __init__(self):\", \"improved_code\": \"    def __init__(self) -> None:\"}, {\"type\": \"style\", \"line_number\": 287, \"file\": \"reviewer/src/review_processor.py\", \"description\": \"Python 3.9+에서는 `typing.Dict` 대신 내장 타입인 `dict`를 사용하여 타입 힌트를 지정하는 것이 권장됩니다 (PEP 585).\", \"suggestion\": \"내장 `dict` 타입을 사용하도록 변경하세요.\", \"severity\": \"info\", \"original_code\": \"    def get_review_summary(self, review: ReviewResponse) -> Dict[str, Any]:\", \"improved_code\": \"    def get_review_summary(self, review: ReviewResponse) -> dict[str, Any]:\"}], \"summary\": \"이 변경사항은 코드의 타입 힌트를 Python 3.9+에서 권장되는 PEP 585 스타일(내장 타입 사용)로 업데이트합니다. `typing.Dict`와 `typing.List` 대신 `dict`와 `list`를 사용하고, `__init__` 메서드에 `-> None` 반환 타입 힌트를 추가했습니다. 이는 코드의 가독성과 현대적인 Python 표준 준수성을 향상시킵니다.\", \"score\": 9.0, \"recommendations\": [\"PEP 585 스타일의 타입 힌트를 프로젝트 전반에 걸쳐 일관되게 적용하세요.\", \"모든 메서드에 명확한 반환 타입 힌트를 추가하여 코드의 명확성을 높이세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n```\\\", \\\"line_number\\\": 20}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"line_number\\\": 185}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_ignore_file, load_file_content\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_ignore_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_ignore_file, load_file_content\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_ignore_file, load_file_content\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_ignore_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_ignore_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 17}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass GitDiffMode(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"git diff 동작 모드 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    STAGED = \\\\\\\"staged\\\\\\\"\\\\n    TARGET_COMMIT = \\\\\\\"target_commit\\\\\\\"\\\\n    TARGET_BRANCH = \\\\\\\"target_branch\\\\\\\"\\\\n    UNSTAGED = \\\\\\\"unstaged\\\\\\\"\\\\n\\\\n\\\\nclass GitDiffUtility:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 관련 작업을 위한 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self,\\\\n        repo_path: str,\\\\n        mode: GitDiffMode = GitDiffMode.UNSTAGED,\\\\n        target: str | None = None,\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"GitDiffUtility 초기화\\\\n\\\\n        Args:\\\\n            repo_path (str): Git 저장소 경로\\\\n            mode (GitDiffMode): diff 동작 모드\\\\n            target (str | None): mode에 따른 대상 (commit hash 또는 branch 이름)\\\\n\\\\n        Raises:\\\\n            ValueError: 저장소 경로가 유효하지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.repo_path = repo_path\\\\n        self.mode = mode\\\\n        self.target = target\\\\n\\\\n        # 경로 유효성 검증\\\\n        path = Path(repo_path)\\\\n        if not path.exists() or not (path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n\\\\n    @classmethod\\\\n    def from_args(cls, args) -> \\\\\\\"GitDiffUtility\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수에서 GitDiffUtility 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            args: 명령줄 인수 객체 (repo_path, staged, target_commit, target_branch 속성 포함)\\\\n\\\\n        Returns:\\\\n            GitDiffUtility: 초기화된 유틸리티 인스턴스\\\\n\\\\n        Raises:\\\\n            ValueError: 저장소 경로가 유효하지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mode = GitDiffMode.UNSTAGED\\\\n        target = None\\\\n\\\\n        if getattr(args, \\\\\\\"staged\\\\\\\", False):\\\\n            mode = GitDiffMode.STAGED\\\\n        elif getattr(args, \\\\\\\"target_commit\\\\\\\", None):\\\\n            mode = GitDiffMode.TARGET_COMMIT\\\\n            target = args.target_commit\\\\n        elif getattr(args, \\\\\\\"target_branch\\\\\\\", None):\\\\n            mode = GitDiffMode.TARGET_BRANCH\\\\n            target = args.target_branch\\\\n\\\\n        return cls(repo_path=str(Path(args.repo_path)), mode=mode, target=target)\\\\n\\\\n    def get_diff(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Git diff 명령을 실행하고 결과를 반환합니다.\\\\n\\\\n        Returns:\\\\n            str: git diff 명령의 출력\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", self.repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n        if self.mode == GitDiffMode.STAGED:\\\\n            cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n        elif self.mode == GitDiffMode.TARGET_COMMIT:\\\\n            if not self.target or not self.target.strip():\\\\n                logger.error(\\\\\\\"오류: commit 값이 비어있습니다.\\\\\\\")\\\\n                return \\\\\\\"\\\\\\\"\\\\n            cmd.append(f\\\\\\\"{self.target}..HEAD\\\\\\\")\\\\n        elif self.mode == GitDiffMode.TARGET_BRANCH:\\\\n            if not self.target or not self.target.strip():\\\\n                logger.error(\\\\\\\"오류: branch 값이 비어있습니다.\\\\\\\")\\\\n                return \\\\\\\"\\\\\\\"\\\\n            cmd.append(f\\\\\\\"{self.target}..HEAD\\\\\\\")\\\\n\\\\n        try:\\\\n            process_result = subprocess.run(\\\\n                cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n            )\\\\n            return process_result.stdout\\\\n        except subprocess.CalledProcessError as e:\\\\n            logger.error(\\\\n                f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n            return \\\\\\\"\\\\\\\"\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n            return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport subprocess\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass GitDiffMode(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"git diff 동작 모드 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    STAGED = \\\\\\\"staged\\\\\\\"\\\\n    TARGET_COMMIT = \\\\\\\"target_commit\\\\\\\"\\\\n    TARGET_BRANCH = \\\\\\\"target_branch\\\\\\\"\\\\n    UNSTAGED = \\\\\\\"unstaged\\\\\\\"\\\\n\\\\n\\\\nclass GitDiffUtility:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 관련 작업을 위한 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self,\\\\n        repo_path: str,\\\\n        mode: GitDiffMode = GitDiffMode.UNSTAGED,\\\\n        target: str | None = None,\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"GitDiffUtility 초기화\\\\n\\\\n        Args:\\\\n            repo_path (str): Git 저장소 경로\\\\n            mode (GitDiffMode): diff 동작 모드\\\\n            target (str | None): mode에 따른 대상 (commit hash 또는 branch 이름)\\\\n\\\\n        Raises:\\\\n            ValueError: 저장소 경로가 유효하지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.repo_path = repo_path\\\\n        self.mode = mode\\\\n        self.target = target\\\\n\\\\n        # 경로 유효성 검증\\\\n        path = Path(repo_path)\\\\n        if not path.exists() or not (path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n\\\\n    @classmethod\\\\n    def from_args(cls, args) -> \\\\\\\"GitDiffUtility\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수에서 GitDiffUtility 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            args: 명령줄 인수 객체 (repo_path, staged, target_commit, target_branch 속성 포함)\\\\n\\\\n        Returns:\\\\n            GitDiffUtility: 초기화된 유틸리티 인스턴스\\\\n\\\\n        Raises:\\\\n            ValueError: 저장소 경로가 유효하지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mode = GitDiffMode.UNSTAGED\\\\n        target = None\\\\n\\\\n        if getattr(args, \\\\\\\"staged\\\\\\\", False):\\\\n            mode = GitDiffMode.STAGED\\\\n        elif getattr(args, \\\\\\\"target_commit\\\\\\\", None):\\\\n            mode = GitDiffMode.TARGET_COMMIT\\\\n            target = args.target_commit\\\\n        elif getattr(args, \\\\\\\"target_branch\\\\\\\", None):\\\\n            mode = GitDiffMode.TARGET_BRANCH\\\\n            target = args.target_branch\\\\n\\\\n        return cls(repo_path=str(Path(args.repo_path)), mode=mode, target=target)\\\\n\\\\n    def get_diff(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Git diff 명령을 실행하고 결과를 반환합니다.\\\\n\\\\n        Returns:\\\\n            str: git diff 명령의 출력\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", self.repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n        if self.mode == GitDiffMode.STAGED:\\\\n            cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n        elif self.mode == GitDiffMode.TARGET_COMMIT:\\\\n            if not self.target or not self.target.strip():\\\\n                logger.error(\\\\\\\"오류: commit 값이 비어있습니다.\\\\\\\")\\\\n                return \\\\\\\"\\\\\\\"\\\\n            cmd.append(f\\\\\\\"{self.target}..HEAD\\\\\\\")\\\\n        elif self.mode == GitDiffMode.TARGET_BRANCH:\\\\n            if not self.target or not self.target.strip():\\\\n                logger.error(\\\\\\\"오류: branch 값이 비어있습니다.\\\\\\\")\\\\n                return \\\\\\\"\\\\\\\"\\\\n            cmd.append(f\\\\\\\"{self.target}..HEAD\\\\\\\")\\\\n\\\\n        try:\\\\n            process_result = subprocess.run(\\\\n                cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n            )\\\\n            return process_result.stdout\\\\n        except subprocess.CalledProcessError as e:\\\\n            logger.error(\\\\n                f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n            return \\\\\\\"\\\\\\\"\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n            return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_git_utils.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"run_git_diff 함수에 대한 단위 테스트 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nimport subprocess\\\\nfrom dataclasses import dataclass\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.git_utils import GitDiffMode, GitDiffUtility\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef git_repo(tmp_path):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"임시 Git 저장소를 생성하고 초기 커밋을 만듭니다.\\\\n\\\\n    Args:\\\\n        tmp_path: pytest의 임시 디렉터리 경로\\\\n\\\\n    Returns:\\\\n        str: 생성된 git 저장소의 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    repo_dir = tmp_path / \\\\\\\"git-repo\\\\\\\"\\\\n    repo_dir.mkdir()\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"init\\\\\\\"], cwd=str(repo_dir), check=True)\\\\n    subprocess.run(\\\\n        [\\\\\\\"git\\\\\\\", \\\\\\\"config\\\\\\\", \\\\\\\"user.email\\\\\\\", \\\\\\\"test@example.com\\\\\\\"], cwd=str(repo_dir)\\\\n    )\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"config\\\\\\\", \\\\\\\"user.name\\\\\\\", \\\\\\\"Test User\\\\\\\"], cwd=str(repo_dir))\\\\n\\\\n    file_path = repo_dir / \\\\\\\"file.txt\\\\\\\"\\\\n    file_path.write_text(\\\\\\\"Initial content\\\\\\\")\\\\n\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\".\\\\\\\"], cwd=str(repo_dir), check=True)\\\\n    subprocess.run(\\\\n        [\\\\\\\"git\\\\\\\", \\\\\\\"commit\\\\\\\", \\\\\\\"-m\\\\\\\", \\\\\\\"Initial commit\\\\\\\"], cwd=str(repo_dir), check=True\\\\n    )\\\\n\\\\n    return str(repo_dir)\\\\n\\\\n\\\\ndef test_git_diff_utility_with_unstaged_changes(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"스테이징되지 않은 변경사항에 대한 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"Modified content\\\\\\\")\\\\n\\\\n    git_diff = GitDiffUtility(git_repo, mode=GitDiffMode.UNSTAGED)\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+Modified content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_git_diff_utility_with_staged_changes(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"스테이징된 변경사항에 대한 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"Staged content\\\\\\\")\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\"file.txt\\\\\\\"], cwd=git_repo, check=True)\\\\n\\\\n    git_diff = GitDiffUtility(git_repo, mode=GitDiffMode.STAGED)\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+Staged content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_git_diff_utility_with_target_commit(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 커밋과의 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    result = subprocess.run(\\\\n        [\\\\\\\"git\\\\\\\", \\\\\\\"rev-parse\\\\\\\", \\\\\\\"HEAD\\\\\\\"],\\\\n        cwd=git_repo,\\\\n        capture_output=True,\\\\n        text=True,\\\\n        check=True,\\\\n    )\\\\n    initial_commit = result.stdout.strip()\\\\n\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"New commit content\\\\\\\")\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\"file.txt\\\\\\\"], cwd=git_repo, check=True)\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"commit\\\\\\\", \\\\\\\"-m\\\\\\\", \\\\\\\"Second commit\\\\\\\"], cwd=git_repo, check=True)\\\\n\\\\n    git_diff = GitDiffUtility(\\\\n        git_repo, mode=GitDiffMode.TARGET_COMMIT, target=initial_commit\\\\n    )\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+New commit content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_git_diff_utility_with_empty_target_commit(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 target_commit 인자에 대한 예외 처리를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    git_diff = GitDiffUtility(git_repo, mode=GitDiffMode.TARGET_COMMIT, target=\\\\\\\"\\\\\\\")\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert diff == \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef test_git_diff_utility_from_args(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"from_args 메서드로 인스턴스 생성을 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    # 테스트용 Args 클래스 정의\\\\n    @dataclass\\\\n    class MockArgs:\\\\n        repo_path: str\\\\n        staged: bool = False\\\\n        target_commit: str | None = None\\\\n        target_branch: str | None = None\\\\n\\\\n    args = MockArgs(repo_path=git_repo, staged=True)\\\\n\\\\n    git_diff = GitDiffUtility.from_args(args)\\\\n    assert git_diff.mode == GitDiffMode.STAGED\\\\n    assert git_diff.repo_path == git_repo\\\\n    assert git_diff.target is None\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"run_git_diff 함수에 대한 단위 테스트 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nimport subprocess\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.git_utils import run_git_diff\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef git_repo(tmp_path):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"임시 Git 저장소를 생성하고 초기 커밋을 만듭니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"run_git_diff 함수에 대한 단위 테스트 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nimport subprocess\\\\nfrom dataclasses import dataclass\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.git_utils import GitDiffMode, GitDiffUtility\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef git_repo(tmp_path):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"임시 Git 저장소를 생성하고 초기 커밋을 만듭니다.\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    )\\\\n\\\\n    return str(repo_dir)\\\\n\\\\n\\\\ndef test_run_git_diff_with_unstaged_changes(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"스테이징되지 않은 변경사항에 대한 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"Modified content\\\\\\\")\\\\n\\\\n    diff = run_git_diff(git_repo)\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+Modified content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_run_git_diff_with_staged_changes(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"스테이징된 변경사항에 대한 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"Staged content\\\\\\\")\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\"file.txt\\\\\\\"], cwd=git_repo, check=True)\\\\n\\\\n    diff = run_git_diff(git_repo, staged=True)\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+Staged content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_run_git_diff_with_target_commit(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 커밋과의 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    result = subprocess.run(\\\\n        [\\\\\\\"git\\\\\\\", \\\\\\\"rev-parse\\\\\\\", \\\\\\\"HEAD\\\\\\\"],\\\\n        cwd=git_repo,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    )\\\\n\\\\n    return str(repo_dir)\\\\n\\\\n\\\\ndef test_git_diff_utility_with_unstaged_changes(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"스테이징되지 않은 변경사항에 대한 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"Modified content\\\\\\\")\\\\n\\\\n    git_diff = GitDiffUtility(git_repo, mode=GitDiffMode.UNSTAGED)\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+Modified content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_git_diff_utility_with_staged_changes(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"스테이징된 변경사항에 대한 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"Staged content\\\\\\\")\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\"file.txt\\\\\\\"], cwd=git_repo, check=True)\\\\n\\\\n    git_diff = GitDiffUtility(git_repo, mode=GitDiffMode.STAGED)\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+Staged content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_git_diff_utility_with_target_commit(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 커밋과의 diff 결과를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_path = os.path.join(git_repo, \\\\\\\"file.txt\\\\\\\")\\\\n    result = subprocess.run(\\\\n        [\\\\\\\"git\\\\\\\", \\\\\\\"rev-parse\\\\\\\", \\\\\\\"HEAD\\\\\\\"],\\\\n        cwd=git_repo,\\\\n```\\\", \\\"line_number\\\": 36}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"New commit content\\\\\\\")\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\"file.txt\\\\\\\"], cwd=git_repo, check=True)\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"commit\\\\\\\", \\\\\\\"-m\\\\\\\", \\\\\\\"Second commit\\\\\\\"], cwd=git_repo, check=True)\\\\n\\\\n    diff = run_git_diff(git_repo, target_commit=initial_commit)\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+New commit content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_run_git_diff_with_empty_target_commit(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 target_commit 인자에 대한 예외 처리를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    diff = run_git_diff(git_repo, target_commit=\\\\\\\"\\\\\\\")\\\\n    assert diff == \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    with open(file_path, \\\\\\\"w\\\\\\\") as f:\\\\n        f.write(\\\\\\\"New commit content\\\\\\\")\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"add\\\\\\\", \\\\\\\"file.txt\\\\\\\"], cwd=git_repo, check=True)\\\\n    subprocess.run([\\\\\\\"git\\\\\\\", \\\\\\\"commit\\\\\\\", \\\\\\\"-m\\\\\\\", \\\\\\\"Second commit\\\\\\\"], cwd=git_repo, check=True)\\\\n\\\\n    git_diff = GitDiffUtility(\\\\n        git_repo, mode=GitDiffMode.TARGET_COMMIT, target=initial_commit\\\\n    )\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert \\\\\\\"-Initial content\\\\\\\" in diff\\\\n    assert \\\\\\\"+New commit content\\\\\\\" in diff\\\\n\\\\n\\\\ndef test_git_diff_utility_with_empty_target_commit(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 target_commit 인자에 대한 예외 처리를 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    git_diff = GitDiffUtility(git_repo, mode=GitDiffMode.TARGET_COMMIT, target=\\\\\\\"\\\\\\\")\\\\n    diff = git_diff.get_diff()\\\\n\\\\n    assert diff == \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef test_git_diff_utility_from_args(git_repo):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"from_args 메서드로 인스턴스 생성을 검증합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    # 테스트용 Args 클래스 정의\\\\n    @dataclass\\\\n    class MockArgs:\\\\n        repo_path: str\\\\n        staged: bool = False\\\\n        target_commit: str | None = None\\\\n        target_branch: str | None = None\\\\n\\\\n    args = MockArgs(repo_path=git_repo, staged=True)\\\\n\\\\n    git_diff = GitDiffUtility.from_args(args)\\\\n    assert git_diff.mode == GitDiffMode.STAGED\\\\n    assert git_diff.repo_path == git_repo\\\\n    assert git_diff.target is None\\\\n```\\\", \\\"line_number\\\": 80}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 191, \"file\": \"reviewer/cli.py\", \"description\": \"get_diff_content 함수에서 GitDiffUtility 사용 중 ValueError 발생 시, 일반적인 오류 메시지만 로깅하고 빈 문자열을 반환합니다. 이로 인해 사용자는 오류의 구체적인 원인(예: 잘못된 저장소 경로)을 파악하기 어려울 수 있습니다.\", \"suggestion\": \"로깅 메시지에 사용자에게 어떤 조치를 취해야 하는지에 대한 구체적인 안내를 추가하거나, 오류 유형에 따라 다른 메시지를 표시하는 것을 고려해보세요. 예를 들어, 'Git diff 생성 중 오류 발생: {오류 내용}. 저장소 경로가 올바른지, Git이 설치되어 있는지 확인해주세요.' 와 같이 안내할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    except ValueError as e:\\n        logger.error(str(e))\\n        return \\\"\\\"\\n```\", \"improved_code\": \"```python\\n    except ValueError as e:\\n        logger.error(f\\\"Git diff 생성 중 오류 발생: {e}. 저장소 경로가 올바른지, Git이 설치되어 있는지 확인해주세요.\\\")\\n        return \\\"\\\"\\n```\"}, {\"type\": \"설계\", \"line_number\": 56, \"file\": \"reviewer/src/utils/git_utils.py\", \"description\": \"GitDiffUtility.from_args 메서드에서 repo_path를 생성자에 전달할 때 str(Path(args.repo_path))를 사용합니다. args.repo_path가 상대 경로일 수 있으며, 이는 프로그램 실행 위치에 따라 의도치 않은 동작을 유발할 가능성이 있습니다. __init__에서 경로 유효성을 검사하지만, 절대 경로를 사용하면 좀 더 명확하고 예측 가능한 동작을 보장할 수 있습니다.\", \"suggestion\": \"repo_path를 절대 경로로 변환하여 사용하는 것을 고려해보세요. 예를 들어, repo_path=str(Path(args.repo_path).resolve())와 같이 수정할 수 있습니다. 이는 특히 다른 모듈이나 컨텍스트에서 이 유틸리티를 사용할 때 경로 해석의 모호성을 줄일 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        return cls(repo_path=str(Path(args.repo_path)), mode=mode, target=target)\\n```\", \"improved_code\": \"```python\\n        return cls(repo_path=str(Path(args.repo_path).resolve()), mode=mode, target=target)\\n```\"}], \"summary\": \"git diff 관련 로직을 기존 함수 방식에서 GitDiffUtility 클래스를 사용하는 방식으로 리팩토링했습니다. 이 변경으로 코드의 구조, 가독성, 유지보수성이 향상되었으며, 관련 테스트 코드도 새로운 클래스 구조에 맞게 업데이트되었습니다. 전반적으로 코드 품질이 개선된 긍정적인 변경입니다.\", \"score\": 9.5, \"recommendations\": [\"오류 발생 시 사용자에게 제공되는 피드백 메시지를 좀 더 구체적으로 개선하여 사용자가 문제 원인을 쉽게 파악하고 조치할 수 있도록 하는 것을 고려해보세요.\", \"파일 경로 처리 시, 특히 다양한 실행 환경이나 모듈 간의 상호작용을 고려해야 할 때, 절대 경로를 일관되게 사용하여 경로 해석의 모호성을 줄이는 것이 좋습니다 (현재 코드에서는 큰 문제가 없을 수 있으나 일반적인 권장 사항입니다).\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\".cursor/rules/linting-setup.mdc\\\", \\\"file_content\\\": \\\"---\\\\ndescription: Reviewer 프로젝트 린팅 설정\\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer 프로젝트 린팅 설정\\\\n\\\\n## Ruff 설정\\\\n\\\\nReviewer 프로젝트는 Python 린터로 Ruff를 사용합니다. 다음 설정을 통해 코드 품질을 관리합니다:\\\\nㅌㅈ\\\\n### VSCode 설정\\\\n[.vscode/settings.json](mdc:.vscode/settings.json) 파일에 정의된 Ruff 설정:\\\\n\\\\n- 라인 길이: 88자 (Black 스타일)\\\\n- 활성화된 린트 규칙:\\\\n  - `E`: pycodestyle 오류\\\\n  - `F`: Pyflakes 규칙\\\\n  - `I`: isort 규칙\\\\n  - `B`: flake8-bugbear 규칙\\\\n  - `C4`: flake8-comprehensions\\\\n  - `ARG`: flake8-unused-arguments\\\\n  - `N`: PEP8 네이밍 규칙\\\\n  - `UP`: pyupgrade 규칙\\\\n  - `ANN`: flake8-annotations (타입 힌팅)\\\\n  - `S`: flake8-bandit (보안)\\\\n  - `A`: flake8-builtins\\\\n\\\\n### 자동화된 코드 정리\\\\n- 파일 저장 시 자동 포맷팅 적용\\\\n- 자동 import 정리\\\\n- 코드 수정 제안(Code Actions)을 통한 문제 해결\\\\n\\\\n## 타입 체킹\\\\nPython 타입 검사 모드는 `basic`으로 설정되어 있습니다. 이를 통해 타입 힌팅에 대한 기본적인 검사가 이루어집니다.\\\\n\\\\n## 테스트 설정\\\\n[pytest.ini](mdc:pytest.ini) 파일에서 pytest 설정을 관리합니다:\\\\n- 테스트 경로: `tests/`\\\\n- 테스트 파일 패턴: `test_*.py`\\\\n- 테스트 클래스 패턴: `Test*`\\\\n- 테스트 함수 패턴: `test_*`\\\\n- legacy_tests 디렉토리 무시\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n---\\\\ndescription: \\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer 프로젝트 린팅 설정\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n---\\\\ndescription: Reviewer 프로젝트 린팅 설정\\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer 프로젝트 린팅 설정\\\\n\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\".cursor/rules/models-and-gateways.mdc\\\", \\\"file_content\\\": \\\"---\\\\ndescription: LLM 모델 및 게이트웨이 구조\\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer LLM 모델 및 게이트웨이\\\\n\\\\n## 지원 모델\\\\n\\\\nReviewer는 다음 LLM 모델 제공자를 지원합니다:\\\\n\\\\n### OpenAI 모델\\\\n- `gpt-4o`: GPT-4 Omni 모델\\\\n- `gpt-4.1`: GPT-4.1 모델\\\\n- `o3-mini`: OpenAI의 모델, reasoning에 최적화 (별칭: `o3-mini-high`)\\\\n- `o4-mini`: OpenAI의 모델, reasoning에 최적화 (별칭: `o4-mini-high`)\\\\n\\\\n### Anthropic 모델\\\\n- `claude-3-7-sonnet-20250219`: Claude 3.7 Sonnet 모델 (별칭: `claude-3-7-sonnet`, `claude-3.7-sonnet`)\\\\n\\\\n### Google 모델\\\\n- `gemini-2.5-pro-exp-03-25`: Google의 Gemini 2.5 Pro 모델 (별칭: `gemini-2.5-pro`)\\\\n- `gemini-2.5-flash-preview-04-17`: Google의 Gemini 2.5 Flash 모델 (별칭: `gemini-2.5-flash`)\\\\n\\\\n## 게이트웨이 아키텍처\\\\n\\\\nReviewer는 각 LLM 제공업체의 API와 통신하기 위한 게이트웨이 클래스들을 구현했습니다. 이 게이트웨이 시스템은 팩토리 패턴을 통해 구현되었습니다.\\\\n\\\\n### 게이트웨이 클래스 구조\\\\n\\\\n```\\\\nBaseGateway (추상 클래스)\\\\n├── OpenAIGateway\\\\n├── ClaudeGateway\\\\n└── GoogleGateway\\\\n```\\\\n\\\\n- [BaseGateway](mdc:reviewer/src/llm_gateway/base_gateway.py): 모든 게이트웨이의 기본 기능을 정의한 추상 클래스\\\\n- [OpenAIGateway](mdc:reviewer/src/llm_gateway/openai_gateway.py): OpenAI API와 통신하기 위한 게이트웨이\\\\n- [ClaudeGateway](mdc:reviewer/src/llm_gateway/claude_gateway.py): Anthropic Claude API와 통신하기 위한 게이트웨이\\\\n- [GoogleGateway](mdc:reviewer/src/llm_gateway/google_gateway.py): Google AI Studio API와 통신하기 위한 게이트웨이\\\\n\\\\n### 팩토리 패턴\\\\n\\\\n[GatewayFactory](mdc:reviewer/src/llm_gateway/gateway_factory.py) 클래스는 모델 이름에 따라 적절한 게이트웨이 인스턴스를 생성합니다:\\\\n\\\\n```python\\\\n# 게이트웨이 생성 예시\\\\nfactory = GatewayFactory()\\\\ngateway = factory.create(\\\\\\\"gpt-4o\\\\\\\")  # OpenAIGateway 인스턴스 반환\\\\ngateway = factory.create(\\\\\\\"claude-3.7-sonnet\\\\\\\")  # ClaudeGateway 인스턴스 반환\\\\ngateway = factory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")  # GoogleGateway 인스턴스 반환\\\\n```\\\\n\\\\n## 모델 정보 관리\\\\n\\\\n[available_models.py](mdc:reviewer/src/available_models.py) 모듈은 지원되는 모든 모델의 정보를 관리합니다:\\\\n\\\\n```python\\\\n# 모델 정보 예시\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    # 기타 모델 정보...\\\\n}\\\\n```\\\\n\\\\n- `full_name`: 모델의 정식 이름\\\\n- `aliases`: 모델의 별칭 목록\\\\n- `description`: 모델 설명\\\\n- `provider`: 모델 제공자 (\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\" 중 하나)\\\\n- `params`: 모델별 파라미터 (temperature, reasoning_effort 등)\\\\n\\\\n## 게이트웨이 핵심 기능\\\\n\\\\n각 게이트웨이는 다음과 같은 공통 기능을 제공합니다:\\\\n\\\\n1. **모델 설정**: 모델 이름, 파라미터 설정\\\\n2. **API 키 관리**: 각 제공자별 API 키 검증 및 관리\\\\n3. **프롬프트 생성**: 코드 리뷰를 위한 프롬프트 생성\\\\n4. **API 요청**: 각 제공자의 API에 맞는 요청 생성 및 전송\\\\n5. **응답 처리**: API 응답을 파싱하고 구조화된 형식으로 변환\\\\n6. **에러 처리**: API 오류, 타임아웃 등의 예외 처리\\\\n\\\\n## 코드 리뷰 프로세스\\\\n\\\\n게이트웨이를 사용한 코드 리뷰 프로세스는 다음과 같습니다:\\\\n\\\\n1. 사용자가 특정 모델을 지정하여 코드 리뷰 요청\\\\n2. `GatewayFactory`를 통해 적절한 게이트웨이 인스턴스 생성\\\\n3. 게이트웨이 객체가 코드 diff와 메타데이터를 사용하여 프롬프트 생성\\\\n4. 해당 모델의 API에 요청 전송\\\\n5. API 응답을 파싱하여 구조화된 리뷰 결과 생성\\\\n6. 결과를 사용자에게 반환\\\\n\\\\n## 사용 예시\\\\n\\\\n```python\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.models import ReviewRequest\\\\n\\\\n# 리뷰 요청 생성\\\\nrequest = ReviewRequest(\\\\n    diff_content=\\\\\\\"...\\\\\\\",\\\\n    file_paths=[\\\\\\\"main.py\\\\\\\", \\\\\\\"utils.py\\\\\\\"],\\\\n    language=\\\\\\\"python\\\\\\\"\\\\n)\\\\n\\\\n# 팩토리를 통한 게이트웨이 생성\\\\nfactory = GatewayFactory()\\\\ngateway = factory.create(\\\\\\\"gpt-4o\\\\\\\")  # OpenAI 모델 사용\\\\n\\\\n# 코드 리뷰 실행\\\\nreview_result = gateway.review_code(request)\\\\n\\\\n# 결과 출력\\\\nprint(review_result.suggestions)\\\\n```\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n---\\\\ndescription: \\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer LLM 모델 및 게이트웨이\\\\n\\\\n## 지원 모델\\\\n\\\\nReviewer는 다음 LLM 모델 제공자를 지원합니다:\\\\n\\\\n### OpenAI 모델\\\\n- GPT-4o\\\\n- GPT-4o-mini\\\\n- GPT-4-turbo\\\\n- GPT-3.5-turbo\\\\n\\\\n### Anthropic 모델\\\\n- Claude 3.7 Sonnet\\\\n- Claude 3.5 Sonnet\\\\n- Claude 3 Opus\\\\n\\\\n## 게이트웨이 구조\\\\n\\\\n[reviewer/src/llm_gateway.py](mdc:reviewer/src/llm_gateway.py)에서 정의된 LLM 게이트웨이는 다음 클래스로 구성됩니다:\\\\n\\\\n1. `OpenAIGateway`: OpenAI API와 통신하기 위한 게이트웨이\\\\n2. `ClaudeGateway`: Anthropic Claude API와 통신하기 위한 게이트웨이\\\\n\\\\n각 게이트웨이는 다음 주요 기능을 제공합니다:\\\\n\\\\n- 모델 설정 및 관리\\\\n- API 키 검증\\\\n- 프롬프트 생성\\\\n- 토큰 사용량 및 비용 추정\\\\n- API 요청 생성 및 처리\\\\n- 응답 파싱 및 구조화\\\\n\\\\n## 모델 정보 관리\\\\n\\\\n[reviewer/src/available_models.py](mdc:reviewer/src/available_models.py)에서 지원되는 모델 정보를 관리합니다:\\\\n\\\\n- 모델 이름 및 별칭\\\\n- 제공자 정보\\\\n- 모델 설명\\\\n- 모델별 파라미터 (온도, 최대 토큰 등)\\\\n\\\\n## 코드 리뷰 프로세스\\\\n\\\\n1. 코드 리뷰 요청이 생성됨\\\\n2. 선택된 모델에 따라 적절한 게이트웨이 인스턴스 생성\\\\n3. 코드 diff 내용을 프롬프트로 변환\\\\n4. API를 통해 LLM 모델에 요청 전송\\\\n5. 응답을 구조화된 리뷰 포맷으로 파싱\\\\n6. 사용자에게 리뷰 결과 제공\\\\n\\\\n## 사용 예시\\\\n\\\\n모델 사용 시 다음 패턴을 따릅니다:\\\\n\\\\n`​``python\\\\nfrom reviewer.src.llm_gateway import get_llm_gateway\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 게이트웨이 인스턴스 생성\\\\ngateway = get_llm_gateway(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n# 리뷰 요청 생성\\\\nrequest = ReviewRequest(\\\\n    diff_content=\\\\\\\"...\\\\\\\",\\\\n    file_paths=[\\\\\\\"file1.py\\\\\\\", \\\\\\\"file2.py\\\\\\\"],\\\\n    language=\\\\\\\"python\\\\\\\"\\\\n)\\\\n\\\\n# 코드 리뷰 실행\\\\nreview_result = gateway.review_code(request)\\\\n`​``\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n---\\\\ndescription: LLM 모델 및 게이트웨이 구조\\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer LLM 모델 및 게이트웨이\\\\n\\\\n## 지원 모델\\\\n\\\\nReviewer는 다음 LLM 모델 제공자를 지원합니다:\\\\n\\\\n### OpenAI 모델\\\\n- `gpt-4o`: GPT-4 Omni 모델\\\\n- `gpt-4.1`: GPT-4.1 모델\\\\n- `o3-mini`: OpenAI의 모델, reasoning에 최적화 (별칭: `o3-mini-high`)\\\\n- `o4-mini`: OpenAI의 모델, reasoning에 최적화 (별칭: `o4-mini-high`)\\\\n\\\\n### Anthropic 모델\\\\n- `claude-3-7-sonnet-20250219`: Claude 3.7 Sonnet 모델 (별칭: `claude-3-7-sonnet`, `claude-3.7-sonnet`)\\\\n\\\\n### Google 모델\\\\n- `gemini-2.5-pro-exp-03-25`: Google의 Gemini 2.5 Pro 모델 (별칭: `gemini-2.5-pro`)\\\\n- `gemini-2.5-flash-preview-04-17`: Google의 Gemini 2.5 Flash 모델 (별칭: `gemini-2.5-flash`)\\\\n\\\\n## 게이트웨이 아키텍처\\\\n\\\\nReviewer는 각 LLM 제공업체의 API와 통신하기 위한 게이트웨이 클래스들을 구현했습니다. 이 게이트웨이 시스템은 팩토리 패턴을 통해 구현되었습니다.\\\\n\\\\n### 게이트웨이 클래스 구조\\\\n\\\\n`​``\\\\nBaseGateway (추상 클래스)\\\\n├── OpenAIGateway\\\\n├── ClaudeGateway\\\\n└── GoogleGateway\\\\n`​``\\\\n\\\\n- [BaseGateway](mdc:reviewer/src/llm_gateway/base_gateway.py): 모든 게이트웨이의 기본 기능을 정의한 추상 클래스\\\\n- [OpenAIGateway](mdc:reviewer/src/llm_gateway/openai_gateway.py): OpenAI API와 통신하기 위한 게이트웨이\\\\n- [ClaudeGateway](mdc:reviewer/src/llm_gateway/claude_gateway.py): Anthropic Claude API와 통신하기 위한 게이트웨이\\\\n- [GoogleGateway](mdc:reviewer/src/llm_gateway/google_gateway.py): Google AI Studio API와 통신하기 위한 게이트웨이\\\\n\\\\n### 팩토리 패턴\\\\n\\\\n[GatewayFactory](mdc:reviewer/src/llm_gateway/gateway_factory.py) 클래스는 모델 이름에 따라 적절한 게이트웨이 인스턴스를 생성합니다:\\\\n\\\\n`​``python\\\\n# 게이트웨이 생성 예시\\\\nfactory = GatewayFactory()\\\\ngateway = factory.create(\\\\\\\"gpt-4o\\\\\\\")  # OpenAIGateway 인스턴스 반환\\\\ngateway = factory.create(\\\\\\\"claude-3.7-sonnet\\\\\\\")  # ClaudeGateway 인스턴스 반환\\\\ngateway = factory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")  # GoogleGateway 인스턴스 반환\\\\n`​``\\\\n\\\\n## 모델 정보 관리\\\\n\\\\n[available_models.py](mdc:reviewer/src/available_models.py) 모듈은 지원되는 모든 모델의 정보를 관리합니다:\\\\n\\\\n`​``python\\\\n# 모델 정보 예시\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    # 기타 모델 정보...\\\\n}\\\\n`​``\\\\n\\\\n- `full_name`: 모델의 정식 이름\\\\n- `aliases`: 모델의 별칭 목록\\\\n- `description`: 모델 설명\\\\n- `provider`: 모델 제공자 (\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\" 중 하나)\\\\n- `params`: 모델별 파라미터 (temperature, reasoning_effort 등)\\\\n\\\\n## 게이트웨이 핵심 기능\\\\n\\\\n각 게이트웨이는 다음과 같은 공통 기능을 제공합니다:\\\\n\\\\n1. **모델 설정**: 모델 이름, 파라미터 설정\\\\n2. **API 키 관리**: 각 제공자별 API 키 검증 및 관리\\\\n3. **프롬프트 생성**: 코드 리뷰를 위한 프롬프트 생성\\\\n4. **API 요청**: 각 제공자의 API에 맞는 요청 생성 및 전송\\\\n5. **응답 처리**: API 응답을 파싱하고 구조화된 형식으로 변환\\\\n6. **에러 처리**: API 오류, 타임아웃 등의 예외 처리\\\\n\\\\n## 코드 리뷰 프로세스\\\\n\\\\n게이트웨이를 사용한 코드 리뷰 프로세스는 다음과 같습니다:\\\\n\\\\n1. 사용자가 특정 모델을 지정하여 코드 리뷰 요청\\\\n2. `GatewayFactory`를 통해 적절한 게이트웨이 인스턴스 생성\\\\n3. 게이트웨이 객체가 코드 diff와 메타데이터를 사용하여 프롬프트 생성\\\\n4. 해당 모델의 API에 요청 전송\\\\n5. API 응답을 파싱하여 구조화된 리뷰 결과 생성\\\\n6. 결과를 사용자에게 반환\\\\n\\\\n## 사용 예시\\\\n\\\\n`​``python\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.models import ReviewRequest\\\\n\\\\n# 리뷰 요청 생성\\\\nrequest = ReviewRequest(\\\\n    diff_content=\\\\\\\"...\\\\\\\",\\\\n    file_paths=[\\\\\\\"main.py\\\\\\\", \\\\\\\"utils.py\\\\\\\"],\\\\n    language=\\\\\\\"python\\\\\\\"\\\\n)\\\\n\\\\n# 팩토리를 통한 게이트웨이 생성\\\\nfactory = GatewayFactory()\\\\ngateway = factory.create(\\\\\\\"gpt-4o\\\\\\\")  # OpenAI 모델 사용\\\\n\\\\n# 코드 리뷰 실행\\\\nreview_result = gateway.review_code(request)\\\\n\\\\n# 결과 출력\\\\nprint(review_result.suggestions)\\\\n`​``\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\".cursor/rules/project-structure.mdc\\\", \\\"file_content\\\": \\\"---\\\\ndescription: 프로젝트 개요 및 프로젝트 구조\\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer - AI 기반 코드 리뷰 도구 구조\\\\n\\\\n## 프로젝트 개요\\\\nReviewer는 AI를 활용하여 코드 리뷰를 자동화하는 도구입니다. OpenAI, Anthropic, Google의 LLM 모델을 사용하여 코드를 분석하고 개선점, 버그, 보안 취약점 등을 찾아 제공합니다.\\\\n\\\\n## 디렉토리 구조\\\\n- `reviewer/`: 메인 패키지\\\\n  - `src/`: 핵심 소스 코드\\\\n    - `llm_gateway/`: LLM 게이트웨이 모듈\\\\n    - `diff_parser/`: 코드 diff 파싱 로직\\\\n    - `exceptions/`: 예외 클래스 모음\\\\n    - `utils/`: 유틸리티 함수 및 클래스\\\\n      - `token/`: 토큰 관련 유틸리티 및 모델\\\\n      - `prompts/`: 프롬프트 생성 및 관리\\\\n      - `logging/`: 로깅 설정 및 관리\\\\n  - `cli.py`: 명령줄 인터페이스\\\\n- `tests/`: 테스트 코드\\\\n- `sample_data/`: 샘플 데이터\\\\n- `logs/`: 로그 저장 디렉토리\\\\n- `resources/`: 리소스 파일\\\\n\\\\n## 주요 파일\\\\n- [setup.py](mdc:setup.py): 패키지 설정 및 의존성 관리\\\\n- [requirements.txt](mdc:requirements.txt): 프로덕션 의존성\\\\n- [requirements-dev.txt](mdc:requirements-dev.txt): 개발 의존성\\\\n- [pyproject.toml](mdc:pyproject.toml): 프로젝트 메타데이터\\\\n- [pytest.ini](mdc:pytest.ini): pytest 설정\\\\n\\\\n## 핵심 모듈\\\\n- [reviewer/cli.py](mdc:reviewer/cli.py): 명령줄 인터페이스 및 진입점\\\\n- [reviewer/src/llm_gateway/base_gateway.py](mdc:reviewer/src/llm_gateway/base_gateway.py): LLM 게이트웨이 기본 클래스\\\\n- [reviewer/src/llm_gateway/gateway_factory.py](mdc:reviewer/src/llm_gateway/gateway_factory.py): 게이트웨이 팩토리 패턴 구현\\\\n- [reviewer/src/available_models.py](mdc:reviewer/src/available_models.py): 지원되는 AI 모델 정의\\\\n- [reviewer/src/config.py](mdc:reviewer/src/config.py): 설정 관리\\\\n- [reviewer/src/review_processor.py](mdc:reviewer/src/review_processor.py): 코드 리뷰 처리 로직\\\\n- [reviewer/src/ui.py](mdc:reviewer/src/ui.py): 리뷰 결과 UI 인터페이스\\\\n\\\\n## 게이트웨이 모듈\\\\n- [reviewer/src/llm_gateway/openai_gateway.py](mdc:reviewer/src/llm_gateway/openai_gateway.py): OpenAI API 게이트웨이\\\\n- [reviewer/src/llm_gateway/claude_gateway.py](mdc:reviewer/src/llm_gateway/claude_gateway.py): Anthropic Claude API 게이트웨이\\\\n- [reviewer/src/llm_gateway/google_gateway.py](mdc:reviewer/src/llm_gateway/google_gateway.py): Google AI API 게이트웨이\\\\n\\\\n## 유틸리티 모듈\\\\n- [reviewer/src/utils/file_utils.py](mdc:reviewer/src/utils/file_utils.py): 파일 처리 유틸리티 함수\\\\n- [reviewer/src/utils/git_utils.py](mdc:reviewer/src/utils/git_utils.py): Git 관련 작업 유틸리티\\\\n- [reviewer/src/utils/prompt_utils.py](mdc:reviewer/src/utils/prompt_utils.py): 프롬프트 처리 유틸리티\\\\n- [reviewer/src/utils/llm_factory.py](mdc:reviewer/src/utils/llm_factory.py): LLM 팩토리 유틸리티\\\\n\\\\n### 토큰 관련 유틸리티\\\\n- [reviewer/src/utils/token/token_utils.py](mdc:reviewer/src/utils/token/token_utils.py): 토큰 처리 유틸리티\\\\n- [reviewer/src/utils/token/models.py](mdc:reviewer/src/utils/token/models.py): 토큰 관련 데이터 모델\\\\n\\\\n### 프롬프트 관련 유틸리티\\\\n- [reviewer/src/utils/prompts/prompt_generator.py](mdc:reviewer/src/utils/prompts/prompt_generator.py): 프롬프트 생성 로직\\\\n- [reviewer/src/utils/prompts/models/system_prompt.py](mdc:reviewer/src/utils/prompts/models/system_prompt.py): 시스템 프롬프트 모델\\\\n- [reviewer/src/utils/prompts/models/user_prompt.py](mdc:reviewer/src/utils/prompts/models/user_prompt.py): 사용자 프롬프트 모델\\\\n- [reviewer/src/utils/prompts/models/review_prompt.py](mdc:reviewer/src/utils/prompts/models/review_prompt.py): 리뷰 프롬프트 모델\\\\n\\\\n### 로깅 관련 유틸리티\\\\n- [reviewer/src/utils/logging/config.py](mdc:reviewer/src/utils/logging/config.py): 로깅 설정 및 구성\\\\n\\\\n## 테스트\\\\n- [tests/test_llm_gateway.py](mdc:tests/test_llm_gateway.py): LLM 게이트웨이 기본 테스트\\\\n- [tests/test_llm_gateway_request.py](mdc:tests/test_llm_gateway_request.py): 게이트웨이 요청 테스트\\\\n- [tests/test_llm_gateway_review_code.py](mdc:tests/test_llm_gateway_review_code.py): 코드 리뷰 기능 테스트\\\\n- [tests/test_diff_parser.py](mdc:tests/test_diff_parser.py): 디프 파서 테스트\\\\n- [tests/test_prompt_generator.py](mdc:tests/test_prompt_generator.py): 프롬프트 생성 테스트\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n---\\\\ndescription: \\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer - AI 기반 코드 리뷰 도구 구조\\\\n\\\\n## 프로젝트 개요\\\\nReviewer는 AI를 활용하여 코드 리뷰를 자동화하는 도구입니다. OpenAI와 Anthropic의 LLM 모델을 사용하여 코드를 분석하고 개선점, 버그, 보안 취약점 등을 찾아 제공합니다.\\\\n\\\\n## 디렉토리 구조\\\\n- `reviewer/`: 메인 패키지\\\\n  - `src/`: 핵심 소스 코드\\\\n  - `cli.py`: 명령줄 인터페이스ㅌㅈ\\\\n- `tests/`: 테스트 코드\\\\n- `sample_data/`: 샘플 데이터ㅌㅈ\\\\n- `logs/`: 로그 저장 디렉토리\\\\n\\\\n## 주요 파일\\\\n- [setup.py](mdc:setup.py): 패키지 설정 및 의존성 관리\\\\n- [requirements.txt](mdc:requirements.txt): 프로덕션 의존성\\\\n- [requirements-dev.txt](mdc:requirements-dev.txt): 개발 의존성\\\\n- [pyproject.toml](mdc:pyproject.toml): 프로젝트 메타데이터\\\\n- [pytest.ini](mdc:pytest.ini): pytest 설정\\\\n\\\\n## 핵심 모듈\\\\n- [reviewer/src/llm_gateway.py](mdc:reviewer/src/llm_gateway.py): LLM API와의 통신 관리\\\\n- [reviewer/src/available_models.py](mdc:reviewer/src/available_models.py): 지원되는 AI 모델 정의\\\\n- [reviewer/src/config.py](mdc:reviewer/src/config.py): 설정 관리\\\\n- [reviewer/src/review_processor.py](mdc:reviewer/src/review_processor.py): 코드 리뷰 처리 로직\\\\n- [reviewer/src/ui.py](mdc:reviewer/src/ui.py): 리뷰 결과 UI 인터페이스\\\\n\\\\n## 테스트\\\\n- [tests/test_llm_gateway.py](mdc:tests/test_llm_gateway.py): LLM 게이트웨이 테스트\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n---\\\\ndescription: 프로젝트 개요 및 프로젝트 구조\\\\nglobs: \\\\nalwaysApply: false\\\\n---\\\\n# Reviewer - AI 기반 코드 리뷰 도구 구조\\\\n\\\\n## 프로젝트 개요\\\\nReviewer는 AI를 활용하여 코드 리뷰를 자동화하는 도구입니다. OpenAI, Anthropic, Google의 LLM 모델을 사용하여 코드를 분석하고 개선점, 버그, 보안 취약점 등을 찾아 제공합니다.\\\\n\\\\n## 디렉토리 구조\\\\n- `reviewer/`: 메인 패키지\\\\n  - `src/`: 핵심 소스 코드\\\\n    - `llm_gateway/`: LLM 게이트웨이 모듈\\\\n    - `diff_parser/`: 코드 diff 파싱 로직\\\\n    - `exceptions/`: 예외 클래스 모음\\\\n    - `utils/`: 유틸리티 함수 및 클래스\\\\n      - `token/`: 토큰 관련 유틸리티 및 모델\\\\n      - `prompts/`: 프롬프트 생성 및 관리\\\\n      - `logging/`: 로깅 설정 및 관리\\\\n  - `cli.py`: 명령줄 인터페이스\\\\n- `tests/`: 테스트 코드\\\\n- `sample_data/`: 샘플 데이터\\\\n- `logs/`: 로그 저장 디렉토리\\\\n- `resources/`: 리소스 파일\\\\n\\\\n## 주요 파일\\\\n- [setup.py](mdc:setup.py): 패키지 설정 및 의존성 관리\\\\n- [requirements.txt](mdc:requirements.txt): 프로덕션 의존성\\\\n- [requirements-dev.txt](mdc:requirements-dev.txt): 개발 의존성\\\\n- [pyproject.toml](mdc:pyproject.toml): 프로젝트 메타데이터\\\\n- [pytest.ini](mdc:pytest.ini): pytest 설정\\\\n\\\\n## 핵심 모듈\\\\n- [reviewer/cli.py](mdc:reviewer/cli.py): 명령줄 인터페이스 및 진입점\\\\n- [reviewer/src/llm_gateway/base_gateway.py](mdc:reviewer/src/llm_gateway/base_gateway.py): LLM 게이트웨이 기본 클래스\\\\n- [reviewer/src/llm_gateway/gateway_factory.py](mdc:reviewer/src/llm_gateway/gateway_factory.py): 게이트웨이 팩토리 패턴 구현\\\\n- [reviewer/src/available_models.py](mdc:reviewer/src/available_models.py): 지원되는 AI 모델 정의\\\\n- [reviewer/src/config.py](mdc:reviewer/src/config.py): 설정 관리\\\\n- [reviewer/src/review_processor.py](mdc:reviewer/src/review_processor.py): 코드 리뷰 처리 로직\\\\n- [reviewer/src/ui.py](mdc:reviewer/src/ui.py): 리뷰 결과 UI 인터페이스\\\\n\\\\n## 게이트웨이 모듈\\\\n- [reviewer/src/llm_gateway/openai_gateway.py](mdc:reviewer/src/llm_gateway/openai_gateway.py): OpenAI API 게이트웨이\\\\n- [reviewer/src/llm_gateway/claude_gateway.py](mdc:reviewer/src/llm_gateway/claude_gateway.py): Anthropic Claude API 게이트웨이\\\\n- [reviewer/src/llm_gateway/google_gateway.py](mdc:reviewer/src/llm_gateway/google_gateway.py): Google AI API 게이트웨이\\\\n\\\\n## 유틸리티 모듈\\\\n- [reviewer/src/utils/file_utils.py](mdc:reviewer/src/utils/file_utils.py): 파일 처리 유틸리티 함수\\\\n- [reviewer/src/utils/git_utils.py](mdc:reviewer/src/utils/git_utils.py): Git 관련 작업 유틸리티\\\\n- [reviewer/src/utils/prompt_utils.py](mdc:reviewer/src/utils/prompt_utils.py): 프롬프트 처리 유틸리티\\\\n- [reviewer/src/utils/llm_factory.py](mdc:reviewer/src/utils/llm_factory.py): LLM 팩토리 유틸리티\\\\n\\\\n### 토큰 관련 유틸리티\\\\n- [reviewer/src/utils/token/token_utils.py](mdc:reviewer/src/utils/token/token_utils.py): 토큰 처리 유틸리티\\\\n- [reviewer/src/utils/token/models.py](mdc:reviewer/src/utils/token/models.py): 토큰 관련 데이터 모델\\\\n\\\\n### 프롬프트 관련 유틸리티\\\\n- [reviewer/src/utils/prompts/prompt_generator.py](mdc:reviewer/src/utils/prompts/prompt_generator.py): 프롬프트 생성 로직\\\\n- [reviewer/src/utils/prompts/models/system_prompt.py](mdc:reviewer/src/utils/prompts/models/system_prompt.py): 시스템 프롬프트 모델\\\\n- [reviewer/src/utils/prompts/models/user_prompt.py](mdc:reviewer/src/utils/prompts/models/user_prompt.py): 사용자 프롬프트 모델\\\\n- [reviewer/src/utils/prompts/models/review_prompt.py](mdc:reviewer/src/utils/prompts/models/review_prompt.py): 리뷰 프롬프트 모델\\\\n\\\\n### 로깅 관련 유틸리티\\\\n- [reviewer/src/utils/logging/config.py](mdc:reviewer/src/utils/logging/config.py): 로깅 설정 및 구성\\\\n\\\\n## 테스트\\\\n- [tests/test_llm_gateway.py](mdc:tests/test_llm_gateway.py): LLM 게이트웨이 기본 테스트\\\\n- [tests/test_llm_gateway_request.py](mdc:tests/test_llm_gateway_request.py): 게이트웨이 요청 테스트\\\\n- [tests/test_llm_gateway_review_code.py](mdc:tests/test_llm_gateway_review_code.py): 코드 리뷰 기능 테스트\\\\n- [tests/test_diff_parser.py](mdc:tests/test_diff_parser.py): 디프 파서 테스트\\\\n- [tests/test_prompt_generator.py](mdc:tests/test_prompt_generator.py): 프롬프트 생성 테스트\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 9, \"file\": \".cursor/rules/linting-setup.mdc\", \"description\": \"문서 내용에 불필요한 한글 자음/모음(ㅌㅈ)이 포함되어 있습니다. 이는 오타로 보이며, 문서의 가독성을 해칩니다.\", \"suggestion\": \"불필요한 문자를 제거하여 문서 내용을 정리하세요.\", \"severity\": \"info\", \"original_code\": \"-\\n+ㅌㅈ\", \"improved_code\": \"\"}, {\"type\": \"style\", \"line_number\": 12, \"file\": \".cursor/rules/project-structure.mdc\", \"description\": \"문서 내용에 불필요한 한글 자음/모음(ㅌㅈ)이 포함되어 있습니다. 이는 오타로 보이며, 문서의 가독성을 해칩니다.\", \"suggestion\": \"불필요한 문자를 제거하여 문서 내용을 정리하세요.\", \"severity\": \"info\", \"original_code\": \"-  - `cli.py`: 명령줄 인터페이스ㅌㅈ\", \"improved_code\": \"-  - `cli.py`: 명령줄 인터페이스\"}, {\"type\": \"style\", \"line_number\": 14, \"file\": \".cursor/rules/project-structure.mdc\", \"description\": \"문서 내용에 불필요한 한글 자음/모음(ㅌㅈ)이 포함되어 있습니다. 이는 오타로 보이며, 문서의 가독성을 해칩니다.\", \"suggestion\": \"불필요한 문자를 제거하여 문서 내용을 정리하세요.\", \"severity\": \"info\", \"original_code\": \"-`tests/`: 테스트 코드\\n-`sample_data/`: 샘플 데이터ㅌㅈ\", \"improved_code\": \"-`tests/`: 테스트 코드\\n-`sample_data/`: 샘플 데이터\"}], \"summary\": \"이 변경사항은 `.cursor/rules` 디렉토리의 Markdown 문서들을 업데이트합니다. 린팅 설정, LLM 모델 및 게이트웨이 구조, 프로젝트 구조에 대한 설명이 추가 및 개선되었습니다. 특히 LLM 게이트웨이 문서에서는 지원 모델 목록이 구체화되고, 게이트웨이 아키텍처(팩토리 패턴 포함) 및 핵심 기능에 대한 상세 설명이 추가되었습니다. 프로젝트 구조 문서에서는 디렉토리 및 파일 구조가 더 상세하게 기술되었습니다. 또한, 문서 내에 포함된 불필요한 오타(ㅌㅈ)가 제거되었습니다.\", \"score\": 9.5, \"recommendations\": [\"코드 변경 사항에 맞춰 문서를 지속적으로 업데이트하여 최신 상태를 유지하세요.\", \"문서 내 코드 블록의 마크다운 형식이 올바르게 적용되었는지 확인하세요 (예: ```python).\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_ignore_file, load_file_content\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_ignore_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_binary_file, load_file_content\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_ignore_file, load_file_content\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_ignore_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 20}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/file_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n    \\\\\\\".exe\\\\\\\",\\\\n    \\\\\\\".dll\\\\\\\",\\\\n    \\\\\\\".so\\\\\\\",\\\\n    \\\\\\\".dylib\\\\\\\",\\\\n    \\\\\\\".bin\\\\\\\",\\\\n    \\\\\\\".o\\\\\\\",\\\\n    \\\\\\\".obj\\\\\\\",\\\\n    \\\\\\\".a\\\\\\\",\\\\n    \\\\\\\".lib\\\\\\\",\\\\n    # 압축 파일\\\\n    \\\\\\\".zip\\\\\\\",\\\\n    \\\\\\\".tar\\\\\\\",\\\\n    \\\\\\\".gz\\\\\\\",\\\\n    \\\\\\\".bz2\\\\\\\",\\\\n    \\\\\\\".xz\\\\\\\",\\\\n    \\\\\\\".jar\\\\\\\",\\\\n    \\\\\\\".war\\\\\\\",\\\\n    \\\\\\\".ear\\\\\\\",\\\\n    \\\\\\\".aar\\\\\\\",\\\\n    # 이미지 파일\\\\n    \\\\\\\".jpg\\\\\\\",\\\\n    \\\\\\\".jpeg\\\\\\\",\\\\n    \\\\\\\".png\\\\\\\",\\\\n    \\\\\\\".gif\\\\\\\",\\\\n    \\\\\\\".bmp\\\\\\\",\\\\n    \\\\\\\".tiff\\\\\\\",\\\\n    \\\\\\\".ico\\\\\\\",\\\\n    \\\\\\\".webp\\\\\\\",\\\\n    # 비디오/오디오 파일\\\\n    \\\\\\\".mp3\\\\\\\",\\\\n    \\\\\\\".mp4\\\\\\\",\\\\n    \\\\\\\".wav\\\\\\\",\\\\n    \\\\\\\".avi\\\\\\\",\\\\n    \\\\\\\".mov\\\\\\\",\\\\n    \\\\\\\".mkv\\\\\\\",\\\\n    \\\\\\\".flac\\\\\\\",\\\\n    \\\\\\\".ogg\\\\\\\",\\\\n    # 문서 파일\\\\n    \\\\\\\".pdf\\\\\\\",\\\\n    \\\\\\\".doc\\\\\\\",\\\\n    \\\\\\\".docx\\\\\\\",\\\\n    \\\\\\\".ppt\\\\\\\",\\\\n    \\\\\\\".pptx\\\\\\\",\\\\n    \\\\\\\".xls\\\\\\\",\\\\n    \\\\\\\".xlsx\\\\\\\",\\\\n    # 기타 바이너리 파일\\\\n    \\\\\\\".class\\\\\\\",\\\\n    \\\\\\\".pyc\\\\\\\",\\\\n    \\\\\\\".pyo\\\\\\\",\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 바이너리 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n}\\\\n\\\\n# 무시할 텍스트 파일 이름 목록\\\\nIGNORE_FILENAMES = {\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n    \\\\\\\".env.local\\\\\\\",\\\\n    \\\\\\\".env.development\\\\\\\",\\\\n    \\\\\\\".env.production\\\\\\\",\\\\n    \\\\\\\".env.test\\\\\\\",\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_ignore_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 무시해야 할 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 무시해야 할 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 무시해야 할 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return (\\\\n        ext in BINARY_EXTENSIONS\\\\n        or base_name in BINARY_FILENAMES\\\\n        or base_name in IGNORE_FILENAMES\\\\n    )\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[제외 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(\\\\n        f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다. 탐색 완료 경로: {current_dir}\\\\\\\"\\\\n    )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 특수 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 바이너리 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n}\\\\n\\\\n# 무시할 텍스트 파일 이름 목록\\\\nIGNORE_FILENAMES = {\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 59}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_binary_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 바이너리 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 바이너리 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 바이너리 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return ext in BINARY_EXTENSIONS or base_name in BINARY_FILENAMES\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_ignore_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 무시해야 할 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 무시해야 할 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 무시해야 할 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return (\\\\n        ext in BINARY_EXTENSIONS\\\\n        or base_name in BINARY_FILENAMES\\\\n        or base_name in IGNORE_FILENAMES\\\\n    )\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n```\\\", \\\"line_number\\\": 86}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(\\\\n            filename\\\\n        ):  # is_binary_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 무시해야 할 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_ignore_file(\\\\n            filename\\\\n        ):  # is_ignore_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[제외 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n```\\\", \\\"line_number\\\": 146}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root, is_ignore_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_ignore_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not review_request.use_full_context:\\\\n            raise ValueError(\\\\\\\"full context 플래그가 켜져있어야 합니다.\\\\\\\")\\\\n\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_ignore_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                if not request.file_content:\\\\n                    logger.warning(\\\\n                        f\\\\\\\"파일 내용이 없습니다. 파일 경로: {request.filename}\\\\\\\"\\\\n                    )\\\\n                    file_content = \\\\\\\"\\\\\\\"\\\\n                else:\\\\n                    file_content = request.file_content\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root, is_binary_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root, is_ignore_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_ignore_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_ignore_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n```\\\", \\\"line_number\\\": 123}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_is_binary_file.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_ignore_file\\\\n\\\\n\\\\nclass TestIsIgnoreFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n            (\\\\\\\"image.png\\\\\\\", True),\\\\n            (\\\\\\\"archive.zip\\\\\\\", True),\\\\n            (\\\\\\\"document.pdf\\\\\\\", True),\\\\n            (\\\\\\\"music.mp3\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n            (\\\\\\\"doc.txt\\\\\\\", False),\\\\n            (\\\\\\\"config.json\\\\\\\", False),\\\\n            (\\\\\\\"index.html\\\\\\\", False),\\\\n            (\\\\\\\"script.js\\\\\\\", False),\\\\n        ],\\\\n    )\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 무시하지 않아도 되는 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n            (\\\\\\\"gradlew\\\\\\\", True),\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_ignore_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"무시해야 할 특수 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n            (\\\\\\\"src/main/resources/config.json\\\\\\\", False),\\\\n            (\\\\\\\"../project/gradlew\\\\\\\", True),\\\\n            (\\\\\\\"C:\\\\\\\\\\\\\\\\Users\\\\\\\\\\\\\\\\user\\\\\\\\\\\\\\\\Documents\\\\\\\\\\\\\\\\file.txt\\\\\\\", False),\\\\n            (\\\\\\\"/var/www/html/.env.local\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_with_path(self, filepath: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"경로가 포함된 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filepath) == expected\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"is_binary_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\n\\\\n\\\\nclass TestIsBinaryFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_binary_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_ignore_file\\\\n\\\\n\\\\nclass TestIsIgnoreFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 바이너리 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n```\\\", \\\"line_number\\\": 21}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 텍스트 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 무시하지 않아도 되는 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n```\\\", \\\"line_number\\\": 40}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"특수 바이너리 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 바이너리 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_ignore_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"무시해야 할 특수 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n```\\\", \\\"line_number\\\": 54}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filepath) == expected\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filepath) == expected\\\\n```\\\", \\\"line_number\\\": 80}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_is_ignore_file.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_ignore_file\\\\n\\\\n\\\\nclass TestIsIgnoreFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n            (\\\\\\\"image.png\\\\\\\", True),\\\\n            (\\\\\\\"archive.zip\\\\\\\", True),\\\\n            (\\\\\\\"document.pdf\\\\\\\", True),\\\\n            (\\\\\\\"music.mp3\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n            (\\\\\\\"doc.txt\\\\\\\", False),\\\\n            (\\\\\\\"config.json\\\\\\\", False),\\\\n            (\\\\\\\"index.html\\\\\\\", False),\\\\n            (\\\\\\\"script.js\\\\\\\", False),\\\\n        ],\\\\n    )\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 무시하지 않아도 되는 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n            (\\\\\\\"gradlew\\\\\\\", True),\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_ignore_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"무시해야 할 특수 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n            (\\\\\\\"src/main/resources/config.json\\\\\\\", False),\\\\n            (\\\\\\\"../project/gradlew\\\\\\\", True),\\\\n            (\\\\\\\"C:\\\\\\\\\\\\\\\\Users\\\\\\\\\\\\\\\\user\\\\\\\\\\\\\\\\Documents\\\\\\\\\\\\\\\\file.txt\\\\\\\", False),\\\\n            (\\\\\\\"/var/www/html/.env.local\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_with_path(self, filepath: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"경로가 포함된 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filepath) == expected\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_ignore_file\\\\n\\\\n\\\\nclass TestIsIgnoreFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_ignore_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n            (\\\\\\\"image.png\\\\\\\", True),\\\\n            (\\\\\\\"archive.zip\\\\\\\", True),\\\\n            (\\\\\\\"document.pdf\\\\\\\", True),\\\\n            (\\\\\\\"music.mp3\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n            (\\\\\\\"doc.txt\\\\\\\", False),\\\\n            (\\\\\\\"config.json\\\\\\\", False),\\\\n            (\\\\\\\"index.html\\\\\\\", False),\\\\n            (\\\\\\\"script.js\\\\\\\", False),\\\\n        ],\\\\n    )\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 무시하지 않아도 되는 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n            (\\\\\\\"gradlew\\\\\\\", True),\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_ignore_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"무시해야 할 특수 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 무시해야 할 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n            (\\\\\\\"src/main/resources/config.json\\\\\\\", False),\\\\n            (\\\\\\\"../project/gradlew\\\\\\\", True),\\\\n            (\\\\\\\"C:\\\\\\\\\\\\\\\\Users\\\\\\\\\\\\\\\\user\\\\\\\\\\\\\\\\Documents\\\\\\\\\\\\\\\\file.txt\\\\\\\", False),\\\\n            (\\\\\\\"/var/www/html/.env.local\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_with_path(self, filepath: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"경로가 포함된 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_ignore_file(filepath) == expected\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_load_file_content.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"load_file_content 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import load_file_content\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef temp_repo_with_files(tmpdir) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트용 임시 저장소와 파일을 생성합니다.\\\\n\\\\n    Args:\\\\n        tmpdir: pytest의 임시 디렉토리 픽스처\\\\n\\\\n    Returns:\\\\n        str: 생성된 임시 저장소 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 임시 저장소 디렉토리 생성\\\\n    repo_dir = tmpdir.mkdir(\\\\\\\"repo\\\\\\\")\\\\n\\\\n    # 텍스트 파일 생성\\\\n    text_file = repo_dir.join(\\\\\\\"file.txt\\\\\\\")\\\\n    text_file.write(\\\\\\\"텍스트 파일 내용\\\\\\\")\\\\n\\\\n    # 중첩 디렉토리 및 파일 생성\\\\n    subdir = repo_dir.mkdir(\\\\\\\"subdir\\\\\\\")\\\\n    subdir_file = subdir.join(\\\\\\\"subfile.py\\\\\\\")\\\\n    subdir_file.write(\\\\n        \\\\\\\"#!/usr/bin/env python\\\\\\\\n# -*- coding: utf-8 -*-\\\\\\\\n\\\\\\\\nprint('테스트')\\\\\\\"\\\\n    )\\\\n\\\\n    # 바이너리 파일로 간주될 파일 생성\\\\n    binary_file = repo_dir.join(\\\\\\\"image.png\\\\\\\")\\\\n    binary_file.write(\\\\\\\"가짜 바이너리 내용\\\\\\\")\\\\n\\\\n    # 외부 디렉토리 (저장소 외부 테스트용)\\\\n    tmpdir.mkdir(\\\\\\\"outside\\\\\\\")\\\\n    outside_file = tmpdir.join(\\\\\\\"outside/outside.txt\\\\\\\")\\\\n    outside_file.write(\\\\\\\"저장소 외부 파일\\\\\\\")\\\\n\\\\n    return str(repo_dir)\\\\n\\\\n\\\\nclass TestLoadFileContent:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"load_file_content 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def test_text_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 파일 로딩이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"텍스트 파일 내용\\\\\\\"\\\\n\\\\n    def test_nested_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"중첩 디렉토리 내 파일 로딩이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"subdir/subfile.py\\\\\\\", temp_repo_with_files)\\\\n        assert \\\\\\\"print('테스트')\\\\\\\" in content\\\\n\\\\n    def test_file_not_found(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"존재하지 않는 파일 로딩 시 적절한 예외가 발생하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        with pytest.raises(Exception) as excinfo:\\\\n            load_file_content(\\\\\\\"non_existent.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 원래 예외가 FileNotFoundError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, FileNotFoundError)\\\\n\\\\n    def test_permission_error(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"저장소 외부 파일 접근 시도 시 적절한 예외가 발생하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        with pytest.raises(Exception) as excinfo:\\\\n            load_file_content(\\\\\\\"../outside/outside.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 원래 예외가 PermissionError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, PermissionError)\\\\n\\\\n    def test_binary_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"제외 파일 로딩 시 적절한 메시지를 반환하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"image.png\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"[제외 파일: image.png]\\\\\\\"\\\\n\\\\n    def test_lru_cache(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        # 첫 번째 호출로 캐시 채우기\\\\n        first_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 파일 내용 변경\\\\n        file_path = os.path.join(temp_repo_with_files, \\\\\\\"file.txt\\\\\\\")\\\\n        with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            f.write(\\\\\\\"변경된 내용\\\\\\\")\\\\n\\\\n        # 같은 매개변수로 다시 호출 (캐시된 결과가 반환되어야 함)\\\\n        second_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        assert first_content == second_content\\\\n        assert second_content == \\\\\\\"텍스트 파일 내용\\\\\\\"  # 변경 전 내용\\\\n\\\\n        # 캐시 초기화 후 다시 호출\\\\n        load_file_content.cache_clear()\\\\n        third_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        assert third_content != first_content\\\\n        assert third_content == \\\\\\\"변경된 내용\\\\\\\"  # 변경 후 내용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 원래 예외가 PermissionError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, PermissionError)\\\\n\\\\n    def test_binary_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 파일 로딩 시 적절한 메시지를 반환하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"image.png\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"[바이너리 파일: image.png]\\\\\\\"\\\\n\\\\n    def test_lru_cache(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 원래 예외가 PermissionError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, PermissionError)\\\\n\\\\n    def test_binary_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"제외 파일 로딩 시 적절한 메시지를 반환하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"image.png\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"[제외 파일: image.png]\\\\\\\"\\\\n\\\\n    def test_lru_cache(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n```\\\", \\\"line_number\\\": 99}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"성능\", \"line_number\": 106, \"file\": \"reviewer/src/utils/file_utils.py\", \"description\": \"`load_file_content` 함수에 `@lru_cache(maxsize=1)`이 사용되었습니다. 이는 가장 마지막으로 호출된 단일 파일의 내용만 캐시함을 의미합니다. 만약 여러 다른 파일들이 순차적으로 로드된 후 이전에 로드된 파일이 다시 요청될 경우, 캐시 미스가 발생하여 파일을 다시 읽게 됩니다. 코드 리뷰와 같이 여러 파일을 다룰 가능성이 있는 경우, 더 큰 캐시 크기가 성능 향상에 도움이 될 수 있습니다.\", \"suggestion\": \"애플리케이션의 파일 접근 패턴을 고려하여 `maxsize`를 적절히 늘리는 것을 검토해 보세요 (예: `maxsize=32` 또는 `maxsize=128`). 이렇게 하면 더 많은 파일 내용을 메모리에 캐시하여 반복적인 파일 읽기 비용을 줄일 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"@lru_cache(maxsize=1)\\ndef load_file_content(filename: str, repo_path: str) -> str:\", \"improved_code\": \"@lru_cache(maxsize=32)  # 예시로 32로 늘림, 실제 값은 사용 패턴에 따라 조절\\ndef load_file_content(filename: str, repo_path: str) -> str:\"}, {\"type\": \"스타일\", \"line_number\": 97, \"file\": \"reviewer/src/utils/file_utils.py\", \"description\": \"파일 경로 조작에 `os.path`와 `pathlib`가 혼용되고 있습니다. 예를 들어, `is_ignore_file` 함수 내에서는 `os.path.splitext`와 `os.path.basename` (97-98행)이 사용되는 반면, 같은 파일의 `find_project_root` 함수에서는 `pathlib.Path` 객체가 사용됩니다. 일관성을 위해 하나의 스타일을 선택하는 것이 좋습니다. `pathlib`는 객체 지향적 접근 방식을 제공하며 현대 파이썬에서 권장되는 경우가 많습니다.\", \"suggestion\": \"프로젝트 전체적으로 `pathlib` 사용을 표준화하여 코드의 일관성과 가독성을 높이는 것을 고려해 보세요. 예를 들어, `os.path.splitext(filename.lower())`와 `os.path.basename(filename)` 대신 `Path(filename.lower()).suffix` 와 `Path(filename).name` 등을 사용할 수 있습니다. (파일 상단에 `from pathlib import Path` 추가 필요)\", \"severity\": \"info\", \"original_code\": \"    # 확장자 또는 파일명으로 무시해야 할 파일 확인\\n    _, ext = os.path.splitext(filename.lower())\\n    base_name = os.path.basename(filename)\", \"improved_code\": \"    from pathlib import Path # 파일 상단에 import 추가 필요\\n\\n    # 확장자 또는 파일명으로 무시해야 할 파일 확인\\n    file_path_obj = Path(filename)\\n    ext = file_path_obj.suffix.lower() # 확장자만 소문자로 변경\\n    base_name = file_path_obj.name\"}], \"summary\": \"제공된 코드 변경 사항은 처리 과정에서 무시해야 할 파일을 다루는 방식의 명확성을 향상시키기 위한 리팩토링입니다. `is_binary_file` 함수 및 관련 로직은 `is_ignore_file`로 이름이 변경되고 확장되어, 이제 바이너리 파일뿐만 아니라 `.gitignore`, `.env`와 같이 건너뛰어야 하는 특정 텍스트 파일도 올바르게 분류합니다. 이러한 변경 사항은 `prompt_generator` 및 관련 테스트 스위트에도 반영되었습니다. 테스트는 이러한 변경 사항을 반영하고 정확성을 보장하도록 업데이트되었습니다.\", \"score\": 8.0, \"recommendations\": [\"여러 고유한 파일에 자주 접근하고 재접근하는 경우, 디스크 I/O를 줄여 성능을 향상시키기 위해 `load_file_content` 함수의 `lru_cache` maxsize를 늘리는 것을 고려하십시오.\", \"가독성 및 플랫폼 간 호환성 향상을 위해, 코드베이스 전체적으로 `os.path` 대신 `pathlib`의 `Path` 객체를 일관되게 사용하는 것을 고려하십시오.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_find_project_root.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"find_project_root 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom pathlib import Path\\\\nfrom unittest import mock\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef project_structure(tmpdir):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TestFindProjectRoot 테스트를 위한 기본 프로젝트 구조를 생성합니다.\\\\n\\\\n    Args:\\\\n        tmpdir: pytest의 임시 디렉토리 픽스처\\\\n\\\\n    Returns:\\\\n        tuple[Path, Path, Path]: (project_dir, src_dir, module_file) 튜플\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 임시 디렉토리에 프로젝트 구조 생성\\\\n    project_dir = Path(tmpdir) / \\\\\\\"project\\\\\\\"\\\\n    src_dir = project_dir / \\\\\\\"src\\\\\\\" / \\\\\\\"utils\\\\\\\"\\\\n    src_dir.mkdir(parents=True)\\\\n\\\\n    # 모듈 파일 생성\\\\n    module_file = src_dir / \\\\\\\"file_utils.py\\\\\\\"\\\\n    module_file.touch()\\\\n\\\\n    return project_dir, src_dir, module_file\\\\n\\\\n\\\\nclass TestFindProjectRoot:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"find_project_root 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def test_found_git_root(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Git 저장소 루트를 올바르게 찾는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        project_dir, _, module_file = project_structure\\\\n\\\\n        # .git 디렉토리 생성 (프로젝트 루트 표시)\\\\n        git_dir = project_dir / \\\\\\\".git\\\\\\\"\\\\n        git_dir.mkdir()\\\\n\\\\n        # __file__ 값을 모킹하여 find_project_root 내부에서 올바른 시작점을 갖도록 함\\\\n        with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n            root = find_project_root()\\\\n            # 정규화된 경로로 비교\\\\n            assert str(root.resolve()) == str(project_dir.resolve())\\\\n\\\\n    def test_found_pyproject_root(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"pyproject.toml이 있는 루트를 올바르게 찾는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        project_dir, _, module_file = project_structure\\\\n\\\\n        # pyproject.toml 파일 생성 (프로젝트 루트 표시)\\\\n        pyproject_file = project_dir / \\\\\\\"pyproject.toml\\\\\\\"\\\\n        pyproject_file.touch()\\\\n\\\\n        # __file__ 값을 모킹하여 find_project_root 내부에서 올바른 시작점을 갖도록 함\\\\n        with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n            root = find_project_root()\\\\n            # 정규화된 경로로 비교\\\\n            assert str(root.resolve()) == str(project_dir.resolve())\\\\n\\\\n    def test_root_not_found(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트를 찾지 못할 때 적절한 예외가 발생하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        _, _, module_file = project_structure\\\\n\\\\n        # exists 메서드 모킹하여 항상 False 반환하도록 설정\\\\n        with mock.patch(\\\\\\\"pathlib.Path.exists\\\\\\\", return_value=False):\\\\n            # __file__ 값을 모킹하여 find_project_root 내부에서 올바른 시작점을 갖도록 함\\\\n            with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n                with pytest.raises(FileNotFoundError):\\\\n                    find_project_root()\\\\n\\\\n    def test_lru_cache(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        project_dir, _, module_file = project_structure\\\\n\\\\n        # .git 디렉토리 생성\\\\n        git_dir = project_dir / \\\\\\\".git\\\\\\\"\\\\n        git_dir.mkdir()\\\\n\\\\n        # __file__ 값 모킹\\\\n        with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n            # 첫 번째 호출\\\\n            first_result = find_project_root()\\\\n\\\\n            # .git 디렉토리 삭제 후 requirements.txt 생성\\\\n            git_dir.rmdir()\\\\n            req_file = project_dir / \\\\\\\"requirements.txt\\\\\\\"\\\\n            req_file.touch()\\\\n\\\\n            # 두 번째 호출 (캐시된 결과가 반환되어야 함)\\\\n            second_result = find_project_root()\\\\n\\\\n            # 정규화된 경로로 비교\\\\n            assert str(first_result.resolve()) == str(second_result.resolve())\\\\n            assert str(second_result.resolve()) == str(project_dir.resolve())\\\\n\\\\n            # 캐시 초기화 후 다시 호출\\\\n            find_project_root.cache_clear()\\\\n\\\\n            # 세 번째 호출 (새 결과가 반환되어야 함, 하지만 여전히 같은 디렉토리)\\\\n            third_result = find_project_root()\\\\n            assert str(third_result.resolve()) == str(project_dir.resolve())\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"find_project_root 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom pathlib import Path\\\\nfrom unittest import mock\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef project_structure(tmpdir):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TestFindProjectRoot 테스트를 위한 기본 프로젝트 구조를 생성합니다.\\\\n\\\\n    Args:\\\\n        tmpdir: pytest의 임시 디렉토리 픽스처\\\\n\\\\n    Returns:\\\\n        tuple[Path, Path, Path]: (project_dir, src_dir, module_file) 튜플\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 임시 디렉토리에 프로젝트 구조 생성\\\\n    project_dir = Path(tmpdir) / \\\\\\\"project\\\\\\\"\\\\n    src_dir = project_dir / \\\\\\\"src\\\\\\\" / \\\\\\\"utils\\\\\\\"\\\\n    src_dir.mkdir(parents=True)\\\\n\\\\n    # 모듈 파일 생성\\\\n    module_file = src_dir / \\\\\\\"file_utils.py\\\\\\\"\\\\n    module_file.touch()\\\\n\\\\n    return project_dir, src_dir, module_file\\\\n\\\\n\\\\nclass TestFindProjectRoot:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"find_project_root 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def test_found_git_root(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Git 저장소 루트를 올바르게 찾는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        project_dir, _, module_file = project_structure\\\\n\\\\n        # .git 디렉토리 생성 (프로젝트 루트 표시)\\\\n        git_dir = project_dir / \\\\\\\".git\\\\\\\"\\\\n        git_dir.mkdir()\\\\n\\\\n        # __file__ 값을 모킹하여 find_project_root 내부에서 올바른 시작점을 갖도록 함\\\\n        with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n            root = find_project_root()\\\\n            # 정규화된 경로로 비교\\\\n            assert str(root.resolve()) == str(project_dir.resolve())\\\\n\\\\n    def test_found_pyproject_root(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"pyproject.toml이 있는 루트를 올바르게 찾는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        project_dir, _, module_file = project_structure\\\\n\\\\n        # pyproject.toml 파일 생성 (프로젝트 루트 표시)\\\\n        pyproject_file = project_dir / \\\\\\\"pyproject.toml\\\\\\\"\\\\n        pyproject_file.touch()\\\\n\\\\n        # __file__ 값을 모킹하여 find_project_root 내부에서 올바른 시작점을 갖도록 함\\\\n        with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n            root = find_project_root()\\\\n            # 정규화된 경로로 비교\\\\n            assert str(root.resolve()) == str(project_dir.resolve())\\\\n\\\\n    def test_root_not_found(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트를 찾지 못할 때 적절한 예외가 발생하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        _, _, module_file = project_structure\\\\n\\\\n        # exists 메서드 모킹하여 항상 False 반환하도록 설정\\\\n        with mock.patch(\\\\\\\"pathlib.Path.exists\\\\\\\", return_value=False):\\\\n            # __file__ 값을 모킹하여 find_project_root 내부에서 올바른 시작점을 갖도록 함\\\\n            with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n                with pytest.raises(FileNotFoundError):\\\\n                    find_project_root()\\\\n\\\\n    def test_lru_cache(self, project_structure) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        find_project_root.cache_clear()\\\\n\\\\n        project_dir, _, module_file = project_structure\\\\n\\\\n        # .git 디렉토리 생성\\\\n        git_dir = project_dir / \\\\\\\".git\\\\\\\"\\\\n        git_dir.mkdir()\\\\n\\\\n        # __file__ 값 모킹\\\\n        with mock.patch(\\\\\\\"reviewer.src.utils.file_utils.__file__\\\\\\\", str(module_file)):\\\\n            # 첫 번째 호출\\\\n            first_result = find_project_root()\\\\n\\\\n            # .git 디렉토리 삭제 후 requirements.txt 생성\\\\n            git_dir.rmdir()\\\\n            req_file = project_dir / \\\\\\\"requirements.txt\\\\\\\"\\\\n            req_file.touch()\\\\n\\\\n            # 두 번째 호출 (캐시된 결과가 반환되어야 함)\\\\n            second_result = find_project_root()\\\\n\\\\n            # 정규화된 경로로 비교\\\\n            assert str(first_result.resolve()) == str(second_result.resolve())\\\\n            assert str(second_result.resolve()) == str(project_dir.resolve())\\\\n\\\\n            # 캐시 초기화 후 다시 호출\\\\n            find_project_root.cache_clear()\\\\n\\\\n            # 세 번째 호출 (새 결과가 반환되어야 함, 하지만 여전히 같은 디렉토리)\\\\n            third_result = find_project_root()\\\\n            assert str(third_result.resolve()) == str(project_dir.resolve())\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_is_binary_file.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"is_binary_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\n\\\\n\\\\nclass TestIsBinaryFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_binary_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n            (\\\\\\\"image.png\\\\\\\", True),\\\\n            (\\\\\\\"archive.zip\\\\\\\", True),\\\\n            (\\\\\\\"document.pdf\\\\\\\", True),\\\\n            (\\\\\\\"music.mp3\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 바이너리 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n            (\\\\\\\"doc.txt\\\\\\\", False),\\\\n            (\\\\\\\"config.json\\\\\\\", False),\\\\n            (\\\\\\\"index.html\\\\\\\", False),\\\\n            (\\\\\\\"script.js\\\\\\\", False),\\\\n        ],\\\\n    )\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 텍스트 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n            (\\\\\\\"gradlew\\\\\\\", True),\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"특수 바이너리 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 바이너리 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n            (\\\\\\\"src/main/resources/config.json\\\\\\\", False),\\\\n            (\\\\\\\"../project/gradlew\\\\\\\", True),\\\\n            (\\\\\\\"C:\\\\\\\\\\\\\\\\Users\\\\\\\\\\\\\\\\user\\\\\\\\\\\\\\\\Documents\\\\\\\\\\\\\\\\file.txt\\\\\\\", False),\\\\n            (\\\\\\\"/var/www/html/.env.local\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_with_path(self, filepath: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"경로가 포함된 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filepath) == expected\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"is_binary_file 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\n\\\\n\\\\nclass TestIsBinaryFile:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"is_binary_file 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"test.exe\\\\\\\", True),\\\\n            (\\\\\\\"image.png\\\\\\\", True),\\\\n            (\\\\\\\"archive.zip\\\\\\\", True),\\\\n            (\\\\\\\"document.pdf\\\\\\\", True),\\\\n            (\\\\\\\"music.mp3\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 바이너리 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"code.py\\\\\\\", False),\\\\n            (\\\\\\\"doc.txt\\\\\\\", False),\\\\n            (\\\\\\\"config.json\\\\\\\", False),\\\\n            (\\\\\\\"index.html\\\\\\\", False),\\\\n            (\\\\\\\"script.js\\\\\\\", False),\\\\n        ],\\\\n    )\\\\n    def test_text_extension(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 확장자를 가진 파일에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (False: 텍스트 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filename,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\".DS_Store\\\\\\\", True),\\\\n            (\\\\\\\"gradlew\\\\\\\", True),\\\\n            (\\\\\\\".env\\\\\\\", True),\\\\n            (\\\\\\\".gitignore\\\\\\\", True),\\\\n            (\\\\\\\"gradle-wrapper.properties\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_binary_filename(self, filename: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"특수 바이너리 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filename: 테스트할 파일명\\\\n            expected: 예상 결과 (True: 바이너리 파일)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filename) == expected\\\\n\\\\n    @pytest.mark.parametrize(\\\\n        \\\\\\\"filepath,expected\\\\\\\",\\\\n        [\\\\n            (\\\\\\\"/path/to/image.jpg\\\\\\\", True),\\\\n            (\\\\\\\"src/main/resources/config.json\\\\\\\", False),\\\\n            (\\\\\\\"../project/gradlew\\\\\\\", True),\\\\n            (\\\\\\\"C:\\\\\\\\\\\\\\\\Users\\\\\\\\\\\\\\\\user\\\\\\\\\\\\\\\\Documents\\\\\\\\\\\\\\\\file.txt\\\\\\\", False),\\\\n            (\\\\\\\"/var/www/html/.env.local\\\\\\\", True),\\\\n        ],\\\\n    )\\\\n    def test_with_path(self, filepath: str, expected: bool) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"경로가 포함된 파일명에 대해 올바르게 판단하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            filepath: 테스트할 파일 경로\\\\n            expected: 예상 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert is_binary_file(filepath) == expected\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/utils/test_load_file_content.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"load_file_content 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import load_file_content\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef temp_repo_with_files(tmpdir) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트용 임시 저장소와 파일을 생성합니다.\\\\n\\\\n    Args:\\\\n        tmpdir: pytest의 임시 디렉토리 픽스처\\\\n\\\\n    Returns:\\\\n        str: 생성된 임시 저장소 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 임시 저장소 디렉토리 생성\\\\n    repo_dir = tmpdir.mkdir(\\\\\\\"repo\\\\\\\")\\\\n\\\\n    # 텍스트 파일 생성\\\\n    text_file = repo_dir.join(\\\\\\\"file.txt\\\\\\\")\\\\n    text_file.write(\\\\\\\"텍스트 파일 내용\\\\\\\")\\\\n\\\\n    # 중첩 디렉토리 및 파일 생성\\\\n    subdir = repo_dir.mkdir(\\\\\\\"subdir\\\\\\\")\\\\n    subdir_file = subdir.join(\\\\\\\"subfile.py\\\\\\\")\\\\n    subdir_file.write(\\\\n        \\\\\\\"#!/usr/bin/env python\\\\\\\\n# -*- coding: utf-8 -*-\\\\\\\\n\\\\\\\\nprint('테스트')\\\\\\\"\\\\n    )\\\\n\\\\n    # 바이너리 파일로 간주될 파일 생성\\\\n    binary_file = repo_dir.join(\\\\\\\"image.png\\\\\\\")\\\\n    binary_file.write(\\\\\\\"가짜 바이너리 내용\\\\\\\")\\\\n\\\\n    # 외부 디렉토리 (저장소 외부 테스트용)\\\\n    tmpdir.mkdir(\\\\\\\"outside\\\\\\\")\\\\n    outside_file = tmpdir.join(\\\\\\\"outside/outside.txt\\\\\\\")\\\\n    outside_file.write(\\\\\\\"저장소 외부 파일\\\\\\\")\\\\n\\\\n    return str(repo_dir)\\\\n\\\\n\\\\nclass TestLoadFileContent:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"load_file_content 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def test_text_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 파일 로딩이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"텍스트 파일 내용\\\\\\\"\\\\n\\\\n    def test_nested_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"중첩 디렉토리 내 파일 로딩이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"subdir/subfile.py\\\\\\\", temp_repo_with_files)\\\\n        assert \\\\\\\"print('테스트')\\\\\\\" in content\\\\n\\\\n    def test_file_not_found(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"존재하지 않는 파일 로딩 시 적절한 예외가 발생하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        with pytest.raises(Exception) as excinfo:\\\\n            load_file_content(\\\\\\\"non_existent.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 원래 예외가 FileNotFoundError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, FileNotFoundError)\\\\n\\\\n    def test_permission_error(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"저장소 외부 파일 접근 시도 시 적절한 예외가 발생하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        with pytest.raises(Exception) as excinfo:\\\\n            load_file_content(\\\\\\\"../outside/outside.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 원래 예외가 PermissionError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, PermissionError)\\\\n\\\\n    def test_binary_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 파일 로딩 시 적절한 메시지를 반환하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"image.png\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"[바이너리 파일: image.png]\\\\\\\"\\\\n\\\\n    def test_lru_cache(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        # 첫 번째 호출로 캐시 채우기\\\\n        first_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 파일 내용 변경\\\\n        file_path = os.path.join(temp_repo_with_files, \\\\\\\"file.txt\\\\\\\")\\\\n        with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            f.write(\\\\\\\"변경된 내용\\\\\\\")\\\\n\\\\n        # 같은 매개변수로 다시 호출 (캐시된 결과가 반환되어야 함)\\\\n        second_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        assert first_content == second_content\\\\n        assert second_content == \\\\\\\"텍스트 파일 내용\\\\\\\"  # 변경 전 내용\\\\n\\\\n        # 캐시 초기화 후 다시 호출\\\\n        load_file_content.cache_clear()\\\\n        third_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        assert third_content != first_content\\\\n        assert third_content == \\\\\\\"변경된 내용\\\\\\\"  # 변경 후 내용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"load_file_content 함수에 대한 유닛 테스트.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\n\\\\nimport pytest\\\\n\\\\nfrom reviewer.src.utils.file_utils import load_file_content\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef temp_repo_with_files(tmpdir) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트용 임시 저장소와 파일을 생성합니다.\\\\n\\\\n    Args:\\\\n        tmpdir: pytest의 임시 디렉토리 픽스처\\\\n\\\\n    Returns:\\\\n        str: 생성된 임시 저장소 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 임시 저장소 디렉토리 생성\\\\n    repo_dir = tmpdir.mkdir(\\\\\\\"repo\\\\\\\")\\\\n\\\\n    # 텍스트 파일 생성\\\\n    text_file = repo_dir.join(\\\\\\\"file.txt\\\\\\\")\\\\n    text_file.write(\\\\\\\"텍스트 파일 내용\\\\\\\")\\\\n\\\\n    # 중첩 디렉토리 및 파일 생성\\\\n    subdir = repo_dir.mkdir(\\\\\\\"subdir\\\\\\\")\\\\n    subdir_file = subdir.join(\\\\\\\"subfile.py\\\\\\\")\\\\n    subdir_file.write(\\\\n        \\\\\\\"#!/usr/bin/env python\\\\\\\\n# -*- coding: utf-8 -*-\\\\\\\\n\\\\\\\\nprint('테스트')\\\\\\\"\\\\n    )\\\\n\\\\n    # 바이너리 파일로 간주될 파일 생성\\\\n    binary_file = repo_dir.join(\\\\\\\"image.png\\\\\\\")\\\\n    binary_file.write(\\\\\\\"가짜 바이너리 내용\\\\\\\")\\\\n\\\\n    # 외부 디렉토리 (저장소 외부 테스트용)\\\\n    tmpdir.mkdir(\\\\\\\"outside\\\\\\\")\\\\n    outside_file = tmpdir.join(\\\\\\\"outside/outside.txt\\\\\\\")\\\\n    outside_file.write(\\\\\\\"저장소 외부 파일\\\\\\\")\\\\n\\\\n    return str(repo_dir)\\\\n\\\\n\\\\nclass TestLoadFileContent:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"load_file_content 함수에 대한 테스트 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def test_text_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트 파일 로딩이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"텍스트 파일 내용\\\\\\\"\\\\n\\\\n    def test_nested_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"중첩 디렉토리 내 파일 로딩이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"subdir/subfile.py\\\\\\\", temp_repo_with_files)\\\\n        assert \\\\\\\"print('테스트')\\\\\\\" in content\\\\n\\\\n    def test_file_not_found(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"존재하지 않는 파일 로딩 시 적절한 예외가 발생하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        with pytest.raises(Exception) as excinfo:\\\\n            load_file_content(\\\\\\\"non_existent.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 원래 예외가 FileNotFoundError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, FileNotFoundError)\\\\n\\\\n    def test_permission_error(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"저장소 외부 파일 접근 시도 시 적절한 예외가 발생하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        with pytest.raises(Exception) as excinfo:\\\\n            load_file_content(\\\\\\\"../outside/outside.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 원래 예외가 PermissionError인지 확인\\\\n        assert isinstance(excinfo.value.__cause__, PermissionError)\\\\n\\\\n    def test_binary_file(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"바이너리 파일 로딩 시 적절한 메시지를 반환하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        content = load_file_content(\\\\\\\"image.png\\\\\\\", temp_repo_with_files)\\\\n        assert content == \\\\\\\"[바이너리 파일: image.png]\\\\\\\"\\\\n\\\\n    def test_lru_cache(self, temp_repo_with_files: str) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"캐싱 기능이 올바르게 작동하는지 테스트합니다.\\\\n\\\\n        Args:\\\\n            temp_repo_with_files: 임시 저장소 경로 픽스처\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 테스트 전 캐시 초기화\\\\n        load_file_content.cache_clear()\\\\n\\\\n        # 첫 번째 호출로 캐시 채우기\\\\n        first_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        # 파일 내용 변경\\\\n        file_path = os.path.join(temp_repo_with_files, \\\\\\\"file.txt\\\\\\\")\\\\n        with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            f.write(\\\\\\\"변경된 내용\\\\\\\")\\\\n\\\\n        # 같은 매개변수로 다시 호출 (캐시된 결과가 반환되어야 함)\\\\n        second_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        assert first_content == second_content\\\\n        assert second_content == \\\\\\\"텍스트 파일 내용\\\\\\\"  # 변경 전 내용\\\\n\\\\n        # 캐시 초기화 후 다시 호출\\\\n        load_file_content.cache_clear()\\\\n        third_content = load_file_content(\\\\\\\"file.txt\\\\\\\", temp_repo_with_files)\\\\n\\\\n        assert third_content != first_content\\\\n        assert third_content == \\\\\\\"변경된 내용\\\\\\\"  # 변경 후 내용\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 37, \"file\": \"tests/utils/test_find_project_root.py\", \"description\": \"Path 객체를 문자열로 변환하여 비교하는 것은 Path 객체를 직접 비교하는 것보다 장황하며, pathlib의 이점을 충분히 활용하지 못합니다. resolve()를 호출한 후 Path 객체를 직접 비교하는 것이 더 Pythonic하고 명확합니다. 이 문제는 37, 49, 64, 93, 94, 98 라인 등 여러 곳에서 발견됩니다.\", \"suggestion\": \"assert root.resolve() == project_dir.resolve()와 같이 Path 객체를 직접 비교하도록 변경합니다.\", \"severity\": \"info\", \"original_code\": \"assert str(root.resolve()) == str(project_dir.resolve())\", \"improved_code\": \"assert root.resolve() == project_dir.resolve()\"}, {\"type\": \"버그\", \"line_number\": 45, \"file\": \"tests/utils/test_is_binary_file.py\", \"description\": \"test_binary_filename 테스트 케이스에서 .gitignore (라인 45), .env (라인 44), gradle-wrapper.properties (라인 46) 파일들이 바이너리 파일로 예상(expected=True)되고 있습니다. 일반적으로 이러한 파일들은 텍스트 파일로 간주됩니다. 만약 is_binary_file 함수가 실제로 이 파일들을 바이너리로 판단한다면, 함수의 로직 또는 파일 유형 분류 기준에 대한 검토가 필요합니다. 이 테스트는 현재 함수의 동작을 반영할 수 있지만, 그 동작 자체가 올바른지에 대한 의문이 있습니다.\", \"suggestion\": \".env, .gitignore, gradle-wrapper.properties 파일들이 실제로 바이너리로 취급되어야 하는지 확인하고, 그렇지 않다면 is_binary_file 함수의 로직을 수정하거나 테스트의 예상 결과를 False로 변경해야 합니다. 예를 들어, .gitignore는 명백한 텍스트 파일입니다. is_binary_file 함수가 의도적으로 이들을 바이너리로 판단한다면, 그 이유에 대한 주석이나 문서화가 필요합니다.\", \"severity\": \"warning\", \"original_code\": \"            (\\\".DS_Store\\\", True),\\n            (\\\"gradlew\\\", True),\\n            (\\\".env\\\", True),\\n            (\\\".gitignore\\\", True),\\n            (\\\"gradle-wrapper.properties\\\", True),\", \"improved_code\": \"            (\\\".DS_Store\\\", True),  # .DS_Store는 바이너리일 수 있음\\n            (\\\"gradlew\\\", True),    # gradlew는 실행 스크립트이지만, 내용에 따라 바이너리로 오인될 수 있는 바이트가 있을 수 있음 (확인 필요)\\n            (\\\".env\\\", False),      # .env 파일은 일반적으로 텍스트입니다.\\n            (\\\".gitignore\\\", False), # .gitignore 파일은 텍스트입니다.\\n            (\\\"gradle-wrapper.properties\\\", False), # .properties 파일은 텍스트입니다.\"}, {\"type\": \"스타일\", \"line_number\": 32, \"file\": \"tests/utils/test_load_file_content.py\", \"description\": \"temp_repo_with_files 픽스처가 임시 저장소 경로를 문자열로 반환하고 (라인 32), 테스트 내부(예: 라인 96)에서 os.path.join을 사용하여 경로를 조작합니다. pathlib.Path 객체를 일관되게 사용하면 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. tmpdir 자체가 py.path.local 객체를 제공하며, 이를 Path로 변환하여 사용하는 것이 좋습니다.\", \"suggestion\": \"픽스처가 Path 객체를 반환하도록 수정하고 (예: def temp_repo_with_files(tmpdir) -> Path: ... return Path(repo_dir)), 테스트 내에서도 Path 객체의 연산자(예: /)를 사용하여 경로를 조작하는 것을 고려하세요 (예: file_path = temp_repo_with_files / \\\"file.txt\\\").\", \"severity\": \"info\", \"original_code\": \"@pytest.fixture\\ndef temp_repo_with_files(tmpdir) -> str:\\n    # ...\\n    repo_dir = tmpdir.mkdir(\\\"repo\\\")\\n    # ...\\n    return str(repo_dir)\\n\\n# 테스트 내 사용 예시 (96라인)\\n# file_path = os.path.join(temp_repo_with_files, \\\"file.txt\\\")\", \"improved_code\": \"from pathlib import Path # 파일 상단에 추가\\n\\n@pytest.fixture\\ndef temp_repo_with_files(tmpdir) -> Path:\\n    # ...\\n    repo_dir = Path(tmpdir.mkdir(\\\"repo\\\"))\\n    # ...\\n    return repo_dir\\n\\n# 테스트 내 사용 예시\\n# file_path = temp_repo_with_files / \\\"file.txt\\\"\"}], \"summary\": \"제공된 Python 테스트 파일들은 file_utils의 세 가지 함수(find_project_root, is_binary_file, load_file_content)에 대해 전반적으로 양호한 테스트 커버리지를 보여줍니다. 긍정적 및 부정적 시나리오, 캐싱 동작 등을 포함하여 다양한 케이스를 테스트하고 있습니다. 주요 개선 영역으로는 경로 객체 비교 표준화, is_binary_file 테스트에서 특정 파일 유형 분류 로직(또는 테스트 기대치) 검토, 테스트 내 경로 조작 일관성 향상 등이 있습니다.\", \"score\": 7.5, \"recommendations\": [\"파일 유형 분류 검증: is_binary_file 함수(또는 해당 함수의 테스트)에서 .gitignore, .env, .properties와 같은 파일들의 분류 로직을 면밀히 검토하십시오. 일반적인 사용 및 내용에 따라 텍스트 또는 바이너리로 올바르게 분류되는지 확인해야 합니다.\", \"pathlib 일관성 유지: 경로 조작 및 비교 시 문자열 변환이나 os.path 모듈 대신 pathlib.Path 객체와 관련 메서드/연산자를 일관되게 사용하는 것을 선호하십시오. 이는 테스트 코드와 유틸리티 함수 자체 모두에 적용될 수 있습니다.\", \"테스트 설정/해제 명확성 유지: 각 테스트 시작 시 cache_clear()를 사용하는 것은 명시적이지만, 더 큰 테스트 클래스나 복잡한 설정/해제 로직의 경우 pytest의 setup_method, teardown_method 또는 사용자 정의 픽스처를 사용하여 캐시 정리와 같은 상태 관리를 함으로써 보일러플레이트를 줄이는 것을 고려하십시오.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway_request.py\\\", \\\"file_content\\\": \\\"import unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\n\\\\nclass TestRequestParamsCreation(unittest.TestCase):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로바이더별 요청 파라미터 생성 테스트\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_openai_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_claude_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"max_tokens\\\\\\\"], 8192)  # Claude 특정 파라미터\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_google_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n        self.assertIn(\\\\\\\"contents\\\\\\\", params)  # Google API 요청 형식에 맞게 변환됨\\\\n        self.assertIn(\\\\\\\"config\\\\\\\", params)  # Google API 구성 포함\\\\n        # config의 시스템 지시 검증\\\\n        self.assertEqual(\\\\n            params[\\\\\\\"config\\\\\\\"].system_instruction, \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"\\\\n        )\\\\n        # 온도 설정 검증\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].temperature, 0.0)\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_mime_type, \\\\\\\"application/json\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_schema, StructuredReviewResponse)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\n\\\\nclass TestRequestParamsCreation(unittest.TestCase):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로바이더별 요청 파라미터 생성 테스트\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_openai_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_claude_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"max_tokens\\\\\\\"], 8192)  # Claude 특정 파라미터\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_google_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n        self.assertIn(\\\\\\\"contents\\\\\\\", params)  # Google API 요청 형식에 맞게 변환됨\\\\n        self.assertIn(\\\\\\\"config\\\\\\\", params)  # Google API 구성 포함\\\\n        # config의 시스템 지시 검증\\\\n        self.assertEqual(\\\\n            params[\\\\\\\"config\\\\\\\"].system_instruction, \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"\\\\n        )\\\\n        # 온도 설정 검증\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].temperature, 0.0)\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_mime_type, \\\\\\\"application/json\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_schema, StructuredReviewResponse)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway_review_code.py\\\", \\\"file_content\\\": \\\"import json\\\\nfrom typing import Any\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nimport instructor\\\\nimport pytest\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, ModelParamsDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, SystemPrompt, UserPrompt\\\\nfrom reviewer.src.utils.token.models import (\\\\n    EstimatedCost,\\\\n    IssueSeverityEnum,\\\\n    ReviewResponse,\\\\n    StructuredReviewIssue,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.0}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef google_model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.1}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"google-test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"google-test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 Google 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef review_prompt_fixture() -> ReviewPrompt:\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"def example(): pass\\\\\\\",\\\\n        modified_code=\\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    return ReviewPrompt(system_prompt=system_prompt, user_prompts=[user_prompt])\\\\n\\\\n\\\\nclass MockBaseGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BaseGateway 추상 클래스를 상속받은 테스트용 구현체\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self, model_info: ModelInfoDict, api_key: str | None = \\\\\\\"fake-api-key\\\\\\\"\\\\n    ) -> None:\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = api_key if api_key is not None else self._load_api_key()\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        return \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        return {\\\\\\\"model\\\\\\\": self.get_model_name(), \\\\\\\"messages\\\\\\\": messages}\\\\n\\\\n    def get_model_name(self):\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self):\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request(\\\\n    mock_save_prompt,\\\\n    mock_estimate_cost,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"정상적인 prepare_review_request 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=1500,\\\\n        input_cost_usd=0.0015,\\\\n        estimated_output_tokens=500,\\\\n        estimated_output_cost_usd=0.0025,\\\\n        estimated_total_cost_usd=0.004,\\\\n        within_context_limit=True,\\\\n    )\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    gateway.prepare_review_request(review_prompt_fixture)\\\\n\\\\n    mock_estimate_cost.assert_called_once_with(review_prompt_fixture)\\\\n    mock_save_prompt.assert_called_once()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request_context_limit_exceeded(\\\\n    mock_save_prompt, mock_estimate_cost, model_info_fixture: ModelInfoDict\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"컨텍스트 제한 초과 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=5000,\\\\n        input_cost_usd=0.005,\\\\n        estimated_output_tokens=1000,\\\\n        estimated_output_cost_usd=0.005,\\\\n        estimated_total_cost_usd=0.01,\\\\n        within_context_limit=False,\\\\n    )\\\\n\\\\n    temp_model_info_for_test = model_info_fixture.copy()\\\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\\\n    temp_model_info_for_test[\\\\\\\"context_limit\\\\\\\"] = 4000\\\\n\\\\n    gateway = MockBaseGateway(temp_model_info_for_test)\\\\n\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        modified_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    review_prompt = ReviewPrompt(\\\\n        system_prompt=system_prompt, user_prompts=[user_prompt]\\\\n    )\\\\n\\\\n    with pytest.raises(ContextLimitExceededError) as excinfo:\\\\n        gateway.prepare_review_request(review_prompt)\\\\n\\\\n    assert \\\\\\\"5000\\\\\\\" in str(excinfo.value)\\\\n    assert \\\\\\\"4000\\\\\\\" in str(excinfo.value)\\\\n    mock_save_prompt.assert_not_called()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_instructor(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Instructor 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n\\\\n    # 테스트용 상세 응답 데이터\\\\n    expected_issues_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"함수에 구현 내용이 없습니다.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 1,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"example.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"함수에 의미 있는 구현을 추가하세요.\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.WARNING,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def example(): pass\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        },\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"suggestion\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"변수명을 더 명확하게 변경하세요.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 5,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"another_module.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"예: `data_list` -> `user_records`\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.INFO,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"data = get_data()\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"user_records = get_data()\\\\\\\",\\\\n        },\\\\n    ]\\\\n    expected_summary = \\\\\\\"코드에 몇 가지 개선 사항이 있습니다.\\\\\\\"\\\\n    expected_score = 75.0\\\\n    expected_recommendations = [\\\\\\\"명확한 변수명 사용\\\\\\\", \\\\\\\"함수 구현 추가\\\\\\\"]\\\\n\\\\n    structured_response_data = StructuredReviewResponse(\\\\n        issues=[StructuredReviewIssue(**data) for data in expected_issues_data],\\\\n        summary=expected_summary,\\\\n        score=expected_score,\\\\n        recommendations=expected_recommendations,\\\\n    )\\\\n    mock_completions.create.return_value = structured_response_data\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"messages\\\\\\\": [],\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        }\\\\n        gateway = MockBaseGateway(model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary\\\\n        assert response.score == expected_score\\\\n        assert response.recommendations == expected_recommendations\\\\n        assert len(response.issues) == len(expected_issues_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"].value\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_genai(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"genai 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n\\\\n    expected_issues_raw_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"genai: 함수 구현 필요\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": \\\\\\\"warning\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 10,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"main.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"빠르게 구현해주세요.\\\\\\\",\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def main():\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def main():\\\\\\\\\\\\\\\\n    print('Hello from GenAI')\\\\\\\",\\\\n        }\\\\n    ]\\\\n    expected_summary_genai = \\\\\\\"GenAI 리뷰: 요약입니다.\\\\\\\"\\\\n    expected_score_genai = 80.0\\\\n    expected_recommendations_genai = [\\\\\\\"GenAI 권장 사항1\\\\\\\", \\\\\\\"GenAI 권장 사항2\\\\\\\"]\\\\n\\\\n    # JSON 문자열 생성 시, 내부 문자열 값에 포함된 특수문자가 올바르게 이스케이프되도록 직접 구성\\\\n    # json.dumps를 문자열 전체가 아닌, 개별 문자열 값에만 적용하거나, 수동으로 이스케이프\\\\n    issues_list_for_json = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": expected_issues_raw_data[0][\\\\\\\"type\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": expected_issues_raw_data[0][\\\\\\\"description\\\\\\\"],\\\\n            \\\\\\\"severity\\\\\\\": expected_issues_raw_data[0][\\\\\\\"severity\\\\\\\"],\\\\n            \\\\\\\"line_number\\\\\\\": expected_issues_raw_data[0][\\\\\\\"line_number\\\\\\\"],\\\\n            \\\\\\\"file\\\\\\\": expected_issues_raw_data[0][\\\\\\\"file\\\\\\\"],\\\\n            \\\\\\\"suggestion\\\\\\\": expected_issues_raw_data[0][\\\\\\\"suggestion\\\\\\\"],\\\\n            \\\\\\\"original_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"original_code\\\\\\\"],\\\\n            \\\\\\\"improved_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"improved_code\\\\\\\"],\\\\n        }\\\\n    ]\\\\n\\\\n    mock_genai_response.text = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    {{\\\\n        \\\\\\\"issues\\\\\\\": {json.dumps(issues_list_for_json)},\\\\n        \\\\\\\"summary\\\\\\\": \\\\\\\"{expected_summary_genai}\\\\\\\", \\\\n        \\\\\\\"score\\\\\\\": {expected_score_genai}, \\\\n        \\\\\\\"recommendations\\\\\\\": {json.dumps(expected_recommendations_genai)}\\\\n    }}\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": google_model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"content\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": MagicMock(),\\\\n        }\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary_genai\\\\n        assert response.score == expected_score_genai\\\\n        assert response.recommendations == expected_recommendations_genai\\\\n        assert len(response.issues) == len(expected_issues_raw_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_raw_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"]\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_empty_response(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 응답 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n    mock_completions.create.return_value = None\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"비어있\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_error_handling(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"예외 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_create_client.side_effect = Exception(\\\\\\\"API 호출 중 오류 발생\\\\\\\")\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"오류 발생\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_parsing_error(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google API 응답 파싱 오류 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n    mock_genai_response.text = \\\\\\\"\\\\\\\"\\\\\\\"{\\\\\\\"issues\\\\\\\": [{\\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\", \\\\\\\"description\\\\\\\": \\\\\\\"desc\\\\\\\", \\\\\\\"line_number\\\\\\\": invalid_value}]}\\\\\\\"\\\\\\\"\\\\\\\"  # 잘못된 JSON\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\"):\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        assert len(response.issues) == 0\\\\n        assert \\\\\\\"API 처리 중 오류\\\\\\\" in response.summary\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    pytest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport json\\\\nfrom typing import Any\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nimport instructor\\\\nimport pytest\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, ModelParamsDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, SystemPrompt, UserPrompt\\\\nfrom reviewer.src.utils.token.models import (\\\\n    EstimatedCost,\\\\n    IssueSeverityEnum,\\\\n    ReviewResponse,\\\\n    StructuredReviewIssue,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.0}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef google_model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.1}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"google-test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"google-test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 Google 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef review_prompt_fixture() -> ReviewPrompt:\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"def example(): pass\\\\\\\",\\\\n        modified_code=\\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    return ReviewPrompt(system_prompt=system_prompt, user_prompts=[user_prompt])\\\\n\\\\n\\\\nclass MockBaseGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BaseGateway 추상 클래스를 상속받은 테스트용 구현체\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self, model_info: ModelInfoDict, api_key: str | None = \\\\\\\"fake-api-key\\\\\\\"\\\\n    ) -> None:\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = api_key if api_key is not None else self._load_api_key()\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        return \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        return {\\\\\\\"model\\\\\\\": self.get_model_name(), \\\\\\\"messages\\\\\\\": messages}\\\\n\\\\n    def get_model_name(self):\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self):\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request(\\\\n    mock_save_prompt,\\\\n    mock_estimate_cost,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"정상적인 prepare_review_request 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=1500,\\\\n        input_cost_usd=0.0015,\\\\n        estimated_output_tokens=500,\\\\n        estimated_output_cost_usd=0.0025,\\\\n        estimated_total_cost_usd=0.004,\\\\n        within_context_limit=True,\\\\n    )\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    gateway.prepare_review_request(review_prompt_fixture)\\\\n\\\\n    mock_estimate_cost.assert_called_once_with(review_prompt_fixture)\\\\n    mock_save_prompt.assert_called_once()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request_context_limit_exceeded(\\\\n    mock_save_prompt, mock_estimate_cost, model_info_fixture: ModelInfoDict\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"컨텍스트 제한 초과 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=5000,\\\\n        input_cost_usd=0.005,\\\\n        estimated_output_tokens=1000,\\\\n        estimated_output_cost_usd=0.005,\\\\n        estimated_total_cost_usd=0.01,\\\\n        within_context_limit=False,\\\\n    )\\\\n\\\\n    temp_model_info_for_test = model_info_fixture.copy()\\\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\\\n    temp_model_info_for_test[\\\\\\\"context_limit\\\\\\\"] = 4000\\\\n\\\\n    gateway = MockBaseGateway(temp_model_info_for_test)\\\\n\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        modified_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    review_prompt = ReviewPrompt(\\\\n        system_prompt=system_prompt, user_prompts=[user_prompt]\\\\n    )\\\\n\\\\n    with pytest.raises(ContextLimitExceededError) as excinfo:\\\\n        gateway.prepare_review_request(review_prompt)\\\\n\\\\n    assert \\\\\\\"5000\\\\\\\" in str(excinfo.value)\\\\n    assert \\\\\\\"4000\\\\\\\" in str(excinfo.value)\\\\n    mock_save_prompt.assert_not_called()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_instructor(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Instructor 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n\\\\n    # 테스트용 상세 응답 데이터\\\\n    expected_issues_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"함수에 구현 내용이 없습니다.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 1,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"example.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"함수에 의미 있는 구현을 추가하세요.\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.WARNING,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def example(): pass\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        },\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"suggestion\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"변수명을 더 명확하게 변경하세요.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 5,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"another_module.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"예: `data_list` -> `user_records`\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.INFO,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"data = get_data()\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"user_records = get_data()\\\\\\\",\\\\n        },\\\\n    ]\\\\n    expected_summary = \\\\\\\"코드에 몇 가지 개선 사항이 있습니다.\\\\\\\"\\\\n    expected_score = 75.0\\\\n    expected_recommendations = [\\\\\\\"명확한 변수명 사용\\\\\\\", \\\\\\\"함수 구현 추가\\\\\\\"]\\\\n\\\\n    structured_response_data = StructuredReviewResponse(\\\\n        issues=[StructuredReviewIssue(**data) for data in expected_issues_data],\\\\n        summary=expected_summary,\\\\n        score=expected_score,\\\\n        recommendations=expected_recommendations,\\\\n    )\\\\n    mock_completions.create.return_value = structured_response_data\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"messages\\\\\\\": [],\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        }\\\\n        gateway = MockBaseGateway(model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary\\\\n        assert response.score == expected_score\\\\n        assert response.recommendations == expected_recommendations\\\\n        assert len(response.issues) == len(expected_issues_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"].value\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_genai(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"genai 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n\\\\n    expected_issues_raw_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"genai: 함수 구현 필요\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": \\\\\\\"warning\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 10,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"main.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"빠르게 구현해주세요.\\\\\\\",\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def main():\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def main():\\\\\\\\\\\\\\\\n    print('Hello from GenAI')\\\\\\\",\\\\n        }\\\\n    ]\\\\n    expected_summary_genai = \\\\\\\"GenAI 리뷰: 요약입니다.\\\\\\\"\\\\n    expected_score_genai = 80.0\\\\n    expected_recommendations_genai = [\\\\\\\"GenAI 권장 사항1\\\\\\\", \\\\\\\"GenAI 권장 사항2\\\\\\\"]\\\\n\\\\n    # JSON 문자열 생성 시, 내부 문자열 값에 포함된 특수문자가 올바르게 이스케이프되도록 직접 구성\\\\n    # json.dumps를 문자열 전체가 아닌, 개별 문자열 값에만 적용하거나, 수동으로 이스케이프\\\\n    issues_list_for_json = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": expected_issues_raw_data[0][\\\\\\\"type\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": expected_issues_raw_data[0][\\\\\\\"description\\\\\\\"],\\\\n            \\\\\\\"severity\\\\\\\": expected_issues_raw_data[0][\\\\\\\"severity\\\\\\\"],\\\\n            \\\\\\\"line_number\\\\\\\": expected_issues_raw_data[0][\\\\\\\"line_number\\\\\\\"],\\\\n            \\\\\\\"file\\\\\\\": expected_issues_raw_data[0][\\\\\\\"file\\\\\\\"],\\\\n            \\\\\\\"suggestion\\\\\\\": expected_issues_raw_data[0][\\\\\\\"suggestion\\\\\\\"],\\\\n            \\\\\\\"original_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"original_code\\\\\\\"],\\\\n            \\\\\\\"improved_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"improved_code\\\\\\\"],\\\\n        }\\\\n    ]\\\\n\\\\n    mock_genai_response.text = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    {{\\\\n        \\\\\\\"issues\\\\\\\": {json.dumps(issues_list_for_json)},\\\\n        \\\\\\\"summary\\\\\\\": \\\\\\\"{expected_summary_genai}\\\\\\\", \\\\n        \\\\\\\"score\\\\\\\": {expected_score_genai}, \\\\n        \\\\\\\"recommendations\\\\\\\": {json.dumps(expected_recommendations_genai)}\\\\n    }}\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": google_model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"content\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": MagicMock(),\\\\n        }\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary_genai\\\\n        assert response.score == expected_score_genai\\\\n        assert response.recommendations == expected_recommendations_genai\\\\n        assert len(response.issues) == len(expected_issues_raw_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_raw_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"]\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_empty_response(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 응답 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n    mock_completions.create.return_value = None\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"비어있\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_error_handling(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"예외 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_create_client.side_effect = Exception(\\\\\\\"API 호출 중 오류 발생\\\\\\\")\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"오류 발생\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_parsing_error(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google API 응답 파싱 오류 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n    mock_genai_response.text = \\\\\\\"\\\\\\\"\\\\\\\"{\\\\\\\"issues\\\\\\\": [{\\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\", \\\\\\\"description\\\\\\\": \\\\\\\"desc\\\\\\\", \\\\\\\"line_number\\\\\\\": invalid_value}]}\\\\\\\"\\\\\\\"\\\\\\\"  # 잘못된 JSON\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\"):\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        assert len(response.issues) == 0\\\\n        assert \\\\\\\"API 처리 중 오류\\\\\\\" in response.summary\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    pytest.main()\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 16, \"file\": \"tests/test_llm_gateway_request.py\", \"description\": \"`messages` 딕셔너리 리스트가 `test_openai_create_request_params`, `test_claude_create_request_params`, `test_google_create_request_params` 세 테스트 메소드에 중복되어 사용되고 있습니다. 이로 인해 테스트 메시지 변경 시 여러 곳을 수정해야 하는 번거로움이 있고, 코드 가독성을 저해할 수 있습니다.\", \"suggestion\": \"중복되는 `messages`를 클래스 변수나 테스트 클래스 외부의 상수로 정의하여 재사용성을 높이고 유지보수를 용이하게 하는 것이 좋습니다. 예를 들어, 클래스 레벨에 `COMMON_TEST_MESSAGES` 상수를 정의하고 각 테스트 메소드에서 이를 참조하도록 변경합니다.\", \"severity\": \"info\", \"original_code\": \"        # 테스트 메시지\\n        messages = [\\n            {\\\"role\\\": \\\"system\\\", \\\"content\\\": \\\"시스템 지시: 코드 리뷰를 수행하세요.\\\"},\\n            {\\n                \\\"role\\\": \\\"user\\\",\\n                \\\"content\\\": \\\"이 코드를 검토해주세요: def hello(): print('world')\\\",\\n            },\\n        ]\", \"improved_code\": \"# At class level or module level\\nCOMMON_TEST_MESSAGES = [\\n    {\\\"role\\\": \\\"system\\\", \\\"content\\\": \\\"시스템 지시: 코드 리뷰를 수행하세요.\\\"},\\n    {\\n        \\\"role\\\": \\\"user\\\",\\n        \\\"content\\\": \\\"이 코드를 검토해주세요: def hello(): print('world')\\\",\\n    },\\n]\\n\\nclass TestRequestParamsCreation(unittest.TestCase):\\n    # ...\\n    def test_openai_create_request_params(self, mock_get_api_key):\\n        # 설정\\n        mock_get_api_key.return_value = \\\"fake-api-key\\\"\\n        gateway = GatewayFactory.create(\\\"gpt-4o\\\")\\n\\n        # 테스트 메시지\\n        messages = COMMON_TEST_MESSAGES\\n\\n        # 테스트 실행\\n        params = gateway._create_request_params(messages)\\n\\n        # 검증\\n        self.assertEqual(params[\\\"model\\\"], \\\"gpt-4o\\\")\\n        self.assertEqual(params[\\\"messages\\\"], messages)\\n        self.assertEqual(params[\\\"temperature\\\"], 0.0)  # 모델의 기본 파라미터\"}, {\"type\": \"버그\", \"line_number\": 250, \"file\": \"tests/test_llm_gateway_review_code.py\", \"description\": \"`test_review_code_success_with_genai` 테스트에서 `mock_genai_response.text`를 생성할 때 f-string과 `json.dumps()`를 혼합하여 사용하고 있습니다. 이 방식은 JSON 구조가 복잡해지거나 문자열 내에 특수 문자가 포함될 경우 이스케이프 문제를 일으키거나 가독성을 해칠 수 있어 잠재적인 버그 발생 가능성이 있습니다.\", \"suggestion\": \"전체 응답 데이터를 파이썬 딕셔너리로 구성한 후, `json.dumps()`를 한 번만 호출하여 전체 JSON 문자열을 생성하는 것이 더 안전하고 가독성이 좋습니다. 이렇게 하면 JSON 형식 오류를 방지하고 코드를 더 쉽게 이해할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"    mock_genai_response.text = f\\\"\\\"\\\"\\n    {{\\n        \\\"issues\\\": {json.dumps(issues_list_for_json)},\\n        \\\"summary\\\": \\\"{expected_summary_genai}\\\", \\n        \\\"score\\\": {expected_score_genai}, \\n        \\\"recommendations\\\": {json.dumps(expected_recommendations_genai)}\\n    }}\\n    \\\"\\\"\\\"\", \"improved_code\": \"    response_data_dict = {\\n        \\\"issues\\\": issues_list_for_json,\\n        \\\"summary\\\": expected_summary_genai,\\n        \\\"score\\\": expected_score_genai,\\n        \\\"recommendations\\\": expected_recommendations_genai\\n    }\\n    mock_genai_response.text = json.dumps(response_data_dict)\"}, {\"type\": \"스타일\", \"line_number\": 110, \"file\": \"tests/test_llm_gateway_review_code.py\", \"description\": \"`test_prepare_review_request_context_limit_exceeded` 함수 내에서 `temp_model_info_for_test`의 타입을 `Any`로 캐스팅한 후 `context_limit` 키를 추가하고 있습니다. 이는 `ModelInfoDict` 타입 정의에 `context_limit`이 없기 때문으로 보이며, 타입 안정성을 저해하고 코드의 의도를 불명확하게 만들 수 있습니다.\", \"suggestion\": \"`ModelInfoDict` 또는 그 내부의 `ModelParamsDict` 타입 정의에 `context_limit` 필드를 선택적(Optional)으로 추가하는 것을 고려해 보세요. 이렇게 하면 타입 캐스팅 없이 안전하게 값을 할당하고, 모델 정보 구조를 더 명확하게 만들 수 있습니다. 예를 들어, `ModelInfoDict`에 `context_limit: NotRequired[int]`를 추가할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"    temp_model_info_for_test = model_info_fixture.copy()\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\n    temp_model_info_for_test[\\\"context_limit\\\"] = 4000\", \"improved_code\": \"# In type definition (e.g., reviewer/src/available_models.py):\\n# class ModelInfoDict(TypedDict):\\n#     full_name: str\\n#     aliases: list[str]\\n#     description: str\\n#     provider: str\\n#     params: ModelParamsDict\\n#     context_limit: NotRequired[int]  # Add this line\\n\\n# In the test (tests/test_llm_gateway_review_code.py):\\n    temp_model_info_for_test = model_info_fixture.copy()\\n    temp_model_info_for_test[\\\"context_limit\\\"] = 4000 # No 'Any' cast needed if type definition is updated\\n\\n    gateway = MockBaseGateway(temp_model_info_for_test)\"}], \"summary\": \"두 개의 새로운 테스트 파일 (`test_llm_gateway_request.py`, `test_llm_gateway_review_code.py`)이 추가되었습니다. `test_llm_gateway_request.py`는 다양한 LLM 프로바이더(OpenAI, Claude, Google)에 대한 요청 파라미터 생성 로직을 검증합니다. `test_llm_gateway_review_code.py`는 `BaseGateway`의 코드 리뷰 준비 및 실행 로직, 컨텍스트 제한 처리, 다양한 응답 시나리오(성공, 빈 응답, 오류)를 `pytest`와 모의 객체를 사용하여 종합적으로 테스트합니다. 이를 통해 LLM 게이트웨이 기능의 안정성 및 커버리지가 향상되었습니다.\", \"score\": 8.5, \"recommendations\": [\"테스트 데이터의 중복을 줄이고 재사용성을 높이기 위해 공통 메시지나 설정은 상수로 추출하거나 pytest 픽스처를 적극적으로 활용하세요.\", \"타입 힌트를 명확히 하고 `TypedDict`를 사용할 때 `Any` 캐스팅을 최소화하도록 타입 정의를 개선하여 코드 안정성과 가독성을 높이세요.\", \"모의 API 응답으로 사용될 JSON 문자열을 생성할 때는 f-string과 `json.dumps`를 혼용하기보다, 파이썬 딕셔너리를 먼저 구성한 후 전체를 `json.dumps`하는 것이 안전합니다.\", \"프로젝트 내 테스트 프레임워크 사용의 일관성을 고려하세요 (현재 `unittest`와 `pytest` 혼용 중). 단일 프레임워크로 통일하면 테스트 관리 및 실행이 용이해질 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway_request.py\\\", \\\"file_content\\\": \\\"import unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\n\\\\nclass TestRequestParamsCreation(unittest.TestCase):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로바이더별 요청 파라미터 생성 테스트\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_openai_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_claude_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"max_tokens\\\\\\\"], 8192)  # Claude 특정 파라미터\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_google_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n        self.assertIn(\\\\\\\"contents\\\\\\\", params)  # Google API 요청 형식에 맞게 변환됨\\\\n        self.assertIn(\\\\\\\"config\\\\\\\", params)  # Google API 구성 포함\\\\n        # config의 시스템 지시 검증\\\\n        self.assertEqual(\\\\n            params[\\\\\\\"config\\\\\\\"].system_instruction, \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"\\\\n        )\\\\n        # 온도 설정 검증\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].temperature, 0.0)\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_mime_type, \\\\\\\"application/json\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_schema, StructuredReviewResponse)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\n\\\\nclass TestRequestParamsCreation(unittest.TestCase):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로바이더별 요청 파라미터 생성 테스트\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_openai_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_claude_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"messages\\\\\\\"], messages)\\\\n        self.assertEqual(params[\\\\\\\"max_tokens\\\\\\\"], 8192)  # Claude 특정 파라미터\\\\n        self.assertEqual(params[\\\\\\\"temperature\\\\\\\"], 0.0)  # 모델의 기본 파라미터\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_google_create_request_params(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 게이트웨이의 요청 파라미터 생성을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 설정\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 테스트 메시지\\\\n        messages = [\\\\n            {\\\\\\\"role\\\\\\\": \\\\\\\"system\\\\\\\", \\\\\\\"content\\\\\\\": \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"},\\\\n            {\\\\n                \\\\\\\"role\\\\\\\": \\\\\\\"user\\\\\\\",\\\\n                \\\\\\\"content\\\\\\\": \\\\\\\"이 코드를 검토해주세요: def hello(): print('world')\\\\\\\",\\\\n            },\\\\n        ]\\\\n\\\\n        # 테스트 실행\\\\n        params = gateway._create_request_params(messages)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(params[\\\\\\\"model\\\\\\\"], \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n        self.assertIn(\\\\\\\"contents\\\\\\\", params)  # Google API 요청 형식에 맞게 변환됨\\\\n        self.assertIn(\\\\\\\"config\\\\\\\", params)  # Google API 구성 포함\\\\n        # config의 시스템 지시 검증\\\\n        self.assertEqual(\\\\n            params[\\\\\\\"config\\\\\\\"].system_instruction, \\\\\\\"시스템 지시: 코드 리뷰를 수행하세요.\\\\\\\"\\\\n        )\\\\n        # 온도 설정 검증\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].temperature, 0.0)\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_mime_type, \\\\\\\"application/json\\\\\\\")\\\\n        self.assertEqual(params[\\\\\\\"config\\\\\\\"].response_schema, StructuredReviewResponse)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway_review_code.py\\\", \\\"file_content\\\": \\\"import json\\\\nfrom typing import Any\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nimport instructor\\\\nimport pytest\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, ModelParamsDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, SystemPrompt, UserPrompt\\\\nfrom reviewer.src.utils.token.models import (\\\\n    EstimatedCost,\\\\n    IssueSeverityEnum,\\\\n    ReviewResponse,\\\\n    StructuredReviewIssue,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.0}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef google_model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.1}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"google-test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"google-test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 Google 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef review_prompt_fixture() -> ReviewPrompt:\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"def example(): pass\\\\\\\",\\\\n        modified_code=\\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    return ReviewPrompt(system_prompt=system_prompt, user_prompts=[user_prompt])\\\\n\\\\n\\\\nclass MockBaseGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BaseGateway 추상 클래스를 상속받은 테스트용 구현체\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self, model_info: ModelInfoDict, api_key: str | None = \\\\\\\"fake-api-key\\\\\\\"\\\\n    ) -> None:\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = api_key if api_key is not None else self._load_api_key()\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        return \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        return {\\\\\\\"model\\\\\\\": self.get_model_name(), \\\\\\\"messages\\\\\\\": messages}\\\\n\\\\n    def get_model_name(self):\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self):\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request(\\\\n    mock_save_prompt,\\\\n    mock_estimate_cost,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"정상적인 prepare_review_request 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=1500,\\\\n        input_cost_usd=0.0015,\\\\n        estimated_output_tokens=500,\\\\n        estimated_output_cost_usd=0.0025,\\\\n        estimated_total_cost_usd=0.004,\\\\n        within_context_limit=True,\\\\n    )\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    gateway.prepare_review_request(review_prompt_fixture)\\\\n\\\\n    mock_estimate_cost.assert_called_once_with(review_prompt_fixture)\\\\n    mock_save_prompt.assert_called_once()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request_context_limit_exceeded(\\\\n    mock_save_prompt, mock_estimate_cost, model_info_fixture: ModelInfoDict\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"컨텍스트 제한 초과 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=5000,\\\\n        input_cost_usd=0.005,\\\\n        estimated_output_tokens=1000,\\\\n        estimated_output_cost_usd=0.005,\\\\n        estimated_total_cost_usd=0.01,\\\\n        within_context_limit=False,\\\\n    )\\\\n\\\\n    temp_model_info_for_test = model_info_fixture.copy()\\\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\\\n    temp_model_info_for_test[\\\\\\\"context_limit\\\\\\\"] = 4000\\\\n\\\\n    gateway = MockBaseGateway(temp_model_info_for_test)\\\\n\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        modified_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    review_prompt = ReviewPrompt(\\\\n        system_prompt=system_prompt, user_prompts=[user_prompt]\\\\n    )\\\\n\\\\n    with pytest.raises(ContextLimitExceededError) as excinfo:\\\\n        gateway.prepare_review_request(review_prompt)\\\\n\\\\n    assert \\\\\\\"5000\\\\\\\" in str(excinfo.value)\\\\n    assert \\\\\\\"4000\\\\\\\" in str(excinfo.value)\\\\n    mock_save_prompt.assert_not_called()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_instructor(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Instructor 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n\\\\n    # 테스트용 상세 응답 데이터\\\\n    expected_issues_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"함수에 구현 내용이 없습니다.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 1,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"example.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"함수에 의미 있는 구현을 추가하세요.\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.WARNING,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def example(): pass\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        },\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"suggestion\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"변수명을 더 명확하게 변경하세요.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 5,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"another_module.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"예: `data_list` -> `user_records`\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.INFO,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"data = get_data()\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"user_records = get_data()\\\\\\\",\\\\n        },\\\\n    ]\\\\n    expected_summary = \\\\\\\"코드에 몇 가지 개선 사항이 있습니다.\\\\\\\"\\\\n    expected_score = 75.0\\\\n    expected_recommendations = [\\\\\\\"명확한 변수명 사용\\\\\\\", \\\\\\\"함수 구현 추가\\\\\\\"]\\\\n\\\\n    structured_response_data = StructuredReviewResponse(\\\\n        issues=[StructuredReviewIssue(**data) for data in expected_issues_data],\\\\n        summary=expected_summary,\\\\n        score=expected_score,\\\\n        recommendations=expected_recommendations,\\\\n    )\\\\n    mock_completions.create.return_value = structured_response_data\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"messages\\\\\\\": [],\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        }\\\\n        gateway = MockBaseGateway(model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary\\\\n        assert response.score == expected_score\\\\n        assert response.recommendations == expected_recommendations\\\\n        assert len(response.issues) == len(expected_issues_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"].value\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_genai(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"genai 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n\\\\n    expected_issues_raw_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"genai: 함수 구현 필요\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": \\\\\\\"warning\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 10,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"main.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"빠르게 구현해주세요.\\\\\\\",\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def main():\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def main():\\\\\\\\\\\\\\\\n    print('Hello from GenAI')\\\\\\\",\\\\n        }\\\\n    ]\\\\n    expected_summary_genai = \\\\\\\"GenAI 리뷰: 요약입니다.\\\\\\\"\\\\n    expected_score_genai = 80.0\\\\n    expected_recommendations_genai = [\\\\\\\"GenAI 권장 사항1\\\\\\\", \\\\\\\"GenAI 권장 사항2\\\\\\\"]\\\\n\\\\n    # JSON 문자열 생성 시, 내부 문자열 값에 포함된 특수문자가 올바르게 이스케이프되도록 직접 구성\\\\n    # json.dumps를 문자열 전체가 아닌, 개별 문자열 값에만 적용하거나, 수동으로 이스케이프\\\\n    issues_list_for_json = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": expected_issues_raw_data[0][\\\\\\\"type\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": expected_issues_raw_data[0][\\\\\\\"description\\\\\\\"],\\\\n            \\\\\\\"severity\\\\\\\": expected_issues_raw_data[0][\\\\\\\"severity\\\\\\\"],\\\\n            \\\\\\\"line_number\\\\\\\": expected_issues_raw_data[0][\\\\\\\"line_number\\\\\\\"],\\\\n            \\\\\\\"file\\\\\\\": expected_issues_raw_data[0][\\\\\\\"file\\\\\\\"],\\\\n            \\\\\\\"suggestion\\\\\\\": expected_issues_raw_data[0][\\\\\\\"suggestion\\\\\\\"],\\\\n            \\\\\\\"original_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"original_code\\\\\\\"],\\\\n            \\\\\\\"improved_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"improved_code\\\\\\\"],\\\\n        }\\\\n    ]\\\\n\\\\n    mock_genai_response.text = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    {{\\\\n        \\\\\\\"issues\\\\\\\": {json.dumps(issues_list_for_json)},\\\\n        \\\\\\\"summary\\\\\\\": \\\\\\\"{expected_summary_genai}\\\\\\\", \\\\n        \\\\\\\"score\\\\\\\": {expected_score_genai}, \\\\n        \\\\\\\"recommendations\\\\\\\": {json.dumps(expected_recommendations_genai)}\\\\n    }}\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": google_model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"content\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": MagicMock(),\\\\n        }\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary_genai\\\\n        assert response.score == expected_score_genai\\\\n        assert response.recommendations == expected_recommendations_genai\\\\n        assert len(response.issues) == len(expected_issues_raw_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_raw_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"]\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_empty_response(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 응답 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n    mock_completions.create.return_value = None\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"비어있\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_error_handling(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"예외 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_create_client.side_effect = Exception(\\\\\\\"API 호출 중 오류 발생\\\\\\\")\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"오류 발생\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_parsing_error(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google API 응답 파싱 오류 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n    mock_genai_response.text = \\\\\\\"\\\\\\\"\\\\\\\"{\\\\\\\"issues\\\\\\\": [{\\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\", \\\\\\\"description\\\\\\\": \\\\\\\"desc\\\\\\\", \\\\\\\"line_number\\\\\\\": invalid_value}]}\\\\\\\"\\\\\\\"\\\\\\\"  # 잘못된 JSON\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\"):\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        assert len(response.issues) == 0\\\\n        assert \\\\\\\"API 처리 중 오류\\\\\\\" in response.summary\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    pytest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport json\\\\nfrom typing import Any\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nimport instructor\\\\nimport pytest\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, ModelParamsDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, SystemPrompt, UserPrompt\\\\nfrom reviewer.src.utils.token.models import (\\\\n    EstimatedCost,\\\\n    IssueSeverityEnum,\\\\n    ReviewResponse,\\\\n    StructuredReviewIssue,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.0}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef google_model_info_fixture() -> ModelInfoDict:\\\\n    params: ModelParamsDict = {\\\\\\\"temperature\\\\\\\": 0.1}\\\\n    model_info: ModelInfoDict = {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"google-test-model-fixture\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"google-test-fixture\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Fixture를 사용한 Google 테스트용 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": params,\\\\n    }\\\\n    return model_info\\\\n\\\\n\\\\n@pytest.fixture\\\\ndef review_prompt_fixture() -> ReviewPrompt:\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"def example(): pass\\\\\\\",\\\\n        modified_code=\\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    return ReviewPrompt(system_prompt=system_prompt, user_prompts=[user_prompt])\\\\n\\\\n\\\\nclass MockBaseGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BaseGateway 추상 클래스를 상속받은 테스트용 구현체\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(\\\\n        self, model_info: ModelInfoDict, api_key: str | None = \\\\\\\"fake-api-key\\\\\\\"\\\\n    ) -> None:\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = api_key if api_key is not None else self._load_api_key()\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        return \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        return {\\\\\\\"model\\\\\\\": self.get_model_name(), \\\\\\\"messages\\\\\\\": messages}\\\\n\\\\n    def get_model_name(self):\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self):\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request(\\\\n    mock_save_prompt,\\\\n    mock_estimate_cost,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"정상적인 prepare_review_request 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=1500,\\\\n        input_cost_usd=0.0015,\\\\n        estimated_output_tokens=500,\\\\n        estimated_output_cost_usd=0.0025,\\\\n        estimated_total_cost_usd=0.004,\\\\n        within_context_limit=True,\\\\n    )\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    gateway.prepare_review_request(review_prompt_fixture)\\\\n\\\\n    mock_estimate_cost.assert_called_once_with(review_prompt_fixture)\\\\n    mock_save_prompt.assert_called_once()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.estimate_review_cost\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.save_prompt\\\\\\\")\\\\ndef test_prepare_review_request_context_limit_exceeded(\\\\n    mock_save_prompt, mock_estimate_cost, model_info_fixture: ModelInfoDict\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"컨텍스트 제한 초과 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_estimate_cost.return_value = EstimatedCost(\\\\n        model=model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n        input_tokens=5000,\\\\n        input_cost_usd=0.005,\\\\n        estimated_output_tokens=1000,\\\\n        estimated_output_cost_usd=0.005,\\\\n        estimated_total_cost_usd=0.01,\\\\n        within_context_limit=False,\\\\n    )\\\\n\\\\n    temp_model_info_for_test = model_info_fixture.copy()\\\\n    temp_model_info_for_test: Any = temp_model_info_for_test\\\\n    temp_model_info_for_test[\\\\\\\"context_limit\\\\\\\"] = 4000\\\\n\\\\n    gateway = MockBaseGateway(temp_model_info_for_test)\\\\n\\\\n    system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=\\\\\\\"코드를 분석하고 리뷰하세요.\\\\\\\")\\\\n    user_prompt = UserPrompt(\\\\n        hunk_idx=\\\\\\\"1\\\\\\\",\\\\n        file_name=\\\\\\\"example.py\\\\\\\",\\\\n        original_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        modified_code=\\\\\\\"매우 큰 코드 블록입니다...\\\\\\\" * 500,\\\\n        line_number=1,\\\\n        language=\\\\\\\"python\\\\\\\",\\\\n    )\\\\n    review_prompt = ReviewPrompt(\\\\n        system_prompt=system_prompt, user_prompts=[user_prompt]\\\\n    )\\\\n\\\\n    with pytest.raises(ContextLimitExceededError) as excinfo:\\\\n        gateway.prepare_review_request(review_prompt)\\\\n\\\\n    assert \\\\\\\"5000\\\\\\\" in str(excinfo.value)\\\\n    assert \\\\\\\"4000\\\\\\\" in str(excinfo.value)\\\\n    mock_save_prompt.assert_not_called()\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_instructor(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Instructor 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n\\\\n    # 테스트용 상세 응답 데이터\\\\n    expected_issues_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"함수에 구현 내용이 없습니다.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 1,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"example.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"함수에 의미 있는 구현을 추가하세요.\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.WARNING,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def example(): pass\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def example(): return 'Hello'\\\\\\\",\\\\n        },\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"suggestion\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"변수명을 더 명확하게 변경하세요.\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 5,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"another_module.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"예: `data_list` -> `user_records`\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": IssueSeverityEnum.INFO,\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"data = get_data()\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"user_records = get_data()\\\\\\\",\\\\n        },\\\\n    ]\\\\n    expected_summary = \\\\\\\"코드에 몇 가지 개선 사항이 있습니다.\\\\\\\"\\\\n    expected_score = 75.0\\\\n    expected_recommendations = [\\\\\\\"명확한 변수명 사용\\\\\\\", \\\\\\\"함수 구현 추가\\\\\\\"]\\\\n\\\\n    structured_response_data = StructuredReviewResponse(\\\\n        issues=[StructuredReviewIssue(**data) for data in expected_issues_data],\\\\n        summary=expected_summary,\\\\n        score=expected_score,\\\\n        recommendations=expected_recommendations,\\\\n    )\\\\n    mock_completions.create.return_value = structured_response_data\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"messages\\\\\\\": [],\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        }\\\\n        gateway = MockBaseGateway(model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary\\\\n        assert response.score == expected_score\\\\n        assert response.recommendations == expected_recommendations\\\\n        assert len(response.issues) == len(expected_issues_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"].value\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.save_raw_response\\\\\\\")\\\\ndef test_review_code_success_with_genai(\\\\n    mock_save_raw_response,\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"genai 클라이언트를 사용한 성공적인 리뷰 코드 호출을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n\\\\n    expected_issues_raw_data = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"genai: 함수 구현 필요\\\\\\\",\\\\n            \\\\\\\"severity\\\\\\\": \\\\\\\"warning\\\\\\\",\\\\n            \\\\\\\"line_number\\\\\\\": 10,\\\\n            \\\\\\\"file\\\\\\\": \\\\\\\"main.py\\\\\\\",\\\\n            \\\\\\\"suggestion\\\\\\\": \\\\\\\"빠르게 구현해주세요.\\\\\\\",\\\\n            \\\\\\\"original_code\\\\\\\": \\\\\\\"def main():\\\\\\\",\\\\n            \\\\\\\"improved_code\\\\\\\": \\\\\\\"def main():\\\\\\\\\\\\\\\\n    print('Hello from GenAI')\\\\\\\",\\\\n        }\\\\n    ]\\\\n    expected_summary_genai = \\\\\\\"GenAI 리뷰: 요약입니다.\\\\\\\"\\\\n    expected_score_genai = 80.0\\\\n    expected_recommendations_genai = [\\\\\\\"GenAI 권장 사항1\\\\\\\", \\\\\\\"GenAI 권장 사항2\\\\\\\"]\\\\n\\\\n    # JSON 문자열 생성 시, 내부 문자열 값에 포함된 특수문자가 올바르게 이스케이프되도록 직접 구성\\\\n    # json.dumps를 문자열 전체가 아닌, 개별 문자열 값에만 적용하거나, 수동으로 이스케이프\\\\n    issues_list_for_json = [\\\\n        {\\\\n            \\\\\\\"type\\\\\\\": expected_issues_raw_data[0][\\\\\\\"type\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": expected_issues_raw_data[0][\\\\\\\"description\\\\\\\"],\\\\n            \\\\\\\"severity\\\\\\\": expected_issues_raw_data[0][\\\\\\\"severity\\\\\\\"],\\\\n            \\\\\\\"line_number\\\\\\\": expected_issues_raw_data[0][\\\\\\\"line_number\\\\\\\"],\\\\n            \\\\\\\"file\\\\\\\": expected_issues_raw_data[0][\\\\\\\"file\\\\\\\"],\\\\n            \\\\\\\"suggestion\\\\\\\": expected_issues_raw_data[0][\\\\\\\"suggestion\\\\\\\"],\\\\n            \\\\\\\"original_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"original_code\\\\\\\"],\\\\n            \\\\\\\"improved_code\\\\\\\": expected_issues_raw_data[0][\\\\\\\"improved_code\\\\\\\"],\\\\n        }\\\\n    ]\\\\n\\\\n    mock_genai_response.text = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    {{\\\\n        \\\\\\\"issues\\\\\\\": {json.dumps(issues_list_for_json)},\\\\n        \\\\\\\"summary\\\\\\\": \\\\\\\"{expected_summary_genai}\\\\\\\", \\\\n        \\\\\\\"score\\\\\\\": {expected_score_genai}, \\\\n        \\\\\\\"recommendations\\\\\\\": {json.dumps(expected_recommendations_genai)}\\\\n    }}\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\") as mock_create_params:\\\\n        mock_create_params.return_value = {\\\\n            \\\\\\\"model\\\\\\\": google_model_info_fixture[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"content\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": MagicMock(),\\\\n        }\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response: ReviewResponse = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        mock_prepare_request.assert_called_once_with(review_prompt_fixture)\\\\n        mock_create_client.assert_called_once()\\\\n        mock_create_params.assert_called_once()\\\\n        mock_save_raw_response.assert_called_once()\\\\n\\\\n        assert response.summary == expected_summary_genai\\\\n        assert response.score == expected_score_genai\\\\n        assert response.recommendations == expected_recommendations_genai\\\\n        assert len(response.issues) == len(expected_issues_raw_data)\\\\n        for i, actual_issue in enumerate(response.issues):\\\\n            expected_issue_data = expected_issues_raw_data[i]\\\\n            assert actual_issue.type == expected_issue_data[\\\\\\\"type\\\\\\\"]\\\\n            assert actual_issue.description == expected_issue_data[\\\\\\\"description\\\\\\\"]\\\\n            assert actual_issue.line_number == expected_issue_data[\\\\\\\"line_number\\\\\\\"]\\\\n            assert actual_issue.file == expected_issue_data[\\\\\\\"file\\\\\\\"]\\\\n            assert actual_issue.suggestion == expected_issue_data[\\\\\\\"suggestion\\\\\\\"]\\\\n            assert actual_issue.severity == expected_issue_data[\\\\\\\"severity\\\\\\\"]\\\\n            assert actual_issue.original_code == expected_issue_data[\\\\\\\"original_code\\\\\\\"]\\\\n            assert actual_issue.improved_code == expected_issue_data[\\\\\\\"improved_code\\\\\\\"]\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_empty_response(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"빈 응답 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_instructor = MagicMock(spec=instructor.Instructor)\\\\n    mock_completions = MagicMock()\\\\n    mock_instructor.chat.completions = mock_completions\\\\n    mock_completions.create.return_value = None\\\\n    mock_create_client.return_value = mock_instructor\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"비어있\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_error_handling(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"예외 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_create_client.side_effect = Exception(\\\\\\\"API 호출 중 오류 발생\\\\\\\")\\\\n\\\\n    gateway = MockBaseGateway(model_info_fixture)\\\\n    response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n    assert len(response.issues) == 0\\\\n    assert \\\\\\\"오류 발생\\\\\\\" in response.summary\\\\n\\\\n\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway.prepare_review_request\\\\\\\")\\\\n@patch(\\\\\\\"reviewer.src.llm_gateway.base_gateway.BaseGateway._create_client\\\\\\\")\\\\ndef test_review_code_parsing_error(\\\\n    mock_create_client,\\\\n    mock_prepare_request,\\\\n    google_model_info_fixture: ModelInfoDict,\\\\n    review_prompt_fixture: ReviewPrompt,\\\\n):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google API 응답 파싱 오류 처리를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mock_genai_client = MagicMock(spec=genai.Client)\\\\n    mock_genai_models = MagicMock()\\\\n    mock_genai_client.models = mock_genai_models\\\\n    mock_genai_response = MagicMock()\\\\n    mock_genai_response.text = \\\\\\\"\\\\\\\"\\\\\\\"{\\\\\\\"issues\\\\\\\": [{\\\\\\\"type\\\\\\\": \\\\\\\"issue\\\\\\\", \\\\\\\"description\\\\\\\": \\\\\\\"desc\\\\\\\", \\\\\\\"line_number\\\\\\\": invalid_value}]}\\\\\\\"\\\\\\\"\\\\\\\"  # 잘못된 JSON\\\\n    mock_genai_models.generate_content.return_value = mock_genai_response\\\\n    mock_create_client.return_value = mock_genai_client\\\\n\\\\n    with patch.object(MockBaseGateway, \\\\\\\"_create_request_params\\\\\\\"):\\\\n        gateway = MockBaseGateway(google_model_info_fixture)\\\\n        response = gateway.review_code(review_prompt_fixture)\\\\n\\\\n        assert len(response.issues) == 0\\\\n        assert \\\\\\\"API 처리 중 오류\\\\\\\" in response.summary\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    pytest.main()\\\\n```\\\", \\\"line_number\\\": 1}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 170, \"file\": \"tests/test_llm_gateway_review_code.py\", \"description\": \"Google API 응답을 시뮬레이션하기 위해 JSON 문자열을 수동으로 구성하는 방식이 복잡하고 오류 발생 가능성이 있습니다. 특히 이스케이프 문자 처리가 까다로울 수 있습니다.\", \"suggestion\": \"예상되는 응답 구조를 Python 딕셔너리로 먼저 정의한 후, `json.dumps()`를 사용하여 전체 딕셔너리를 JSON 문자열로 변환하는 것이 더 명확하고 안전합니다.\", \"severity\": \"info\", \"original_code\": \"    mock_genai_response.text = f\\\"\\\"\\\"\\n    {{\\n        \\\"issues\\\": {json.dumps(issues_list_for_json)},\\n        \\\"summary\\\": \\\"{expected_summary_genai}\\\", \\n        \\\"score\\\": {expected_score_genai}, \\n        \\\"recommendations\\\": {json.dumps(expected_recommendations_genai)}\\n    }}\\n    \\\"\\\"\\\"\", \"improved_code\": \"    expected_response_dict = {\\n        \\\"issues\\\": issues_list_for_json,\\n        \\\"summary\\\": expected_summary_genai,\\n        \\\"score\\\": expected_score_genai,\\n        \\\"recommendations\\\": expected_recommendations_genai,\\n    }\\n    mock_genai_response.text = json.dumps(expected_response_dict)\"}, {\"type\": \"bug\", \"line_number\": 208, \"file\": \"tests/test_llm_gateway_review_code.py\", \"description\": \"Google GenAI 응답 테스트에서 이슈 심각도(severity)를 문자열로 직접 비교하고 있습니다. `StructuredReviewIssue` 모델이 심각도를 `IssueSeverityEnum`으로 파싱한다면, Instructor 테스트와 마찬가지로 Enum 값의 `.value`와 비교하는 것이 더 정확하고 일관적입니다.\", \"suggestion\": \"파싱된 심각도 값이 Enum이거나 Enum의 문자열 표현이라면, `IssueSeverityEnum(expected_issue_data[\\\"severity\\\"]).value`와 같이 Enum 값으로 변환하여 비교하거나, `actual_issue.severity`가 이미 Enum 값이라면 `.value`를 사용하여 비교하도록 수정하세요.\", \"severity\": \"info\", \"original_code\": \"            assert actual_issue.severity == expected_issue_data[\\\"severity\\\"]\", \"improved_code\": \"            assert actual_issue.severity == IssueSeverityEnum(expected_issue_data[\\\"severity\\\"]).value\"}], \"summary\": \"새로운 테스트 파일 두 개가 추가되었습니다. `test_llm_gateway_request.py`는 LLM 게이트웨이별 요청 파라미터 생성을 테스트하고, `test_llm_gateway_review_code.py`는 `BaseGateway`의 `review_code` 메서드 동작을 다양한 시나리오(성공, 컨텍스트 제한 초과, 빈 응답, 오류 처리, 파싱 오류)에 대해 테스트합니다. 전반적으로 테스트 커버리지를 높이는 좋은 변경입니다.\", \"score\": 9.0, \"recommendations\": [\"테스트 코드 전반에 걸쳐 일관된 테스트 프레임워크(예: pytest)를 사용하는 것을 고려해 볼 수 있습니다.\", \"Google GenAI 응답 시뮬레이션 시 JSON 문자열 생성 방식을 개선하여 가독성과 안정성을 높입니다.\", \"이슈 심각도 비교 로직을 `IssueSeverityEnum`을 활용하여 더 명확하고 일관되게 만듭니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 21}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/file_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n    \\\\\\\".exe\\\\\\\",\\\\n    \\\\\\\".dll\\\\\\\",\\\\n    \\\\\\\".so\\\\\\\",\\\\n    \\\\\\\".dylib\\\\\\\",\\\\n    \\\\\\\".bin\\\\\\\",\\\\n    \\\\\\\".o\\\\\\\",\\\\n    \\\\\\\".obj\\\\\\\",\\\\n    \\\\\\\".a\\\\\\\",\\\\n    \\\\\\\".lib\\\\\\\",\\\\n    # 압축 파일\\\\n    \\\\\\\".zip\\\\\\\",\\\\n    \\\\\\\".tar\\\\\\\",\\\\n    \\\\\\\".gz\\\\\\\",\\\\n    \\\\\\\".bz2\\\\\\\",\\\\n    \\\\\\\".xz\\\\\\\",\\\\n    \\\\\\\".jar\\\\\\\",\\\\n    \\\\\\\".war\\\\\\\",\\\\n    \\\\\\\".ear\\\\\\\",\\\\n    \\\\\\\".aar\\\\\\\",\\\\n    # 이미지 파일\\\\n    \\\\\\\".jpg\\\\\\\",\\\\n    \\\\\\\".jpeg\\\\\\\",\\\\n    \\\\\\\".png\\\\\\\",\\\\n    \\\\\\\".gif\\\\\\\",\\\\n    \\\\\\\".bmp\\\\\\\",\\\\n    \\\\\\\".tiff\\\\\\\",\\\\n    \\\\\\\".ico\\\\\\\",\\\\n    \\\\\\\".webp\\\\\\\",\\\\n    # 비디오/오디오 파일\\\\n    \\\\\\\".mp3\\\\\\\",\\\\n    \\\\\\\".mp4\\\\\\\",\\\\n    \\\\\\\".wav\\\\\\\",\\\\n    \\\\\\\".avi\\\\\\\",\\\\n    \\\\\\\".mov\\\\\\\",\\\\n    \\\\\\\".mkv\\\\\\\",\\\\n    \\\\\\\".flac\\\\\\\",\\\\n    \\\\\\\".ogg\\\\\\\",\\\\n    # 문서 파일\\\\n    \\\\\\\".pdf\\\\\\\",\\\\n    \\\\\\\".doc\\\\\\\",\\\\n    \\\\\\\".docx\\\\\\\",\\\\n    \\\\\\\".ppt\\\\\\\",\\\\n    \\\\\\\".pptx\\\\\\\",\\\\n    \\\\\\\".xls\\\\\\\",\\\\n    \\\\\\\".xlsx\\\\\\\",\\\\n    # 기타 바이너리 파일\\\\n    \\\\\\\".class\\\\\\\",\\\\n    \\\\\\\".pyc\\\\\\\",\\\\n    \\\\\\\".pyo\\\\\\\",\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 특수 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n    \\\\\\\".env.local\\\\\\\",\\\\n    \\\\\\\".env.development\\\\\\\",\\\\n    \\\\\\\".env.production\\\\\\\",\\\\n    \\\\\\\".env.test\\\\\\\",\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_binary_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 바이너리 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 바이너리 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 바이너리 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return ext in BINARY_EXTENSIONS or base_name in BINARY_FILENAMES\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(\\\\n            filename\\\\n        ):  # is_binary_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(\\\\n        f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다. 탐색 완료 경로: {current_dir}\\\\\\\"\\\\n    )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport os\\\\nfrom functools import lru_cache\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(\\\\n        f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다. 탐색 완료 경로: {current_dir}\\\\\\\"\\\\n    )\\\\n```\\\", \\\"line_number\\\": 158}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root, is_binary_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not review_request.use_full_context:\\\\n            raise ValueError(\\\\\\\"full context 플래그가 켜져있어야 합니다.\\\\\\\")\\\\n\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                if not request.file_content:\\\\n                    logger.warning(\\\\n                        f\\\\\\\"파일 내용이 없습니다. 파일 경로: {request.filename}\\\\\\\"\\\\n                    )\\\\n                    file_content = \\\\\\\"\\\\\\\"\\\\n                else:\\\\n                    file_content = request.file_content\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\n\\\\nfrom reviewer.src.utils.file_utils import find_project_root, is_binary_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n```\\\", \\\"line_number\\\": 15}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 `find_project_root` 유틸리티 함수를 `reviewer/src/utils/prompts/prompt_generator.py`에서 `reviewer/src/utils/file_utils.py`로 이동시키고, 관련 파일들의 import 구문을 업데이트합니다. 이는 파일 시스템 관련 유틸리티 함수를 전용 모듈에 배치하여 코드 구조와 모듈성을 개선하는 긍정적인 리팩토링입니다.\", \"score\": 9.0, \"recommendations\": [\"유틸리티 함수를 기능별로 분리하는 것은 좋은 코드 조직화 방법입니다. 앞으로도 유사한 유틸리티 함수는 적절한 유틸리티 모듈에 배치하는 것을 고려하세요.\", \"이동된 함수에 대한 테스트 코드가 있다면, 해당 테스트 코드도 새로운 위치에 맞게 업데이트되었는지 확인하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"file_content\\\": \\\"import re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_FILE_HEADER = re.compile(r\\\\\\\"^diff --git a/(\\\\\\\\S+) b/(\\\\\\\\S+)\\\\\\\", flags=re.MULTILINE)\\\\n\\\\n\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파싱하여 구조화된 DiffResult 객체를 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n\\\\n    Returns:\\\\n        DiffResult: Git diff 결과를 나타내는 객체\\\\n\\\\n    Raises:\\\\n        DiffParsingError: diff가 비어있거나 유효하지 않은 형식인 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not diff_text:\\\\n        raise DiffParsingError(\\\\\\\"빈 diff가 제공되었습니다.\\\\\\\")\\\\n\\\\n    file_diffs = _PATTERN_DIFF_SPLIT.split(diff_text)\\\\n    result = DiffResult()\\\\n\\\\n    for raw_diff in file_diffs:\\\\n        if not raw_diff.strip():\\\\n            continue\\\\n        header_match = _PATTERN_FILE_HEADER.search(raw_diff)\\\\n        if header_match:\\\\n            filename = header_match.group(2)\\\\n        else:\\\\n            continue\\\\n\\\\n        hunks = _PATTERN_HUNK_SPLIT.split(raw_diff)\\\\n        hunk_list = [\\\\n            Hunk.from_hunk_text(h) for h in hunks if h.lstrip().startswith(\\\\\\\"@@\\\\\\\")\\\\n        ]\\\\n\\\\n        if use_full_context:\\\\n            file_content = load_file_content(filename, repo_path)\\\\n        else:\\\\n            file_content = None\\\\n\\\\n        parsed_diff = FileDiff(\\\\n            filename=filename, file_content=file_content, hunks=hunk_list\\\\n        )\\\\n        parsed_diff.detect_language()\\\\n        parsed_diff.calculate_changes()\\\\n        result.files.append(parsed_diff)\\\\n\\\\n    if not result.files:\\\\n        raise DiffParsingError(\\\\\\\"유효하지 않은 diff 형식입니다.\\\\\\\")\\\\n\\\\n    return result\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils.prompts import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_binary_file, load_file_content\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import is_binary_file, load_file_content\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"load_file_content\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 21}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/file_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nfrom functools import lru_cache\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n    \\\\\\\".exe\\\\\\\",\\\\n    \\\\\\\".dll\\\\\\\",\\\\n    \\\\\\\".so\\\\\\\",\\\\n    \\\\\\\".dylib\\\\\\\",\\\\n    \\\\\\\".bin\\\\\\\",\\\\n    \\\\\\\".o\\\\\\\",\\\\n    \\\\\\\".obj\\\\\\\",\\\\n    \\\\\\\".a\\\\\\\",\\\\n    \\\\\\\".lib\\\\\\\",\\\\n    # 압축 파일\\\\n    \\\\\\\".zip\\\\\\\",\\\\n    \\\\\\\".tar\\\\\\\",\\\\n    \\\\\\\".gz\\\\\\\",\\\\n    \\\\\\\".bz2\\\\\\\",\\\\n    \\\\\\\".xz\\\\\\\",\\\\n    \\\\\\\".jar\\\\\\\",\\\\n    \\\\\\\".war\\\\\\\",\\\\n    \\\\\\\".ear\\\\\\\",\\\\n    \\\\\\\".aar\\\\\\\",\\\\n    # 이미지 파일\\\\n    \\\\\\\".jpg\\\\\\\",\\\\n    \\\\\\\".jpeg\\\\\\\",\\\\n    \\\\\\\".png\\\\\\\",\\\\n    \\\\\\\".gif\\\\\\\",\\\\n    \\\\\\\".bmp\\\\\\\",\\\\n    \\\\\\\".tiff\\\\\\\",\\\\n    \\\\\\\".ico\\\\\\\",\\\\n    \\\\\\\".webp\\\\\\\",\\\\n    # 비디오/오디오 파일\\\\n    \\\\\\\".mp3\\\\\\\",\\\\n    \\\\\\\".mp4\\\\\\\",\\\\n    \\\\\\\".wav\\\\\\\",\\\\n    \\\\\\\".avi\\\\\\\",\\\\n    \\\\\\\".mov\\\\\\\",\\\\n    \\\\\\\".mkv\\\\\\\",\\\\n    \\\\\\\".flac\\\\\\\",\\\\n    \\\\\\\".ogg\\\\\\\",\\\\n    # 문서 파일\\\\n    \\\\\\\".pdf\\\\\\\",\\\\n    \\\\\\\".doc\\\\\\\",\\\\n    \\\\\\\".docx\\\\\\\",\\\\n    \\\\\\\".ppt\\\\\\\",\\\\n    \\\\\\\".pptx\\\\\\\",\\\\n    \\\\\\\".xls\\\\\\\",\\\\n    \\\\\\\".xlsx\\\\\\\",\\\\n    # 기타 바이너리 파일\\\\n    \\\\\\\".class\\\\\\\",\\\\n    \\\\\\\".pyc\\\\\\\",\\\\n    \\\\\\\".pyo\\\\\\\",\\\\n    \\\\\\\".db\\\\\\\",\\\\n    \\\\\\\".sqlite\\\\\\\",\\\\n    \\\\\\\".dat\\\\\\\",\\\\n}\\\\n\\\\n# 특수 파일 이름 목록\\\\nBINARY_FILENAMES = {\\\\n    \\\\\\\"gradlew\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.jar\\\\\\\",\\\\n    \\\\\\\"mvnw\\\\\\\",\\\\n    \\\\\\\"mvnw.cmd\\\\\\\",\\\\n    \\\\\\\".DS_Store\\\\\\\",\\\\n    \\\\\\\"gradle-wrapper.properties\\\\\\\",\\\\n    \\\\\\\"gradlew.bat\\\\\\\",\\\\n    \\\\\\\".gitignore\\\\\\\",\\\\n    \\\\\\\".gitmodules\\\\\\\",\\\\n    \\\\\\\".gitconfig\\\\\\\",\\\\n    \\\\\\\".git\\\\\\\",\\\\n    \\\\\\\".env\\\\\\\",\\\\n    \\\\\\\".env.local\\\\\\\",\\\\n    \\\\\\\".env.development\\\\\\\",\\\\n    \\\\\\\".env.production\\\\\\\",\\\\n    \\\\\\\".env.test\\\\\\\",\\\\n    \\\\\\\".env.development.local\\\\\\\",\\\\n    \\\\\\\".env.production.local\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef is_binary_file(filename: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명이나 확장자를 기준으로 바이너리 파일인지 확인합니다.\\\\n\\\\n    Args:\\\\n        filename (str): 확인할 파일 경로\\\\n\\\\n    Returns:\\\\n        bool: 바이너리 파일이면 True, 아니면 False\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os.path\\\\n\\\\n    # 확장자 또는 파일명으로 바이너리 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return ext in BINARY_EXTENSIONS or base_name in BINARY_FILENAMES\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(\\\\n            filename\\\\n        ):  # is_binary_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport os\\\\nfrom functools import lru_cache\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"파일 관련 유틸리티 함수와 상수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# 제외할 바이너리/비텍스트 파일 확장자 목록\\\\nBINARY_EXTENSIONS = {\\\\n    # 실행 파일 및 라이브러리\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    # 확장자 또는 파일명으로 바이너리 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return ext in BINARY_EXTENSIONS or base_name in BINARY_FILENAMES\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 확장자 또는 파일명으로 바이너리 파일 확인\\\\n    _, ext = os.path.splitext(filename.lower())\\\\n    base_name = os.path.basename(filename)\\\\n\\\\n    return ext in BINARY_EXTENSIONS or base_name in BINARY_FILENAMES\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(\\\\n            filename\\\\n        ):  # is_binary_file은 같은 파일 내에 있으므로 바로 사용\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n```\\\", \\\"line_number\\\": 97}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 관련 유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\n\\\\n__all__ = [\\\\\\\"PromptGenerator\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 관련 유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    load_file_content,\\\\n)\\\\n\\\\n__all__ = [\\\\\\\"PromptGenerator\\\\\\\", \\\\\\\"load_file_content\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 관련 유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\n\\\\n__all__ = [\\\\\\\"PromptGenerator\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 1}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                if not request.file_content:\\\\n                    logger.warning(\\\\n                        f\\\\\\\"파일 내용이 없습니다. 파일 경로: {request.filename}\\\\\\\"\\\\n                    )\\\\n                    file_content = \\\\\\\"\\\\\\\"\\\\n                else:\\\\n                    file_content = request.file_content\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.logging.config import get_logger\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n```\\\", \\\"line_number\\\": 46}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                if not request.file_content:\\\\n                    logger.warning(\\\\n                        f\\\\\\\"파일 내용이 없습니다. 파일 경로: {request.filename}\\\\\\\"\\\\n                    )\\\\n                    file_content = \\\\\\\"\\\\\\\"\\\\n                else:\\\\n                    file_content = request.file_content\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n```\\\", \\\"line_number\\\": 149}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"tests/test_llm_gateway.py\\\", \\\"file_content\\\": \\\"import unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, get_model_info\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import (\\\\n    ClaudeGateway,\\\\n    GatewayFactory,\\\\n    GoogleGateway,\\\\n    OpenAIGateway,\\\\n)\\\\n\\\\n\\\\nclass TestOpenAIGateway(unittest.TestCase):\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_init_with_valid_model(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 키와 유효한 모델로 OpenAIGateway 초기화를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 모킹\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        # 테스트할 모델 가져오기\\\\n        model_info = get_model_info(\\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertIsNotNone(model_info)\\\\n\\\\n        # 게이트웨이 생성\\\\n        gateway = OpenAIGateway(model_info)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(gateway.model, model_info)\\\\n        mock_get_api_key.assert_called_once_with(\\\\\\\"openai\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_init_with_invalid_model_provider(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"잘못된 모델 제공자로 OpenAIGateway 초기화 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 모킹\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        # 실제 존재하는 Claude 모델 정보를 반환하도록 모킹\\\\n        claude_model_info: ModelInfoDict = {\\\\n            \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n            \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\"],\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Claude 모델\\\\\\\",\\\\n            \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",  # OpenAI가 아닌 다른 제공자\\\\n            \\\\\\\"params\\\\\\\": {\\\\n                \\\\\\\"temperature\\\\\\\": 0.0,\\\\n            },\\\\n        }\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(InvalidModelProviderError) as context:\\\\n            OpenAIGateway(claude_model_info)\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.model_name, \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(context.exception.expected_provider, \\\\\\\"openAI\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_init_without_api_key(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 키 없이 OpenAIGateway 초기화 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 없음 모킹\\\\n        mock_get_api_key.return_value = None\\\\n\\\\n        # 테스트할 모델 가져오기\\\\n        model_info = get_model_info(\\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertIsNotNone(model_info)\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(APIKeyNotFoundError) as context:\\\\n            OpenAIGateway(model_info)\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.provider, \\\\\\\"openai\\\\\\\")\\\\n\\\\n\\\\nclass TestClaudeGateway(unittest.TestCase):\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_init_with_valid_model(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 키와 유효한 모델로 ClaudeGateway 초기화를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 모킹\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        # 테스트할 모델 가져오기\\\\n        model_info = get_model_info(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n        self.assertIsNotNone(model_info)\\\\n\\\\n        # 게이트웨이 생성\\\\n        gateway = ClaudeGateway(model_info)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n        self.assertEqual(gateway.model, model_info)\\\\n        mock_get_api_key.assert_called_once_with(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_init_with_invalid_model_provider(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"잘못된 모델 제공자로 ClaudeGateway 초기화 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 모킹\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        # 실제 존재하는 OpenAI 모델 정보를 반환하도록 모킹\\\\n        openai_model_info: ModelInfoDict = {\\\\n            \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n            \\\\\\\"aliases\\\\\\\": [],\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI 모델\\\\\\\",\\\\n            \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",  # Claude가 아닌 다른 제공자\\\\n            \\\\\\\"params\\\\\\\": {\\\\n                \\\\\\\"temperature\\\\\\\": 0.0,\\\\n            },\\\\n        }\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(InvalidModelProviderError) as context:\\\\n            ClaudeGateway(openai_model_info)\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.model_name, \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(context.exception.expected_provider, \\\\\\\"claude\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_init_without_api_key(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 키 없이 ClaudeGateway 초기화 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 없음 모킹\\\\n        mock_get_api_key.return_value = None\\\\n\\\\n        # 테스트할 모델 가져오기\\\\n        model_info = get_model_info(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n        self.assertIsNotNone(model_info)\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(APIKeyNotFoundError) as context:\\\\n            ClaudeGateway(model_info)\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.provider, \\\\\\\"claude\\\\\\\")\\\\n\\\\n\\\\nclass TestGoogleGateway(unittest.TestCase):\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_init_with_valid_model(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 키와 유효한 모델로 GoogleGateway 초기화를 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 모킹\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        model_info = get_model_info(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n        self.assertIsNotNone(model_info)\\\\n\\\\n        # 게이트웨이 생성\\\\n        gateway = GoogleGateway(model_info)\\\\n\\\\n        # 검증\\\\n        self.assertEqual(gateway.get_model_name(), model_info[\\\\\\\"full_name\\\\\\\"])\\\\n        self.assertEqual(gateway.model, model_info)\\\\n        mock_get_api_key.assert_called_once_with(\\\\\\\"google\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_init_with_invalid_model_provider(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"잘못된 모델 제공자로 GoogleGateway 초기화 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 모킹\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        # 실제 존재하는 OpenAI 모델 정보를 반환하도록 모킹 (Claude 테스트와 유사)\\\\n        openai_model_info: ModelInfoDict = {\\\\n            \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n            \\\\\\\"aliases\\\\\\\": [],\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI 모델\\\\\\\",\\\\n            \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",  # Google이 아닌 다른 제공자\\\\n            \\\\\\\"params\\\\\\\": {\\\\n                \\\\\\\"temperature\\\\\\\": 0.0,\\\\n            },\\\\n        }\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(InvalidModelProviderError) as context:\\\\n            GoogleGateway(openai_model_info)\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.model_name, \\\\\\\"gpt-4o\\\\\\\")\\\\n        self.assertEqual(context.exception.expected_provider, \\\\\\\"google\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_init_without_api_key(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 키 없이 GoogleGateway 초기화 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # API 키 없음 모킹\\\\n        mock_get_api_key.return_value = None\\\\n\\\\n        # 테스트할 모델 가져오기 (test_init_with_valid_model과 동일 로직)\\\\n        try:\\\\n            model_info = get_model_info(\\\\\\\"gemini-pro\\\\\\\")\\\\n        except UnsupportedModelError:\\\\n            model_info: ModelInfoDict = {\\\\n                \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro\\\\\\\",\\\\n                \\\\\\\"aliases\\\\\\\": [],\\\\n                \\\\\\\"description\\\\\\\": \\\\\\\"Google 모델\\\\\\\",\\\\n                \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n                \\\\\\\"params\\\\\\\": {\\\\\\\"temperature\\\\\\\": 0.0},\\\\n            }\\\\n            print(\\\\n                \\\\\\\"Warning: 'gemini-2.5-pro' model not found in available_models. Using mock data for TestGoogleGateway.\\\\\\\"\\\\n            )\\\\n        self.assertIsNotNone(model_info)\\\\n        model_info[\\\\\\\"provider\\\\\\\"] = \\\\\\\"google\\\\\\\"\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(APIKeyNotFoundError) as context:\\\\n            GoogleGateway(model_info)\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.provider, \\\\\\\"google\\\\\\\")\\\\n\\\\n\\\\nclass TestCreateLLMGateway(unittest.TestCase):\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.get_api_key\\\\\\\")\\\\n    def test_create_openai_gateway(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI 모델명으로 get_llm_gateway 호출 시 실제 OpenAIGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = GatewayFactory.create(\\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n        # 검증 - 실제 OpenAIGateway 인스턴스인지 확인\\\\n        self.assertIsInstance(gateway, OpenAIGateway)\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"gpt-4o\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.claude_gateway.get_api_key\\\\\\\")\\\\n    def test_create_claude_gateway(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude 모델명으로 get_llm_gateway 호출 시 ClaudeGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = GatewayFactory.create(\\\\\\\"claude-3-7-sonnet\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, ClaudeGateway)\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n\\\\n    # create test_create_google_gateway\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_create_google_gateway(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 모델명으로 get_llm_gateway 호출 시 GoogleGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, GoogleGateway)\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n\\\\n    # UnsupportedModelError 테스트\\\\n    @patch(\\\\n        \\\\\\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\\\\\",\\\\n        side_effect=UnsupportedModelError(\\\\\\\"unsupported-model\\\\\\\"),\\\\n    )\\\\n    def test_create_gateway_with_unsupported_model(self, mock_get_model_info):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"지원하지 않는 모델명으로 get_llm_gateway 호출 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(UnsupportedModelError) as context:\\\\n            GatewayFactory.create(\\\\\\\"unsupported-model\\\\\\\")\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.model_name, \\\\\\\"unsupported-model\\\\\\\")\\\\n        mock_get_model_info.assert_called_once_with(\\\\\\\"unsupported-model\\\\\\\")\\\\n\\\\n    # UnsupportedProviderError 테스트\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\\\\\")\\\\n    def test_create_gateway_with_unsupported_provider(self, mock_get_model_info):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"지원하지 않는 제공자를 가진 모델로 get_llm_gateway 호출 시 예외 발생을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 지원하지 않는 제공자를 가진 모델 정보 반환\\\\n        mock_get_model_info.return_value = {\\\\n            \\\\\\\"full_name\\\\\\\": \\\\\\\"wrong_model_name\\\\\\\",\\\\n            \\\\\\\"aliases\\\\\\\": [],\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"잘못된 모델\\\\\\\",\\\\n            \\\\\\\"provider\\\\\\\": \\\\\\\"unsupported_provider\\\\\\\",  # 지원하지 않는 제공자\\\\n            \\\\\\\"params\\\\\\\": {},\\\\n        }\\\\n\\\\n        # 예외 발생 확인\\\\n        with self.assertRaises(UnsupportedProviderError) as context:\\\\n            GatewayFactory.create(\\\\\\\"wrong_model_name\\\\\\\")\\\\n\\\\n        # 예외 속성 검증\\\\n        self.assertEqual(context.exception.provider, \\\\\\\"unsupported_provider\\\\\\\")\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    unittest.main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport unittest\\\\nfrom unittest.mock import MagicMock, patch\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, get_model_info\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport unittest\\\\nfrom unittest.mock import patch\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict, get_model_info\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, ClaudeGateway)\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.openai_gateway.OpenAIGateway\\\\\\\")\\\\n    def test_create_default_gateway(self, mock_openai_gateway):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델을 지정하지 않았을 때 기본 모델 사용을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        # 모의 게이트웨이 설정\\\\n        mock_instance = MagicMock()\\\\n        mock_openai_gateway.return_value = mock_instance\\\\n\\\\n        # 모델을 지정하지 않고 함수 호출\\\\n        gateway = GatewayFactory.create(\\\\\\\"o4-mini\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertEqual(gateway, mock_instance)\\\\n        model_info = get_model_info(\\\\\\\"o4-mini\\\\\\\")\\\\n        self.assertIsNotNone(model_info)\\\\n        mock_openai_gateway.assert_called_once_with(model_info=model_info)\\\\n\\\\n    # UnsupportedModelError 테스트\\\\n    @patch(\\\\n        \\\\\\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\\\\\",\\\\n        side_effect=UnsupportedModelError(\\\\\\\"unsupported-model\\\\\\\"),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, ClaudeGateway)\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\")\\\\n\\\\n    # create test_create_google_gateway\\\\n    @patch(\\\\\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\\\\\")\\\\n    def test_create_google_gateway(self, mock_get_api_key):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google 모델명으로 get_llm_gateway 호출 시 GoogleGateway 반환을 테스트합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        mock_get_api_key.return_value = \\\\\\\"fake-api-key\\\\\\\"\\\\n\\\\n        gateway = GatewayFactory.create(\\\\\\\"gemini-2.5-pro\\\\\\\")\\\\n\\\\n        # 검증\\\\n        self.assertIsInstance(gateway, GoogleGateway)\\\\n        self.assertEqual(gateway.get_model_name(), \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\")\\\\n\\\\n    # UnsupportedModelError 테스트\\\\n    @patch(\\\\n        \\\\\\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\\\\\",\\\\n        side_effect=UnsupportedModelError(\\\\\\\"unsupported-model\\\\\\\"),\\\\n```\\\", \\\"line_number\\\": 235}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 169, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"_create_full_context_code_review_prompt 함수에서 파일 내용이 비어있을 때 로깅되는 경고 메시지가 \\\"파일 내용이 없습니다\\\"로 되어 있습니다. 이는 실제 파일 내용이 비어있는 경우를 의미하지만, 메시지만으로는 바이너리 파일이나 읽을 수 없는 파일의 플레이스홀더가 없는 경우와 혼동될 수 있습니다. `load_file_content` 함수는 바이너리/인코딩 오류 파일에 대해 플레이스홀더 문자열을 반환하므로, `request.file_content`가 완전히 비어있는 경우는 드물 것입니다.\", \"suggestion\": \"메시지를 \\\"파일 내용이 비어있습니다\\\" 또는 \\\"파일 내용이 비어있어 프롬프트에 빈 내용으로 추가됩니다\\\" 등으로 더 명확하게 변경하거나, 경고 수준을 `info`로 낮추는 것을 고려할 수 있습니다. 또는 플레이스홀더도 유효한 내용으로 간주하고 해당 조건 및 로깅을 제거하는 것도 고려해볼 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"                        if not request.file_content:\\n                            logger.warning(\\n                                f\\\"파일 내용이 없습니다. 파일 경로: {request.filename}\\\"\\n                            )\\n                            file_content = \\\"\\\"\\n                        else:\\n                            file_content = request.file_content\", \"improved_code\": \"                        # 파일 내용 사용 (parse_git_diff에서 이미 로드됨)\\n                        # load_file_content는 바이너리/인코딩 오류 파일에 대해 플레이스홀더 문자열을 반환합니다.\\n                        # 따라서 request.file_content는 None이 아니며, 빈 문자열일 가능성은 낮습니다.\\n                        # 플레이스홀더도 프롬프트에 포함하는 것이 의도라면, 별도의 검사 없이 바로 사용합니다.\\n                        file_content = request.file_content\\n\\n                        # 만약 내용이 비어있는 파일(플레이스홀더 제외)을 건너뛰고 싶다면 여기에 조건을 추가합니다.\\n                        # 예: if not file_content or file_content.startswith(\\\"[\\\"): continue\\n                        # 또는 빈 파일에 대한 로깅 메시지를 더 명확하게 수정:\\n                        # if not request.file_content:\\n                        #     logger.info(f\\\"파일 내용이 비어있습니다. 파일 경로: {request.filename}\\\")\\n                        #     file_content = \\\"\\\"\"}, {\"type\": \"style\", \"line_number\": 235, \"file\": \"tests/test_llm_gateway.py\", \"description\": \"`test_create_default_gateway` 테스트 케이스가 제거되었습니다. 이 테스트는 모델 이름이 명시되지 않았을 때 `GatewayFactory.create`가 기본 모델을 올바르게 사용하는지 확인하는 역할을 했습니다. 이 테스트의 제거가 `GatewayFactory`의 기본 모델 선택 로직 변경 또는 제거와 일치하는지 확인해야 합니다. 그렇지 않다면 테스트 커버리지가 감소한 것입니다.\", \"suggestion\": \"`GatewayFactory`에 기본 모델 선택 로직이 여전히 존재한다면, 해당 로직을 테스트하는 새로운 테스트 케이스를 추가하거나 기존 테스트를 복원하는 것을 고려하세요. 기본 모델 로직이 제거되었다면, 해당 변경 사항이 의도된 것인지 확인하고 관련 문서를 업데이트하세요.\", \"severity\": \"info\", \"original_code\": \"\\n        # 검증\\n        self.assertIsInstance(gateway, ClaudeGateway)\\n        self.assertEqual(gateway.get_model_name(), \\\"claude-3-7-sonnet-20250219\\\")\\n\\n    @patch(\\\"reviewer.src.llm_gateway.openai_gateway.OpenAIGateway\\\")\\n    def test_create_default_gateway(self, mock_openai_gateway):\\n        \\\"\\\"\\\"모델을 지정하지 않았을 때 기본 모델 사용을 테스트합니다.\\\"\\\"\\\"\\n\\n        # 모의 게이트웨이 설정\\n        mock_instance = MagicMock()\\n        mock_openai_gateway.return_value = mock_instance\\n\\n        # 모델을 지정하지 않고 함수 호출\\n        gateway = GatewayFactory.create(\\\"o4-mini\\\")\\n\\n        # 검증\\n        self.assertEqual(gateway, mock_instance)\\n        model_info = get_model_info(\\\"o4-mini\\\")\\n        self.assertIsNotNone(model_info)\\n        mock_openai_gateway.assert_called_once_with(model_info=model_info)\\n\\n    # UnsupportedModelError 테스트\\n    @patch(\\n        \\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\",\\n        side_effect=UnsupportedModelError(\\\"unsupported-model\\\"),\\n    )\", \"improved_code\": \"\\n        # 검증\\n        self.assertIsInstance(gateway, ClaudeGateway)\\n        self.assertEqual(gateway.get_model_name(), \\\"claude-3-7-sonnet-20250219\\\")\\n\\n    # 기본 모델 선택 로직 테스트 (복원 또는 대체 테스트 추가)\\n    # MagicMock import 필요\\n    from unittest.mock import MagicMock\\n    @patch(\\\"reviewer.src.llm_gateway.openai_gateway.OpenAIGateway\\\") # 또는 적절한 기본 게이트웨이\\n    def test_create_default_gateway(self, mock_openai_gateway):\\n        \\\"\\\"\\\"모델을 지정하지 않았을 때 기본 모델 사용을 테스트합니다.\\\"\\\"\\\"\\n\\n        # 모의 게이트웨이 설정\\n        mock_instance = MagicMock()\\n        mock_openai_gateway.return_value = mock_instance\\n\\n        # 모델을 지정하지 않고 함수 호출 (기본 모델이 사용될 것으로 예상)\\n        # GatewayFactory.create 함수가 기본 모델을 어떻게 결정하는지에 따라 인자 조정 필요\\n        gateway = GatewayFactory.create() # 기본 모델 테스트 시 인자 없을 수 있음\\n\\n        # 검증\\n        self.assertEqual(gateway, mock_instance)\\n        # 기본 모델 정보 가져오는 로직에 따라 검증 조정 필요\\n        # model_info = get_model_info(\\\"o4-mini\\\") # 또는 실제 기본 모델명\\n        # self.assertIsNotNone(model_info)\\n        # mock_openai_gateway.assert_called_once_with(model_info=model_info)\\n\\n\\n    # create test_create_google_gateway\\n    @patch(\\\"reviewer.src.llm_gateway.google_gateway.get_api_key\\\")\\n    def test_create_google_gateway(self, mock_get_api_key):\\n        \\\"\\\"\\\"Google 모델명으로 get_llm_gateway 호출 시 GoogleGateway 반환을 테스트합니다.\\\"\\\"\\\"\\n        mock_get_api_key.return_value = \\\"fake-api-key\\\"\\n\\n        gateway = GatewayFactory.create(\\\"gemini-2.5-pro\\\")\\n\\n        # 검증\\n        self.assertIsInstance(gateway, GoogleGateway)\\n        self.assertEqual(gateway.get_model_name(), \\\"gemini-2.5-pro-exp-03-25\\\")\\n\\n    # UnsupportedModelError 테스트\\n    @patch(\\n        \\\"reviewer.src.llm_gateway.gateway_factory.get_model_info\\\",\\n        side_effect=UnsupportedModelError(\\\"unsupported-model\\\"),\\n    )\"}], \"summary\": \"파일 유틸리티 함수인 `load_file_content`가 `reviewer/src/utils/file_utils.py`로 이동되었고, 캐싱이 적용되었습니다. 프롬프트 생성 로직은 전체 컨텍스트 사용 시 diff 파싱 단계에서 미리 로드된 파일 내용을 사용하도록 변경되었습니다. 관련 파일들의 임포트 경로가 업데이트되었으며, LLM 게이트웨이 테스트 파일에서 일부 테스트가 수정/제거되었습니다.\", \"score\": 8.0, \"recommendations\": [\"프롬프트 생성 시 파일 내용이 비어있을 때의 로깅 메시지를 더 명확하게 수정하거나 로깅 수준을 조정하여 혼동을 줄입니다.\", \"LLM 게이트웨이 팩토리의 기본 모델 선택 로직에 대한 테스트 커버리지가 유지되는지 확인하고, 필요하다면 제거된 테스트를 복원하거나 대체 테스트를 추가합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 7}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n```\\\", \\\"line_number\\\": 91}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 131}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"line_number\\\": 293}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"line_number\\\": 336}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef _validate_api_key(api_key: str, provider: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키의 유효성을 검증합니다.\\\\n\\\\n    Args:\\\\n        api_key: 검증할 API 키\\\\n        provider: API 제공자 이름\\\\n\\\\n    Raises:\\\\n        InvalidAPIKeyError: API 키가 빈 값이거나 너무 짧은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not api_key or api_key.strip() == \\\\\\\"\\\\\\\":\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키가 비어 있습니다.\\\\\\\")\\\\n        raise InvalidAPIKeyError(provider, \\\\\\\"API 키가 비어 있습니다\\\\\\\")\\\\n\\\\n    if len(api_key) < 8:\\\\n        logger.error(\\\\n            f\\\\\\\"{provider.upper()} API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다.\\\\\\\"\\\\n        )\\\\n        raise InvalidAPIKeyError(\\\\n            provider, \\\\\\\"API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키\\\\n\\\\n    Raises:\\\\n        APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        InvalidAPIKeyError: API 키가 유효하지 않은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        api_key = config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n        _validate_api_key(api_key, provider)\\\\n        return api_key\\\\n\\\\n    logger.error(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n    raise APIKeyNotFoundError(provider)\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # API 키 유효성 검증\\\\n        _validate_api_key(api_key, provider)\\\\n\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except InvalidAPIKeyError:\\\\n        # 이미 로그는 _validate_api_key에서 기록됨\\\\n        return False\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"]\\\\n    except KeyError:\\\\n        logger.warning(\\\\n            \\\\\\\"기본 모델이 설정되지 않았습니다. 임시로 'o4-mini'로 리뷰를 처리합니다.\\\\\\\"\\\\n        )\\\\n        logger.info(\\\\n            \\\\\\\"다음 명령어로 기본 모델을 설정해주세요: reviewer config model <model_name>\\\\\\\"\\\\n        )\\\\n        return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\\n\\\\ndef set_default_model(model_name: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"model\\\\\\\" not in config:\\\\n            config[\\\\\\\"model\\\\\\\"] = {}\\\\n        config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"] = model_name\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_diff_only() -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 기본 설정값을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"review\\\\\\\"].getboolean(\\\\\\\"diff_only\\\\\\\", fallback=False)\\\\n    except KeyError:\\\\n        return False\\\\n\\\\n\\\\ndef set_default_diff_only(diff_only: bool) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 기본 설정값을 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"review\\\\\\\" not in config:\\\\n            config[\\\\\\\"review\\\\\\\"] = {}\\\\n        config[\\\\\\\"review\\\\\\\"][\\\\\\\"diff_only\\\\\\\"] = str(diff_only).lower()\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"diff-only 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_diff_only() -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 기본 설정값을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"review\\\\\\\"].getboolean(\\\\\\\"diff_only\\\\\\\", fallback=False)\\\\n    except KeyError:\\\\n        return False\\\\n\\\\n\\\\ndef set_default_diff_only(diff_only: bool) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 기본 설정값을 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"review\\\\\\\" not in config:\\\\n            config[\\\\\\\"review\\\\\\\"] = {}\\\\n        config[\\\\\\\"review\\\\\\\"][\\\\\\\"diff_only\\\\\\\"] = str(diff_only).lower()\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"diff-only 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n```\\\", \\\"line_number\\\": 245}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 336, \"file\": \"reviewer/cli.py\", \"description\": \"설정 파일 내 섹션 이름의 일관성이 부족합니다. API 키는 `[credentials]`, 경로는 `[paths]`, 기본 모델은 `[model]` (또는 `[default]`), 그리고 `diff_only`는 `[review]` 섹션에 저장됩니다. 모든 기본 설정을 `[default]` 섹션에 모으거나, 기능별로 명확하게 구분하는 것이 가독성과 유지보수성을 높일 수 있습니다.\", \"suggestion\": \"기본 설정과 관련된 값들(예: 기본 모델, 기본 diff-only 값)을 `[default]` 섹션 아래에 통합하거나, `[review]` 섹션을 리뷰 관련 기본 설정(모델, diff-only 등)을 위한 섹션으로 명확히 정의하여 사용하세요.\", \"severity\": \"info\", \"original_code\": \"```python\\n    logger.info(f\\\"기본 모델: {get_default_model()}\\\")\\n\\n    # 기본 diff-only 설정\\n    logger.info(f\\\"기본 diff-only 값: {get_default_diff_only()}\\\")\\n\\n\\ndef handle_config_command(args: argparse.Namespace) -> None:\\n```\", \"improved_code\": \"```python\\n    logger.info(f\\\"기본 모델: {get_default_model()}\\\")\\n\\n    # 기본 diff-only 설정\\n    logger.info(f\\\"기본 diff-only 값: {get_default_diff_only()}\\\")\\n\\n\\ndef handle_config_command(args: argparse.Namespace) -> None:\\n```\"}], \"summary\": \"`reviewer/cli.py`와 `reviewer/src/config.py` 파일에 `diff-only` 기본 설정 기능을 추가하고 관련 CLI 명령어를 구현하는 변경사항입니다. `reviewer/src/config.py`에 `get_default_diff_only`와 `set_default_diff_only` 함수가 추가되었고, `reviewer/cli.py`에서는 `review` 명령어에 기본 설정 적용, `config` 명령어에 `diff-only` 하위 명령어 추가, `config list`에 해당 설정 표시 기능이 구현되었습니다. 전반적으로 새로운 기능을 잘 통합하고 있습니다.\", \"score\": 9.0, \"recommendations\": [\"설정 파일 내 섹션 이름 및 구조의 일관성을 검토하여 가독성과 유지보수성을 개선합니다.\", \"설정 값을 읽어올 때 `.get()` 메서드에 기본값을 지정하거나 명시적인 예외 처리를 사용하여 코드 안정성을 높입니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 7, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n```\\\", \\\"line_number\\\": 91, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 131, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"line_number\\\": 293, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"5\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"line_number\\\": 336, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"original_code\\\": \\\"```python\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_diff_only() -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 기본 설정값을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"review\\\\\\\"].getboolean(\\\\\\\"diff_only\\\\\\\", fallback=False)\\\\n    except KeyError:\\\\n        return False\\\\n\\\\n\\\\ndef set_default_diff_only(diff_only: bool) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 기본 설정값을 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"review\\\\\\\" not in config:\\\\n            config[\\\\\\\"review\\\\\\\"] = {}\\\\n        config[\\\\\\\"review\\\\\\\"][\\\\\\\"diff_only\\\\\\\"] = str(diff_only).lower()\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"diff-only 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n```\\\", \\\"line_number\\\": 245, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 CLI 도구에 `diff-only` 옵션을 설정 파일에서 관리할 수 있도록 하는 기능을 추가합니다. `reviewer config diff-only [true|false]` 명령어를 통해 기본값을 설정하고, `reviewer review` 명령어에서 이 기본값을 사용하도록 수정되었습니다. 또한, `reviewer config list` 명령어에 `diff-only` 설정값이 포함되도록 업데이트되었습니다. 전반적으로 새로운 설정 옵션을 깔끔하게 통합한 변경입니다.\", \"score\": 9.0, \"recommendations\": [\"새로운 설정 옵션(`diff-only`)을 CLI와 설정 파일에 성공적으로 통합했습니다.\", \"설정값 로딩 및 저장 로직이 명확하게 구현되었습니다.\", \"CLI 인자 파싱 및 설정값 적용 로직이 올바르게 작동합니다.\", \"현재 수준의 예외 처리는 대부분의 경우 충분하지만, 애플리케이션의 복잡성이 증가한다면 설정 파일 관련 오류에 대한 좀 더 구체적인 처리를 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\n```\\\", \\\"line_number\\\": 4}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 119}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n```\\\", \\\"line_number\\\": 262}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n```\\\", \\\"line_number\\\": 321}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n```\\\", \\\"line_number\\\": 132}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef _validate_api_key(api_key: str, provider: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키의 유효성을 검증합니다.\\\\n\\\\n    Args:\\\\n        api_key: 검증할 API 키\\\\n        provider: API 제공자 이름\\\\n\\\\n    Raises:\\\\n        InvalidAPIKeyError: API 키가 빈 값이거나 너무 짧은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not api_key or api_key.strip() == \\\\\\\"\\\\\\\":\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키가 비어 있습니다.\\\\\\\")\\\\n        raise InvalidAPIKeyError(provider, \\\\\\\"API 키가 비어 있습니다\\\\\\\")\\\\n\\\\n    if len(api_key) < 8:\\\\n        logger.error(\\\\n            f\\\\\\\"{provider.upper()} API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다.\\\\\\\"\\\\n        )\\\\n        raise InvalidAPIKeyError(\\\\n            provider, \\\\\\\"API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키\\\\n\\\\n    Raises:\\\\n        APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        InvalidAPIKeyError: API 키가 유효하지 않은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        api_key = config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n        _validate_api_key(api_key, provider)\\\\n        return api_key\\\\n\\\\n    logger.error(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n    raise APIKeyNotFoundError(provider)\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # API 키 유효성 검증\\\\n        _validate_api_key(api_key, provider)\\\\n\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except InvalidAPIKeyError:\\\\n        # 이미 로그는 _validate_api_key에서 기록됨\\\\n        return False\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"]\\\\n    except KeyError:\\\\n        logger.warning(\\\\n            \\\\\\\"기본 모델이 설정되지 않았습니다. 임시로 'o4-mini'로 리뷰를 처리합니다.\\\\\\\"\\\\n        )\\\\n        logger.info(\\\\n            \\\\\\\"다음 명령어로 기본 모델을 설정해주세요: reviewer config model <model_name>\\\\\\\"\\\\n        )\\\\n        return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\\n\\\\ndef set_default_model(model_name: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"model\\\\\\\" not in config:\\\\n            config[\\\\\\\"model\\\\\\\"] = {}\\\\n        config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"] = model_name\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        return config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"]\\\\n    except KeyError:\\\\n        logger.warning(\\\\n            \\\\\\\"기본 모델이 설정되지 않았습니다. 임시로 'o4-mini'로 리뷰를 처리합니다.\\\\\\\"\\\\n        )\\\\n        logger.info(\\\\n            \\\\\\\"다음 명령어로 기본 모델을 설정해주세요: reviewer config model <model_name>\\\\\\\"\\\\n        )\\\\n        return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\\n\\\\ndef set_default_model(model_name: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        if \\\\\\\"model\\\\\\\" not in config:\\\\n            config[\\\\\\\"model\\\\\\\"] = {}\\\\n        config[\\\\\\\"model\\\\\\\"][\\\\\\\"default_model\\\\\\\"] = model_name\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n```\\\", \\\"line_number\\\": 216}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\nfrom .openai_gateway import OpenAIGateway\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"BaseGateway\\\\\\\",\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n    \\\\\\\"get_default_model\\\\\\\",\\\\n]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 13}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 1}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 216, \"file\": \"reviewer/src/config.py\", \"description\": \"기본 모델 설정 및 조회 로직이 config 모듈로 이동되었습니다. 이는 설정 관련 로직을 한 곳에 모아 코드의 응집도를 높이고 유지보수성을 개선하는 좋은 설계 변경입니다.\", \"suggestion\": \"이 변경은 긍정적입니다. config 모듈의 역할을 명확히 하고 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    # 기본 위치\\n    if sys.platform == \\\"darwin\\\":\\n        return MAC_CONFIG_DIR / \\\"review_prompt\\\"\\n    else:\\n        return Path.home() / \\\".local\\\" / \\\"share\\\" / \\\"reviewer\\\" / \\\"review_prompt\\\"\\n```\", \"improved_code\": \"```python\\n    # 기본 위치\\n    if sys.platform == \\\"darwin\\\":\\n        return MAC_CONFIG_DIR / \\\"review_request\\\"\\n    else:\\n        return Path.home() / \\\".local\\\" / \\\"share\\\" / \\\"reviewer\\\" / \\\"review_request\\\"\\n\\ndef get_default_model() -> str:\\n    \\\"\\\"\\\"기본 모델을 반환합니다.\\\"\\\"\\\"\\n    try:\\n        config = load_config()\\n        return config[\\\"model\\\"][\\\"default_model\\\"]\\n    except KeyError:\\n        logger.warning(\\n            \\\"기본 모델이 설정되지 않았습니다. 임시로 'o4-mini'로 리뷰를 처리합니다.\\\"\\n        )\\n        logger.info(\\n            \\\"다음 명령어로 기본 모델을 설정해주세요: reviewer config model <model_name>\\\"\\n        )\\n        return \\\"o4-mini\\\"\\n\\ndef set_default_model(model_name: str) -> bool:\\n    \\\"\\\"\\\"기본 모델 설정을 처리합니다.\\\"\\\"\\\"\\n    try:\\n        config = load_config()\\n        if \\\"model\\\" not in config:\\n            config[\\\"model\\\"] = {}\\n        config[\\\"model\\\"][\\\"default_model\\\"] = model_name\\n        save_config(config)\\n        return True\\n    except Exception as e:\\n        logger.error(f\\\"기본 모델 설정 중 오류 발생: {str(e)}\\\", exc_info=True)\\n        return False\\n```\"}, {\"type\": \"설계\", \"line_number\": 16, \"file\": \"reviewer/src/llm_gateway/gateway_factory.py\", \"description\": \"GatewayFactory에서 기본 모델을 결정하는 로직이 제거되었습니다. 팩토리는 주어진 모델에 대한 게이트웨이를 생성하는 역할만 수행하도록 책임이 분리되어 설계가 개선되었습니다. 기본 모델 결정은 CLI 레이어에서 담당하게 됩니다.\", \"suggestion\": \"이 변경은 팩토리 패턴의 목적에 더 부합하며 코드의 관심사 분리를 잘 보여줍니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n            model: 사용할 모델 이름\\n\\n        Returns:\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\n        \\\"\\\"\\\"\\n        if not model:\\n            model = get_default_model()\\n\\n        model_info = get_model_info(model)\\n\\n        if model_info[\\\"provider\\\"] == \\\"openai\\\":\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\n\\n```\", \"improved_code\": \"```python\\n            model: 사용할 모델 이름\\n\\n        Returns:\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\n        \\\"\\\"\\\"\\n        model_info = get_model_info(model)\\n\\n        if model_info[\\\"provider\\\"] == \\\"openai\\\":\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\n\\n```\"}, {\"type\": \"스타일\", \"line_number\": 119, \"file\": \"reviewer/cli.py\", \"description\": \"CLI에 기본 모델을 설정하는 'config model' 하위 명령어가 추가되었습니다. 사용자가 명령줄을 통해 쉽게 기본 모델을 관리할 수 있게 되어 유용성이 향상되었습니다.\", \"suggestion\": \"새로운 CLI 명령어 추가는 사용자 편의성을 높입니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    )\\n    results_dir_parser.add_argument(\\n        \\\"path\\\", nargs=\\\"?\\\", help=\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\"\\n    )\\n\\n    # 설정 목록 표시\\n    config_subparsers.add_parser(\\\"list\\\", help=\\\"모든 설정 표시\\\")\\n\\n    # 결과 관리 명령어\\n    results_parser = subparsers.add_parser(\\\"results\\\", help=\\\"리뷰 결과 관리\\\")\\n```\", \"improved_code\": \"```python\\n    )\\n    results_dir_parser.add_argument(\\n        \\\"path\\\", nargs=\\\"?\\\", help=\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\"\\n    )\\n\\n    # 모델 설정\\n    model_parser = config_subparsers.add_parser(\\\"model\\\", help=\\\"모델 설정\\\")\\n    model_parser.add_argument(\\n        \\\"model_name\\\",\\n        nargs=\\\"?\\\",\\n        choices=get_supported_models(),\\n        help=\\\"기본으로 사용할 AI 모델\\\",\\n    )\\n\\n    # 설정 목록 표시\\n    config_subparsers.add_parser(\\\"list\\\", help=\\\"모든 설정 표시\\\")\\n\\n    # 결과 관리 명령어\\n    results_parser = subparsers.add_parser(\\\"results\\\", help=\\\"리뷰 결과 관리\\\")\\n```\"}, {\"type\": \"스타일\", \"line_number\": 321, \"file\": \"reviewer/cli.py\", \"description\": \"config 명령 처리 로직에 'model' 하위 명령어가 추가되었습니다. 이는 새로운 기능에 대한 적절한 핸들링 로직 추가입니다.\", \"suggestion\": \"새로운 명령어 처리가 잘 반영되었습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n    if args.config_command == \\\"api-key\\\":\\n        config_api_key(args)\\n    elif args.config_command == \\\"results-dir\\\":\\n        config_results_dir(args)\\n    elif args.config_command == \\\"list\\\":\\n        config_list()\\n\\n\\ndef handle_results_command(args: argparse.Namespace) -> None:\\n```\", \"improved_code\": \"```python\\n\\n    if args.config_command == \\\"api-key\\\":\\n        config_api_key(args)\\n    elif args.config_command == \\\"results-dir\\\":\\n        config_results_dir(args)\\n    elif args.config_command == \\\"model\\\":\\n        config_model(args)\\n    elif args.config_command == \\\"list\\\":\\n        config_list()\\n\\n\\ndef handle_results_command(args: argparse.Namespace) -> None:\\n```\"}, {\"type\": \"버그\", \"line_number\": 216, \"file\": \"reviewer/src/config.py\", \"description\": \"`get_default_review_prompt_dir` 함수의 기본 경로가 `review_request`로 설정되어 있습니다. 함수 이름과 반환하는 경로의 의미가 일치하지 않습니다. `review_prompt`로 수정해야 합니다.\", \"suggestion\": \"기본 경로를 `review_prompt`로 수정하여 함수 이름과 일치시킵니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    # 기본 위치\\n    if sys.platform == \\\"darwin\\\":\\n        return MAC_CONFIG_DIR / \\\"review_request\\\"\\n    else:\\n        return Path.home() / \\\".local\\\" / \\\"share\\\" / \\\"reviewer\\\" / \\\"review_request\\\"\\n```\", \"improved_code\": \"```python\\n    # 기본 위치\\n    if sys.platform == \\\"darwin\\\":\\n        return MAC_CONFIG_DIR / \\\"review_prompt\\\"\\n    else:\\n        return Path.home() / \\\".local\\\" / \\\"share\\\" / \\\"reviewer\\\" / \\\"review_prompt\\\"\\n```\"}], \"summary\": \"이 변경사항은 기본 LLM 모델 설정 및 관리를 위한 기능을 추가하고, 설정 관련 로직을 config 모듈로 중앙화하는 리팩토링을 포함합니다. `get_default_model` 함수가 `available_models.py`에서 `config.py`로 이동했으며, 기본 모델을 설정하는 `set_default_model` 함수가 추가되었습니다. CLI에는 `config model` 명령어가 새로 생겨 사용자가 기본 모델을 설정하고 확인할 수 있게 되었습니다. GatewayFactory에서는 기본 모델 결정 로직이 제거되어 책임이 명확해졌습니다. 또한, `get_default_review_prompt_dir` 함수의 기본 경로 설정에 잠재적인 버그가 발견되었습니다. 전반적으로 코드 구조와 설정 관리 기능이 개선되었으나, 경로 설정의 일관성 문제가 있습니다.\", \"score\": 8.5, \"recommendations\": [\"새로 추가된 'config model' 명령어에 대한 사용 예시를 README 또는 도움말에 명확히 추가합니다.\", \"기본 모델 설정 시, 지원하지 않는 모델 이름을 입력했을 때의 오류 메시지를 사용자에게 더 친절하게 안내하도록 개선할 수 있습니다 (현재는 argparse에서 처리되지만, config 함수 내에서도 유효성 검사를 강화할 수 있습니다).\", \"`get_default_review_prompt_dir` 함수의 기본 경로를 함수 이름에 맞게 `review_prompt`로 수정하여 일관성을 확보합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"line_number\\\": 56}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"line_number\\\": 166}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 4}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 코드 리뷰 도구에 새로운 기능을 추가합니다. 사용자는 이제 스테이징된 변경사항, 특정 커밋 이후의 변경사항, 또는 특정 브랜치와의 변경사항을 리뷰 대상으로 지정할 수 있습니다. 이를 위해 `reviewer/cli.py` 파일에 새로운 명령줄 인수가 추가되었고, `reviewer/src/utils/git_utils.py` 파일의 `run_git_diff` 함수가 리팩토링되어 이러한 다양한 리뷰 대상을 처리할 수 있도록 개선되었습니다. `argparse`의 상호 배타적 그룹을 사용하여 리뷰 대상 옵션이 하나만 선택되도록 제한한 점과, `run_git_diff` 함수에서 각 옵션에 따라 적절한 `git diff` 명령어를 구성하도록 로직을 수정한 점이 주요 변경 내용입니다.\", \"score\": 9.0, \"recommendations\": [\"CLI의 `main` 함수에서 일반 `Exception`을 catch하기 전에 특정 예외(예: `ValueError`, `subprocess.CalledProcessError`)를 먼저 처리하여 더 구체적인 오류 메시지를 제공하는 것을 고려해 볼 수 있습니다.\", \"`reviewer results show` 명령어로 결과를 표시할 때, 파일 내용이 매우 클 경우를 대비하여 출력 형식을 제어하거나 페이지네이션 기능을 추가하는 것을 고려해 볼 수 있습니다.\", \"`run_git_diff` 함수 또는 `cli.py`에서 `git diff` 명령을 실행하기 전에 제공된 커밋 ID나 브랜치 이름이 유효한지 미리 확인하는 로직을 추가하면 사용자에게 더 명확한 오류 메시지를 제공할 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"line_number\\\": 56}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"line_number\\\": 166}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 4}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 14, \"file\": \"reviewer/src/utils/git_utils.py\", \"description\": \"git diff 명령의 `--unified` 옵션 값이 0에서 5로 변경되었습니다. 이는 diff 출력 시 변경된 코드 주변에 표시되는 컨텍스트 라인 수를 변경합니다. `--unified=5`는 기본값이며 가독성이 좋지만, `--unified=0`의 최소화된 출력을 기대하는 다른 시스템이나 스크립트에서는 호환성 문제가 발생할 수 있습니다.\", \"suggestion\": \"이 함수의 출력 형식이 `--unified=5`로 고정되어도 괜찮은지 확인하고, 필요한 경우 문서화하세요. 만약 컨텍스트 라인 수를 제어해야 한다면, 함수 인자로 `--unified` 값을 받을 수 있도록 수정하는 것을 고려해볼 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"cmd = [\\\"git\\\", \\\"-C\\\", repo_path, \\\"diff\\\", \\\"--unified=0\\\"]\", \"improved_code\": \"cmd = [\\\"git\\\", \\\"-C\\\", repo_path, \\\"diff\\\", \\\"--unified=5\\\"]\"}, {\"type\": \"버그\", \"line_number\": 47, \"file\": \"reviewer/src/utils/git_utils.py\", \"description\": \"`subprocess.CalledProcessError` 또는 일반 `Exception` 발생 시 빈 문자열 (`\\\"\\\"`)을 반환합니다. 이는 git 명령 실행 중 오류가 발생했는지, 아니면 diff 결과가 단순히 비어있는지(변경사항 없음) 호출자가 구분할 수 없게 만듭니다.\", \"suggestion\": \"오류 발생 시 예외를 다시 발생시키거나 (`raise e`), 실패를 명확히 나타내는 값(예: `None`)을 반환하도록 수정하여 호출자가 오류 상태를 정확히 감지하고 처리할 수 있도록 해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"    except subprocess.CalledProcessError as e:\\n        logger.error(\\n            f\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        return \\\"\\\"\\n    except Exception as e:  # 일반적인 예외 처리 추가\\n        logger.error(\\n            f\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        return \\\"\\\"\", \"improved_code\": \"    except subprocess.CalledProcessError as e:\\n        logger.error(\\n            f\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        raise e\\n    except Exception as e:  # 일반적인 예외 처리 추가\\n        logger.error(\\n            f\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        raise e\"}, {\"type\": \"버그\", \"line_number\": 37, \"file\": \"reviewer/src/utils/git_utils.py\", \"description\": \"`target_commit` 또는 `target_branch` 인자가 제공되었으나 빈 문자열이거나 공백만 포함하는 경우, 오류를 로깅하고 빈 문자열 (`\\\"\\\"`)을 반환합니다. 이는 유효하지 않은 입력으로 인한 오류 상태를 숨기고, 호출자가 입력 오류를 특정하여 처리하기 어렵게 만듭니다.\", \"suggestion\": \"유효하지 않은 입력(빈 문자열 등)이 감지되면 `ValueError`와 같은 적절한 예외를 발생시켜 호출자에게 명확하게 알리는 것이 좋습니다.\", \"severity\": \"warning\", \"original_code\": \"        if not target_commit.strip():\\n            logger.error(\\\"오류: target_commit 값이 비어있습니다.\\\")\\n            return \\\"\\\"\", \"improved_code\": \"        if not target_commit.strip():\\n            logger.error(\\\"오류: target_commit 값이 비어있습니다.\\\")\\n            raise ValueError(\\\"target_commit cannot be empty or whitespace only.\\\")\"}], \"summary\": \"`run_git_diff` 함수에서 `git diff` 명령의 컨텍스트 라인 수를 0에서 5로 변경하는 수정이 있었습니다. 코드 자체는 git 명령 실행 및 기본 오류 처리를 잘 수행하고 있으나, 오류 발생 시 빈 문자열을 반환하는 방식과 유효하지 않은 입력 처리 방식은 개선의 여지가 있습니다.\", \"score\": 7.0, \"recommendations\": [\"오류 발생 시 예외를 발생시키거나 명확한 실패 값을 반환하여 오류 상태를 호출자에게 정확히 전달하도록 수정합니다.\", \"유효하지 않은 입력(빈 문자열 등)에 대해 `ValueError`와 같은 예외를 발생시켜 입력 검증 실패를 명확히 알립니다.\", \"`--unified` 옵션 변경의 의도를 확인하고, 필요하다면 문서화하거나 유연성을 위해 인자로 제공하는 것을 고려합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=0\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n```\\\", \\\"line_number\\\": 14}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 코드 리뷰 도구에 새로운 기능을 추가합니다. 사용자는 이제 스테이징된 변경사항, 특정 커밋 이후의 변경사항, 또는 특정 브랜치와의 변경사항을 리뷰 대상으로 지정할 수 있습니다. 이를 위해 `reviewer/cli.py` 파일에 새로운 명령줄 인수가 추가되었고, `reviewer/src/utils/git_utils.py` 파일의 `run_git_diff` 함수가 리팩토링되어 이러한 다양한 리뷰 대상을 처리할 수 있도록 개선되었습니다. `argparse`의 상호 배타적 그룹을 사용하여 리뷰 대상 옵션이 하나만 선택되도록 제한한 점과, `run_git_diff` 함수에서 각 옵션에 따라 적절한 `git diff` 명령어를 구성하도록 로직을 수정한 점이 주요 변경 내용입니다.\", \"score\": 9.0, \"recommendations\": [\"CLI의 `main` 함수에서 일반 `Exception`을 catch하기 전에 특정 예외(예: `ValueError`, `subprocess.CalledProcessError`)를 먼저 처리하여 더 구체적인 오류 메시지를 제공하는 것을 고려해 볼 수 있습니다.\", \"`reviewer results show` 명령어로 결과를 표시할 때, 파일 내용이 매우 클 경우를 대비하여 출력 형식을 제어하거나 페이지네이션 기능을 추가하는 것을 고려해 볼 수 있습니다.\", \"`run_git_diff` 함수 또는 `cli.py`에서 `git diff` 명령을 실행하기 전에 제공된 커밋 ID나 브랜치 이름이 유효한지 미리 확인하는 로직을 추가하면 사용자에게 더 명확한 오류 메시지를 제공할 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n```\\\", \\\"line_number\\\": 56}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(\\\\n        repo_path=str(repo_path),\\\\n        staged=args.staged,\\\\n        target_commit=args.target_commit,\\\\n        target_branch=args.target_branch,\\\\n    )\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n```\\\", \\\"line_number\\\": 166}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(\\\\n    repo_path: str,\\\\n    staged: bool = False,\\\\n    target_commit: str | None = None,\\\\n    target_branch: str | None = None,\\\\n) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        staged (bool): 스테이징된 변경사항 비교 여부\\\\n        target_commit (str | None): HEAD와 비교할 특정 커밋 ID (예: \\\\\\\"abc1234\\\\\\\")\\\\n        target_branch (str | None): HEAD와 비교할 특정 브랜치명 (예: \\\\\\\"main\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"]\\\\n\\\\n    if staged:\\\\n        cmd.append(\\\\\\\"--cached\\\\\\\")\\\\n    elif target_commit:\\\\n        # 사용자가 제공한 커밋 ID가 유효한지 간단히 확인 (옵션)\\\\n        # 실제 git 명령어는 존재하지 않는 커밋에 대해 오류를 반환할 것임\\\\n        if not target_commit.strip():\\\\n            logger.error(\\\\\\\"오류: target_commit 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_commit}..HEAD\\\\\\\")\\\\n    elif target_branch:\\\\n        if not target_branch.strip():\\\\n            logger.error(\\\\\\\"오류: target_branch 값이 비어있습니다.\\\\\\\")\\\\n            return \\\\\\\"\\\\\\\"\\\\n        cmd.append(f\\\\\\\"{target_branch}..HEAD\\\\\\\")\\\\n    # 아무 옵션도 지정되지 않으면 (staged=False, target_commit=None, target_branch=None),\\\\n    # cmd는 [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=5\\\\\\\"] 가 되어\\\\n    # 워킹 디렉토리의 변경사항 (스테이징되지 않은 변경사항)을 보여줍니다.\\\\n\\\\n    try:\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except Exception as e:  # 일반적인 예외 처리 추가\\\\n        logger.error(\\\\n            f\\\\\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\\\\\n실행된 명령어: {' '.join(cmd)}\\\\\\\",\\\\n            exc_info=True,\\\\n        )\\\\n        return \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 4}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 59, \"file\": \"reviewer/src/utils/git_utils.py\", \"description\": \"run_git_diff 함수에서 broad except Exception을 사용하여 예상치 못한 다양한 오류를 포괄적으로 처리하고 있습니다. 이는 특정 오류의 원인을 파악하기 어렵게 만들고 디버깅을 방해할 수 있습니다.\", \"suggestion\": \"subprocess.CalledProcessError는 이미 처리하고 있으므로, 그 외에 발생할 수 있는 특정 예외(예: OSError)를 명시적으로 처리하거나, 정말 예상치 못한 오류는 로그만 남기고 예외를 다시 발생시키는 것이 좋습니다. 또는 이 함수 레벨에서는 CalledProcessError만 처리하고 다른 예외는 호출자에게 위임하는 것도 고려할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    except subprocess.CalledProcessError as e:\\n        logger.error(\\n            f\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        return \\\"\\\"\\n    except Exception as e:  # 일반적인 예외 처리 추가\\n        logger.error(\\n            f\\\"Git diff 처리 중 예상치 못한 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        return \\\"\\\"\\n```\", \"improved_code\": \"```python\\n    except subprocess.CalledProcessError as e:\\n        logger.error(\\n            f\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\",\\n            exc_info=True,\\n        )\\n        return \\\"\\\"\\n    # 예상치 못한 다른 오류는 호출자에게 위임하거나, 필요시 더 구체적인 예외를 처리\\n    # except OSError as e:\\n    #     logger.error(f\\\"Git 실행 환경 오류 발생: {e}\\\\n실행된 명령어: {' '.join(cmd)}\\\", exc_info=True)\\n    #     return \\\"\\\"\\n```\"}], \"summary\": \"이 변경사항은 CLI 도구에 코드 리뷰 대상을 지정하는 새로운 옵션(--staged, --target-commit, --target-branch)을 추가하고, 이를 처리하기 위해 git diff 유틸리티 함수를 리팩토링합니다. `argparse`의 상호 배타적 그룹을 사용하여 CLI 인수의 유효성을 개선했으며, `run_git_diff` 함수는 새로운 인자를 받아 적절한 git diff 명령을 생성하도록 수정되었습니다.\", \"score\": 9.0, \"recommendations\": [\"run_git_diff 함수에서 broad except Exception 대신 더 구체적인 예외를 처리하거나 예외를 다시 발생시켜 오류 처리를 개선합니다.\", \"CLI `--target-commit` 및 `--target-branch` 옵션에 대해 입력된 값이 유효한 Git 객체인지 사전에 간단히 검증하는 로직을 추가하여 사용자에게 더 명확한 오류 메시지를 제공할 수 있습니다 (현재는 Git 명령 자체의 오류에 의존).\", \"테스트 코드를 추가하여 새로운 CLI 옵션과 `run_git_diff` 함수의 다양한 시나리오(staged, commit, branch, invalid repo 등)를 검증합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 9, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\", \"description\": \"InMemoryDatabase에서 사용자 및 게시글 저장소의 값 타입을 `Any`에서 구체적인 타입(`User`, `Article`)으로 변경하여 타입 안전성을 확보했습니다. 이전에는 저장된 객체의 실제 타입을 알 수 없어 캐스팅이 필요했지만, 이제 컴파일 시점에 타입 오류를 방지할 수 있습니다.\", \"suggestion\": \"변경된 코드가 올바른 방향입니다. 구체적인 타입을 사용하여 코드의 안정성과 가독성을 높였습니다.\", \"severity\": \"info\", \"original_code\": \"val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\", \"improved_code\": \"val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\"}, {\"type\": \"스타일\", \"line_number\": 18, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\", \"description\": \"InMemoryDatabase의 타입 변경 덕분에 `as? User` 또는 `mapNotNull { it as? Article }`와 같은 불필요한 캐스팅 코드를 제거할 수 있게 되었습니다. 이는 코드의 가독성을 높이고 잠재적인 런타임 캐스팅 오류의 위험을 줄입니다.\", \"suggestion\": \"캐스팅 제거는 올바른 개선입니다. 앞으로도 가능한 경우 구체적인 타입을 사용하여 캐스팅을 피하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\", \"improved_code\": \"val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\"}, {\"type\": \"스타일\", \"line_number\": 14, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\", \"description\": \"replaceAll 람다에서 사용되지 않는 첫 번째 파라미터(맵의 키)를 관례적으로 `_`로 변경했습니다. 이는 해당 파라미터가 람다 본문에서 사용되지 않음을 명확히 보여주어 코드의 의도를 더 잘 드러냅니다.\", \"suggestion\": \"사용되지 않는 파라미터를 `_`로 표시하는 것은 좋은 코틀린 스타일입니다. 이 컨벤션을 유지하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"InMemoryDatabase.articles.replaceAll { articleId, article ->\", \"improved_code\": \"InMemoryDatabase.articles.replaceAll { _, article ->\"}], \"summary\": \"이 변경사항은 테스트 코드 내 InMemoryDatabase의 타입 안전성을 크게 개선하고, 이에 따라 Mock Repository 코드에서 불필요한 캐스팅을 제거합니다. 또한, 사용되지 않는 람다 파라미터를 `_`로 표시하는 코틀린 스타일 가이드라인을 따릅니다. 전반적으로 테스트 코드의 가독성과 안정성이 향상되었습니다.\", \"score\": 9.0, \"recommendations\": [\"테스트 코드에서 도메인 모델의 구체적인 타입을 적극적으로 활용하여 타입 안전성을 유지합니다.\", \"코틀린 컨벤션을 따라 사용되지 않는 람다 파라미터는 `_`로 표시합니다.\", \"Mock 객체가 실제 구현체의 계약(Contract)을 정확히 따르는지 지속적으로 확인합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"file_content\\\": \\\"distributionBase=GRADLE_USER_HOME\\\\ndistributionPath=wrapper/dists\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\nnetworkTimeout=10000\\\\nvalidateDistributionUrl=true\\\\nzipStoreBase=GRADLE_USER_HOME\\\\nzipStorePath=wrapper/dists\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.7-bin.zip\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew.bat\\\", \\\"file_content\\\": \\\"@rem\\\\n@rem Copyright 2015 the original author or authors.\\\\n@rem\\\\n@rem Licensed under the Apache License, Version 2.0 (the \\\\\\\"License\\\\\\\");\\\\n@rem you may not use this file except in compliance with the License.\\\\n@rem You may obtain a copy of the License at\\\\n@rem\\\\n@rem      https://www.apache.org/licenses/LICENSE-2.0\\\\n@rem\\\\n@rem Unless required by applicable law or agreed to in writing, software\\\\n@rem distributed under the License is distributed on an \\\\\\\"AS IS\\\\\\\" BASIS,\\\\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\\\n@rem See the License for the specific language governing permissions and\\\\n@rem limitations under the License.\\\\n@rem\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n\\\\n@if \\\\\\\"%DEBUG%\\\\\\\"==\\\\\\\"\\\\\\\" @echo off\\\\n@rem ##########################################################################\\\\n@rem\\\\n@rem  Gradle startup script for Windows\\\\n@rem\\\\n@rem ##########################################################################\\\\n\\\\n@rem Set local scope for the variables with windows NT shell\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" setlocal\\\\n\\\\nset DIRNAME=%~dp0\\\\nif \\\\\\\"%DIRNAME%\\\\\\\"==\\\\\\\"\\\\\\\" set DIRNAME=.\\\\n@rem This is normally unused\\\\nset APP_BASE_NAME=%~n0\\\\nset APP_HOME=%DIRNAME%\\\\n\\\\n@rem Resolve any \\\\\\\".\\\\\\\" and \\\\\\\"..\\\\\\\" in APP_HOME to make it shorter.\\\\nfor %%i in (\\\\\\\"%APP_HOME%\\\\\\\") do set APP_HOME=%%~fi\\\\n\\\\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\\\\nset DEFAULT_JVM_OPTS=\\\\\\\"-Xmx64m\\\\\\\" \\\\\\\"-Xms64m\\\\\\\"\\\\n\\\\n@rem Find java.exe\\\\nif defined JAVA_HOME goto findJavaFromJavaHome\\\\n\\\\nset JAVA_EXE=java.exe\\\\n%JAVA_EXE% -version >NUL 2>&1\\\\nif %ERRORLEVEL% equ 0 goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:findJavaFromJavaHome\\\\nset JAVA_HOME=%JAVA_HOME:\\\\\\\"=%\\\\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\\\\n\\\\nif exist \\\\\\\"%JAVA_EXE%\\\\\\\" goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:execute\\\\n@rem Setup the command line\\\\n\\\\nset CLASSPATH=%APP_HOME%\\\\\\\\gradle\\\\\\\\wrapper\\\\\\\\gradle-wrapper.jar\\\\n\\\\n\\\\n@rem Execute Gradle\\\\n\\\\\\\"%JAVA_EXE%\\\\\\\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \\\\\\\"-Dorg.gradle.appname=%APP_BASE_NAME%\\\\\\\" -classpath \\\\\\\"%CLASSPATH%\\\\\\\" org.gradle.wrapper.GradleWrapperMain %*\\\\n\\\\n:end\\\\n@rem End local scope for the variables with windows NT shell\\\\nif %ERRORLEVEL% equ 0 goto mainEnd\\\\n\\\\n:fail\\\\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\\\\nrem the _cmd.exe /c_ return code!\\\\nset EXIT_CODE=%ERRORLEVEL%\\\\nif %EXIT_CODE% equ 0 set EXIT_CODE=1\\\\nif not \\\\\\\"\\\\\\\"==\\\\\\\"%GRADLE_EXIT_CONSOLE%\\\\\\\" exit %EXIT_CODE%\\\\nexit /b %EXIT_CODE%\\\\n\\\\n:mainEnd\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" endlocal\\\\n\\\\n:omega\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"configuration\", \"line_number\": 8, \"file\": \"gradle/wrapper/gradle-wrapper.properties\", \"description\": \"gradle-wrapper.properties 파일에 로컬 환경에 특화된 Java 홈 경로(org.gradle.java.home)가 포함되어 있습니다. 이 설정은 빌드 환경에 따라 달라지므로, 버전 관리 시스템에 포함되면 다른 개발자의 환경에서 문제가 발생하거나 불필요한 diff를 유발할 수 있습니다.\", \"suggestion\": \"해당 라인을 삭제하고, 필요하다면 로컬 환경 설정 파일(예: ~/.gradle/gradle.properties)에 추가하거나 환경 변수로 설정하는 것이 좋습니다. 또한, gradle-wrapper.properties 파일이 실수로 로컬 설정을 포함하지 않도록 .gitignore에 추가하는 것을 고려할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```text\\nzipStoreBase=GRADLE_USER_HOME\\nzipStorePath=wrapper/dists\\n```\", \"improved_code\": \"```text\\nzipStoreBase=GRADLE_USER_HOME\\nzipStorePath=wrapper/dists\\n```\"}], \"summary\": \"이번 변경사항은 테스트 코드의 InMemoryDatabase에서 사용되는 Map의 Value 타입을 Any에서 구체적인 도메인 모델(User, Article)로 변경하여 타입 안정성을 높였습니다. 이에 따라 Mock Repository 코드에서 불필요한 타입 캐스팅(as?) 및 필터링(mapNotNull) 로직이 제거되어 코드가 간결해졌습니다. 또한 Gradle Wrapper 버전을 8.7에서 8.10으로 업데이트하고, gradlew.bat 파일에 SPDX 라이선스 식별자를 추가했습니다. 다만, gradle-wrapper.properties 파일에 로컬 Java 홈 경로가 포함된 부분은 개선이 필요합니다.\", \"score\": 9.0, \"recommendations\": [\"gradle/wrapper/gradle-wrapper.properties 파일에서 로컬 환경에 특화된 설정(org.gradle.java.home)을 제거하고 .gitignore에 추가하여 버전 관리가 되지 않도록 합니다.\", \"Mock Repository 코드의 타입 안정성 개선은 좋은 방향이며, 앞으로도 가능한 구체적인 타입을 사용하여 코드의 명확성을 높이는 것을 권장합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        PermissionError: 저장소 외부의 파일에 접근하려고 시도한 경우\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(repo_path, filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 파일 경로 완성 및 보안 검사\\\\n        abs_repo_path = os.path.abspath(repo_path)\\\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\\\n        # 악의적인 filename (예: \\\\\\\"../../../etc/passwd\\\\\\\")을 방지합니다.\\\\n        prospective_path = os.path.join(abs_repo_path, filename)\\\\n        abs_file_path = os.path.abspath(prospective_path)\\\\n\\\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\\\n        # os.sep을 추가하여 \\\\\\\"/foo/bar\\\\\\\"와 \\\\\\\"/foo/barbaz\\\\\\\" 같은 경우를 구분합니다.\\\\n        if (\\\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\\\n            and abs_file_path != abs_repo_path\\\\n        ):\\\\n            raise PermissionError(\\\\n                f\\\\\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\\\\\"\\\\n            )\\\\n\\\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\\\n```\\\", \\\"line_number\\\": 65}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"security\", \"line_number\": 71, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"파일 경로 유효성 검사 로직은 `os.path.abspath`와 `startswith`를 사용하여 디렉토리 탐색 공격을 방어하려는 좋은 시도입니다. 하지만 `os.path.abspath`는 심볼릭 링크를 해석하지 않기 때문에, 악의적으로 생성된 심볼릭 링크를 통해 저장소 외부 파일에 접근하는 공격에 취약할 수 있습니다.\", \"suggestion\": \"심볼릭 링크 공격에 대한 방어를 강화하기 위해 `os.path.abspath` 대신 `os.path.realpath`를 사용하여 실제 경로를 얻은 후 유효성 검사를 수행하는 것을 고려해 보세요. `os.path.realpath`는 심볼릭 링크를 해석하여 최종 경로를 반환합니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n        abs_file_path = os.path.abspath(prospective_path)\\n\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\n        # os.sep을 추가하여 \\\"/foo/bar\\\"와 \\\"/foo/barbaz\\\" 같은 경우를 구분합니다.\\n        if (\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\n            and abs_file_path != abs_repo_path\\n        ):\\n            raise PermissionError(\\n                f\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\"\\n            )\\n\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\n```\", \"improved_code\": \"```python\\n        # 파일 경로 완성 및 보안 검사\\n        # realpath를 사용하여 심볼릭 링크 공격 방지 강화\\n        abs_repo_path = os.path.realpath(repo_path)\\n        # filename이 repo_path에 대한 상대 경로라고 가정합니다.\\n        # 악의적인 filename (예: \\\"../../../etc/passwd\\\")을 방지합니다.\\n        prospective_path = os.path.join(abs_repo_path, filename)\\n        abs_file_path = os.path.realpath(prospective_path)\\n\\n        # resolved_path가 resolved_repo_path로 시작하는지 확인합니다.\\n        # os.sep을 추가하여 \\\"/foo/bar\\\"와 \\\"/foo/barbaz\\\" 같은 경우를 구분합니다.\\n        if (\\n            not abs_file_path.startswith(abs_repo_path + os.sep)\\n            and abs_file_path != abs_repo_path\\n        ):\\n            raise PermissionError(\\n                f\\\"보안 위협: 저장소 외부의 파일에 접근하려고 시도했습니다: {filename}\\\"\\n            )\\n\\n        file_path = abs_file_path  # 검증된 절대 경로 사용\\n```\"}, {\"type\": \"bug\", \"line_number\": 91, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"광범위한 `except Exception` 블록은 `FileNotFoundError`, `PermissionError`, `UnicodeDecodeError` 외에 발생할 수 있는 다른 구체적인 파일 읽기 관련 오류(예: `IOError`, `OSError`의 다른 하위 클래스)를 모두 잡아냅니다. 이는 디버깅을 어렵게 만들고, 예상치 못한 오류의 원인을 파악하기 힘들게 합니다.\", \"suggestion\": \"가능한 한 구체적인 예외를 잡거나, 파일 읽기 관련 오류에 대해 `OSError`나 `IOError`와 같이 좀 더 제한적인 예외를 잡도록 변경하세요. 또는 예상치 못한 오류는 자연스럽게 호출자에게 전파되도록 두는 것이 좋습니다. 예외를 다시 발생시킬 때는 원래 예외 정보를 포함하도록 `raise ... from e` 구문을 사용하세요.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    except Exception as e:\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\n        import traceback\\n\\n        error_msg = f\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\n{traceback.format_exc()}\\\"\\n        raise Exception(error_msg) from e\\n```\", \"improved_code\": \"```python\\n    except (OSError, IOError) as e: # 또는 더 구체적인 예외들을 명시\\n        # 파일 읽기 관련 오류 처리\\n        import traceback\\n\\n        error_msg = f\\\"파일 '{filename}' 읽기 오류: {type(e).__name__} - {str(e)}\\\\n{traceback.format_exc()}\\\"\\n        # 원래 예외 타입을 유지하거나 더 적절한 예외 타입으로 변경\\n        raise IOError(error_msg) from e\\n    # FileNotFoundError, PermissionError, UnicodeDecodeError는 이미 위에서 처리됨\\n```\"}, {\"type\": \"performance\", \"line_number\": 58, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"`load_file_content` 함수에 `@lru_cache(maxsize=1)` 데코레이터가 적용되어 있습니다. `maxsize=1` 캐시는 바로 직전에 호출된 동일한 인자에 대한 결과만 캐시합니다. 코드 리뷰 요청 처리 시 여러 파일을 순차적으로 읽게 되므로, 동일한 파일이 연속해서 요청될 가능성이 낮아 이 캐시는 거의 효과가 없을 것으로 예상됩니다.\", \"suggestion\": \"`load_file_content` 함수에서 `@lru_cache(maxsize=1)` 데코레이터를 제거하거나, 파일 내용을 캐시하는 것이 실제로 성능에 도움이 된다고 판단될 경우 더 큰 `maxsize`를 설정하여 여러 파일의 내용을 캐시하도록 변경하세요. 다만, 파일 내용 캐시는 메모리 사용량에 영향을 줄 수 있으므로 신중하게 결정해야 합니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n@lru_cache(maxsize=1)\\ndef load_file_content(filename: str, repo_path: str) -> str:\\n    \\\"\\\"\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\n```\", \"improved_code\": \"```python\\n# @lru_cache(maxsize=1) # 캐시 제거 또는 적절한 크기로 변경\\ndef load_file_content(filename: str, repo_path: str) -> str:\\n    \\\"\\\"\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\n```\"}, {\"type\": \"design\", \"line_number\": 140, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"`_create_simple_code_review_prompt` 함수 내에서 입력 인자인 `review_request` 객체의 `file_paths` 속성을 수정하고 있습니다. 함수가 새로운 객체(프롬프트)를 생성하는 역할을 주로 수행하는데, 입력 객체에 부수 효과(side effect)를 일으키는 것은 예상치 못한 동작일 수 있으며, 호출자가 `review_request` 객체를 재사용할 경우 문제가 발생할 수 있습니다.\", \"suggestion\": \"함수 내에서 입력 객체를 수정하는 것을 피하세요. 만약 처리된 파일 경로 목록이 필요하다면, 이를 함수의 반환 값에 포함시키거나 다른 방식으로 관리하는 것이 좋습니다. 또한, `file_paths`가 중복을 허용하지 않는 목록이라면 `list` 대신 `set`을 사용하는 것이 `in` 연산 및 추가 시 성능에 더 효율적입니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n            file_name = file.filename\\n            if file_name not in review_request.file_paths:\\n                review_request.file_paths.append(file_name)\\n\\n            for hunk_idx, hunk in enumerate(file.hunks):\\n```\", \"improved_code\": \"```python\\n            file_name = file.filename\\n            # review_request 객체를 수정하지 않도록 변경\\n            # if file_name not in review_request.file_paths:\\n            #     review_request.file_paths.append(file_name)\\n\\n            for hunk_idx, hunk in enumerate(file.hunks):\\n```\"}], \"summary\": \"제공된 코드는 코드 리뷰를 위한 프롬프트를 생성하는 기능을 구현합니다. 특히 `load_file_content` 함수에 디렉토리 탐색 공격을 방지하기 위한 보안 검사 로직이 추가되었습니다. 이는 코드의 보안성을 크게 향상시키는 긍정적인 변경입니다. 다만, 심볼릭 링크에 대한 잠재적 취약점, 광범위한 예외 처리, 비효율적인 캐시 사용, 입력 객체 수정과 같은 개선할 수 있는 부분들이 존재합니다.\", \"score\": 7.0, \"recommendations\": [\"파일 경로 유효성 검사 시 심볼릭 링크를 고려하여 `os.path.realpath` 사용을 검토하세요.\", \"파일 읽기 오류 처리를 더 구체적인 예외 타입으로 제한하여 디버깅 용이성을 높이세요.\", \"`load_file_content` 함수의 `lru_cache(maxsize=1)`를 제거하거나 적절한 캐싱 전략을 재검토하세요.\", \"프롬프트 생성 함수 내에서 입력 객체(`review_request`)를 수정하는 부수 효과를 제거하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        repo_path=repo_path,\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 559}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n    main_cli()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    main()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"file_content\\\": \\\"import re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils.prompts import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_FILE_HEADER = re.compile(r\\\\\\\"^diff --git a/(\\\\\\\\S+) b/(\\\\\\\\S+)\\\\\\\", flags=re.MULTILINE)\\\\n\\\\n\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파싱하여 구조화된 DiffResult 객체를 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n\\\\n    Returns:\\\\n        DiffResult: Git diff 결과를 나타내는 객체\\\\n\\\\n    Raises:\\\\n        DiffParsingError: diff가 비어있거나 유효하지 않은 형식인 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not diff_text:\\\\n        raise DiffParsingError(\\\\\\\"빈 diff가 제공되었습니다.\\\\\\\")\\\\n\\\\n    file_diffs = _PATTERN_DIFF_SPLIT.split(diff_text)\\\\n    result = DiffResult()\\\\n\\\\n    for raw_diff in file_diffs:\\\\n        if not raw_diff.strip():\\\\n            continue\\\\n        header_match = _PATTERN_FILE_HEADER.search(raw_diff)\\\\n        if header_match:\\\\n            filename = header_match.group(2)\\\\n        else:\\\\n            continue\\\\n\\\\n        hunks = _PATTERN_HUNK_SPLIT.split(raw_diff)\\\\n        hunk_list = [\\\\n            Hunk.from_hunk_text(h) for h in hunks if h.lstrip().startswith(\\\\\\\"@@\\\\\\\")\\\\n        ]\\\\n\\\\n        if use_full_context:\\\\n            file_content = load_file_content(filename, repo_path)\\\\n        else:\\\\n            file_content = None\\\\n\\\\n        parsed_diff = FileDiff(\\\\n            filename=filename, file_content=file_content, hunks=hunk_list\\\\n        )\\\\n        parsed_diff.detect_language()\\\\n        parsed_diff.calculate_changes()\\\\n        result.files.append(parsed_diff)\\\\n\\\\n    if not result.files:\\\\n        raise DiffParsingError(\\\\\\\"유효하지 않은 diff 형식입니다.\\\\\\\")\\\\n\\\\n    return result\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\ndef parse_git_diff(diff_text: str, use_full_context: bool) -> DiffResult:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n```\\\", \\\"line_number\\\": 20}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n```\\\", \\\"line_number\\\": 57}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        file_path = os.path.join(project_root, filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n```\\\", \\\"line_number\\\": 70}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n        raise e\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n```\\\", \\\"line_number\\\": 152}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n```\\\", \\\"line_number\\\": 192}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n```\\\", \\\"line_number\\\": 197}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n```\\\", \\\"line_number\\\": 203}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n```\\\", \\\"line_number\\\": 215}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n    repo_path: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    repo_path: str\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"setup.py\\\", \\\"file_content\\\": \\\"from setuptools import find_packages, setup\\\\n\\\\n# 실행에 필요한 기본 의존성 패키지 목록\\\\nrequired = [\\\\n    \\\\\\\"requests>=2.31.0\\\\\\\",\\\\n    \\\\\\\"pydantic>=2.6.1\\\\\\\",\\\\n    \\\\\\\"python-dotenv>=1.0.0\\\\\\\",\\\\n    \\\\\\\"openai>=1.65.4\\\\\\\",\\\\n    \\\\\\\"anthropic>=0.39.0\\\\\\\",\\\\n    \\\\\\\"tiktoken>=0.5.2\\\\\\\",\\\\n    \\\\\\\"instructor>=1.7.7\\\\\\\",\\\\n    \\\\\\\"streamlit>=1.32.0\\\\\\\",\\\\n]\\\\n\\\\n# 개발 및 테스트에 필요한 추가 의존성\\\\ndev_required = [\\\\n    \\\\\\\"pytest>=7.4.4\\\\\\\",\\\\n    \\\\\\\"pytest-cov>=4.1.0\\\\\\\",\\\\n    \\\\\\\"build>=1.0.3\\\\\\\",\\\\n    \\\\\\\"twine>=6.0.0\\\\\\\",\\\\n    \\\\\\\"wheel>=0.40.0\\\\\\\",\\\\n]\\\\n\\\\nsetup(\\\\n    name=\\\\\\\"reviewer\\\\\\\",\\\\n    version=\\\\\\\"0.1.0\\\\\\\",\\\\n    packages=find_packages(),\\\\n    install_requires=required,\\\\n    extras_require={\\\\n        \\\\\\\"dev\\\\\\\": dev_required,\\\\n    },\\\\n    entry_points={\\\\n        \\\\\\\"console_scripts\\\\\\\": [\\\\n            \\\\\\\"reviewer=reviewer.cli:main\\\\\\\",\\\\n        ],\\\\n    },\\\\n    python_requires=\\\\\\\">=3.6\\\\\\\",\\\\n    description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\",\\\\n    author=\\\\\\\"Reviewer 팀\\\\\\\",\\\\n    classifiers=[\\\\n        \\\\\\\"Programming Language :: Python :: 3\\\\\\\",\\\\n        \\\\\\\"License :: OSI Approved :: MIT License\\\\\\\",\\\\n        \\\\\\\"Operating System :: OS Independent\\\\\\\",\\\\n    ],\\\\n)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n            \\\\\\\"reviewer=reviewer.cli:main_cli\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"reviewer=reviewer.cli:main\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 14, \"file\": \"reviewer/src/diff_parser/parser.py\", \"description\": \"`parse_git_diff` 함수 시그니처에 `repo_path` 인수가 추가되었습니다. 이는 저장소 경로를 명시적으로 전달하기 위한 변경으로, 함수 사용 방식이 변경됩니다.\", \"suggestion\": \"변경 사항을 문서화하고, 해당 함수를 사용하는 다른 부분에서도 `repo_path`를 올바르게 전달하는지 확인해야 합니다. (현재 diff에서는 잘 반영됨)\", \"severity\": \"info\", \"original_code\": \"```python\\ndef parse_git_diff(diff_text: str, use_full_context: bool) -> DiffResult:\\n```\", \"improved_code\": \"```python\\ndef parse_git_diff(\\n    diff_text: str, use_full_context: bool, repo_path: str\\n) -> DiffResult:\\n```\"}, {\"type\": \"설계\", \"line_number\": 50, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"`load_file_content` 함수 시그니처에 `repo_path` 인수가 추가되었습니다. 이는 저장소 경로를 기준으로 파일을 찾기 위한 변경입니다.\", \"suggestion\": \"변경 사항을 문서화하고, 해당 함수를 사용하는 다른 부분에서도 `repo_path`를 올바르게 전달하는지 확인해야 합니다. (현재 diff에서는 잘 반영됨)\", \"severity\": \"info\", \"original_code\": \"```python\\ndef load_file_content(filename: str) -> str:\\n    \\\"\\\"\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\"\\\"\\\"\\n    try:\\n        # Git 루트 디렉토리 찾기\\n        project_root = find_project_root()\\n```\", \"improved_code\": \"```python\\ndef load_file_content(filename: str, repo_path: str) -> str:\\n    \\\"\\\"\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\n\\n    Args:\\n        filename (str): 읽을 파일 경로\\n        repo_path (str): 저장소 경로\\n```\"}, {\"type\": \"버그\", \"line_number\": 70, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"바이너리 파일 및 인코딩 오류가 있는 파일을 LLM에 전달하지 않고 건너뛰거나 플레이스홀더를 사용하는 로직이 추가되었습니다. 이는 LLM 처리 오류를 방지하고 불필요한 토큰 사용을 줄입니다.\", \"suggestion\": \"바이너리 파일이나 건너뛴 파일에 대해 사용자에게 명확하게 알리는 로그 메시지를 추가하면 좋습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        # 파일 내용 읽기\\n        if os.path.exists(file_path):\\n```\", \"improved_code\": \"```python\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\n        if is_binary_file(filename):\\n            return f\\\"[바이너리 파일: {filename}]\\\"\\n\\n        # UTF-8로 파일 읽기 시도\\n        try:\\n```\"}, {\"type\": \"스타일\", \"line_number\": 49, \"file\": \"reviewer/cli.py\", \"description\": \"`--model` 인수의 도움말 텍스트 형식이 f-string에서 `%(default)s`로 변경되었습니다. 이는 `argparse`의 표준적인 기본값 표시 방법입니다.\", \"suggestion\": \"다른 인수의 도움말 텍스트에서도 `%(default)s`를 일관되게 사용하는 것을 고려할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        help=f\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\",\\n```\", \"improved_code\": \"```python\\n        help=\\\"사용할 AI 모델 (기본값: %(default)s)\\\",\\n```\"}, {\"type\": \"스타일\", \"line_number\": 559, \"file\": \"reviewer/cli.py\", \"description\": \"CLI 진입점 함수 이름이 `main_cli`에서 `main`으로 변경되었습니다. `setup.py`의 `entry_points`도 이에 맞춰 업데이트되었습니다. 이는 일반적인 Python CLI 애플리케이션의 진입점 명명 규칙을 따릅니다.\", \"suggestion\": \"특별한 추가 제안은 없습니다. 좋은 변경입니다.\", \"severity\": \"info\", \"original_code\": \"```python\\ndef main_cli() -> None:\\n    \\\"\\\"\\\"CLI 도구의 진입점 함수\\\"\\\"\\\"\\n    try:\\n        main()\\n    except KeyboardInterrupt:\\n        logger.info(\\\"\\\\n실행이 취소되었습니다.\\\")\\n    except Exception as e:\\n        logger.error(f\\\"오류 발생: {str(e)}\\\")\\n        sys.exit(1)\\n\\n\\n```\", \"improved_code\": \"```python\\n\\n```\"}], \"summary\": \"이 변경사항은 코드 리뷰 도구에 저장소 경로 지정 기능(`--repo-path`)을 추가하고, 전체 파일 컨텍스트 사용 시 해당 경로를 기준으로 파일을 읽도록 수정합니다. 또한, 바이너리 파일 및 인코딩 오류가 있는 파일을 건너뛰어 LLM 처리의 안정성을 높였습니다. CLI 진입점 함수 이름 변경 및 도움말 텍스트 형식 개선과 같은 스타일 및 리팩토링 변경도 포함됩니다.\", \"score\": 9.0, \"recommendations\": [\"문서 업데이트: `parse_git_diff` 및 `load_file_content` 함수의 `repo_path` 인수에 대한 설명을 추가합니다.\", \"로그 개선: 바이너리 파일이나 인코딩 오류로 인해 건너뛴 파일에 대한 명확한 로그 메시지를 추가합니다.\", \"일관된 도움말 형식: `argparse`의 `%(default)s` 형식을 다른 인수의 도움말 텍스트에도 일관되게 적용하는 것을 고려합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    main()\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        repo_path=repo_path,\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    main()\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n    main_cli()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    main()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"file_content\\\": \\\"import re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils.prompts import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_FILE_HEADER = re.compile(r\\\\\\\"^diff --git a/(\\\\\\\\S+) b/(\\\\\\\\S+)\\\\\\\", flags=re.MULTILINE)\\\\n\\\\n\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파싱하여 구조화된 DiffResult 객체를 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n\\\\n    Returns:\\\\n        DiffResult: Git diff 결과를 나타내는 객체\\\\n\\\\n    Raises:\\\\n        DiffParsingError: diff가 비어있거나 유효하지 않은 형식인 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not diff_text:\\\\n        raise DiffParsingError(\\\\\\\"빈 diff가 제공되었습니다.\\\\\\\")\\\\n\\\\n    file_diffs = _PATTERN_DIFF_SPLIT.split(diff_text)\\\\n    result = DiffResult()\\\\n\\\\n    for raw_diff in file_diffs:\\\\n        if not raw_diff.strip():\\\\n            continue\\\\n        header_match = _PATTERN_FILE_HEADER.search(raw_diff)\\\\n        if header_match:\\\\n            filename = header_match.group(2)\\\\n        else:\\\\n            continue\\\\n\\\\n        hunks = _PATTERN_HUNK_SPLIT.split(raw_diff)\\\\n        hunk_list = [\\\\n            Hunk.from_hunk_text(h) for h in hunks if h.lstrip().startswith(\\\\\\\"@@\\\\\\\")\\\\n        ]\\\\n\\\\n        if use_full_context:\\\\n            file_content = load_file_content(filename, repo_path)\\\\n        else:\\\\n            file_content = None\\\\n\\\\n        parsed_diff = FileDiff(\\\\n            filename=filename, file_content=file_content, hunks=hunk_list\\\\n        )\\\\n        parsed_diff.detect_language()\\\\n        parsed_diff.calculate_changes()\\\\n        result.files.append(parsed_diff)\\\\n\\\\n    if not result.files:\\\\n        raise DiffParsingError(\\\\\\\"유효하지 않은 diff 형식입니다.\\\\\\\")\\\\n\\\\n    return result\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\ndef parse_git_diff(diff_text: str, use_full_context: bool) -> DiffResult:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n```\\\", \\\"line_number\\\": 20}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n```\\\", \\\"line_number\\\": 57}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        file_path = os.path.join(project_root, filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n```\\\", \\\"line_number\\\": 70}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n        raise e\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n```\\\", \\\"line_number\\\": 152}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n```\\\", \\\"line_number\\\": 192}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n```\\\", \\\"line_number\\\": 197}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n```\\\", \\\"line_number\\\": 203}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n```\\\", \\\"line_number\\\": 215}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n    repo_path: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    repo_path: str\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 49, \"file\": \"reviewer/cli.py\", \"description\": \"--model 인수의 도움말 문자열에서 기본값을 표시하기 위해 f-string을 사용하고 있습니다. argparse는 기본값을 자동으로 표시하기 위한 `%(default)s` 플레이스홀더를 제공하며, 이를 사용하는 것이 더 표준적이고 유지보수하기 좋습니다.\", \"suggestion\": \"도움말 문자열에서 `%(default)s` 플레이스홀더를 사용하여 argparse가 기본값을 자동으로 삽입하도록 변경하세요.\", \"severity\": \"info\", \"original_code\": \"        help=f\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\",\", \"improved_code\": \"        help=\\\"사용할 AI 모델 (기본값: %(default)s)\\\",\"}, {\"type\": \"설계\", \"line_number\": 82, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"`load_file_content` 함수에서 광범위한 `Exception`을 잡고 수동으로 트레이스백을 포함한 새로운 예외 메시지를 구성하여 다시 발생시키고 있습니다. 이는 예상치 못한 다양한 오류를 잡을 수 있지만, 특정 파일 관련 오류(예: `IOError`, `OSError`)를 구분하기 어렵게 만들고, 수동 트레이스백 포맷팅은 로깅 라이브러리의 기능을 제대로 활용하지 못합니다.\", \"suggestion\": \"파일 관련 특정 예외(`IOError`, `OSError` 등)를 먼저 잡고, 로깅 시 `exc_info=True`를 사용하여 자동으로 트레이스백을 포함하도록 변경하세요. 예외 발생 시에는 원본 예외를 그대로 다시 발생시키거나, 원본 예외를 포함하는 새로운 예외를 발생시켜 호출자가 오류 유형을 더 쉽게 판단하고 처리할 수 있도록 하세요.\", \"severity\": \"warning\", \"original_code\": \"except Exception as e:\\n    # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\n    import traceback\\n\\n    error_msg = f\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\n{traceback.format_exc()}\\\"\\n    raise Exception(error_msg) from e\", \"improved_code\": \"except (IOError, OSError) as e:\\n    logger.error(f\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\", exc_info=True)\\n    raise # Re-raise the specific exception\\nexcept Exception as e: # Catch any other unexpected errors\\n    logger.error(f\\\"파일 '{filename}' 읽기 중 예상치 못한 오류 발생: {str(e)}\\\", exc_info=True)\\n    raise # Re-raise the unexpected exception\"}], \"summary\": \"이 변경사항은 Git 저장소 경로 처리 로직을 개선하고, 파일 내용 로딩 시 바이너리 파일 및 인코딩 오류 처리를 강화합니다. `repo_path` 인자가 `parse_git_diff` 및 `load_file_content` 함수로 전달되도록 수정되었으며, `ReviewRequest` 모델에도 추가되었습니다. 또한, CLI 진입점 코드가 간소화되었습니다.\", \"score\": 8.0, \"recommendations\": [\"`load_file_content` 함수에서 예외 처리 로직을 좀 더 구체적인 예외 타입을 잡고 로깅 라이브러리의 `exc_info`를 활용하는 방식으로 개선하는 것을 고려하세요.\", \"새로운 `repo_path` 처리 로직과 `load_file_content` 함수의 다양한 시나리오(파일 없음, 바이너리 파일, 인코딩 오류 등)에 대한 단위 테스트를 추가하여 코드의 견고성을 높이세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        repo_path=repo_path,\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"file_content\\\": \\\"import re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils.prompts import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_FILE_HEADER = re.compile(r\\\\\\\"^diff --git a/(\\\\\\\\S+) b/(\\\\\\\\S+)\\\\\\\", flags=re.MULTILINE)\\\\n\\\\n\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파싱하여 구조화된 DiffResult 객체를 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n\\\\n    Returns:\\\\n        DiffResult: Git diff 결과를 나타내는 객체\\\\n\\\\n    Raises:\\\\n        DiffParsingError: diff가 비어있거나 유효하지 않은 형식인 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not diff_text:\\\\n        raise DiffParsingError(\\\\\\\"빈 diff가 제공되었습니다.\\\\\\\")\\\\n\\\\n    file_diffs = _PATTERN_DIFF_SPLIT.split(diff_text)\\\\n    result = DiffResult()\\\\n\\\\n    for raw_diff in file_diffs:\\\\n        if not raw_diff.strip():\\\\n            continue\\\\n        header_match = _PATTERN_FILE_HEADER.search(raw_diff)\\\\n        if header_match:\\\\n            filename = header_match.group(2)\\\\n        else:\\\\n            continue\\\\n\\\\n        hunks = _PATTERN_HUNK_SPLIT.split(raw_diff)\\\\n        hunk_list = [\\\\n            Hunk.from_hunk_text(h) for h in hunks if h.lstrip().startswith(\\\\\\\"@@\\\\\\\")\\\\n        ]\\\\n\\\\n        if use_full_context:\\\\n            file_content = load_file_content(filename, repo_path)\\\\n        else:\\\\n            file_content = None\\\\n\\\\n        parsed_diff = FileDiff(\\\\n            filename=filename, file_content=file_content, hunks=hunk_list\\\\n        )\\\\n        parsed_diff.detect_language()\\\\n        parsed_diff.calculate_changes()\\\\n        result.files.append(parsed_diff)\\\\n\\\\n    if not result.files:\\\\n        raise DiffParsingError(\\\\\\\"유효하지 않은 diff 형식입니다.\\\\\\\")\\\\n\\\\n    return result\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\ndef parse_git_diff(diff_text: str, use_full_context: bool) -> DiffResult:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n```\\\", \\\"line_number\\\": 20}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom .file_utils import BINARY_EXTENSIONS, BINARY_FILENAMES, is_binary_file\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n__all__ = [\\\\n    \\\\\\\"run_git_diff\\\\\\\",\\\\n    \\\\\\\"save_prompt\\\\\\\",\\\\n    \\\\\\\"is_binary_file\\\\\\\",\\\\n    \\\\\\\"BINARY_EXTENSIONS\\\\\\\",\\\\n    \\\\\\\"BINARY_FILENAMES\\\\\\\",\\\\n]\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n    except Exception as e:\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n            try:\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.file_utils import is_binary_file\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n```\\\", \\\"line_number\\\": 57}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        file_path = os.path.join(project_root, filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        if not os.path.exists(file_path):\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\\\n        if is_binary_file(filename):\\\\n            return f\\\\\\\"[바이너리 파일: {filename}]\\\\\\\"\\\\n\\\\n        # UTF-8로 파일 읽기 시도\\\\n        try:\\\\n```\\\", \\\"line_number\\\": 70}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        except UnicodeDecodeError:\\\\n            # 인코딩 오류 시 바이너리 파일로 간주\\\\n            return f\\\\\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\\\\\"\\\\n\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n        raise e\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 단순 예외 전파가 아닌 의미 있는 오류 메시지 제공\\\\n        import traceback\\\\n\\\\n        error_msg = f\\\\\\\"파일 '{filename}' 읽기 오류: {str(e)}\\\\\\\\n{traceback.format_exc()}\\\\\\\"\\\\n        raise Exception(error_msg) from e\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(file.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n```\\\", \\\"line_number\\\": 152}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n```\\\", \\\"line_number\\\": 192}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            # 바이너리 파일인지 먼저 확인\\\\n            if is_binary_file(request.filename):\\\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\\\n                continue\\\\n\\\\n```\\\", \\\"line_number\\\": 197}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # 파일 내용 읽기 시도\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n\\\\n                # user_prompt 생성\\\\n                user_prompt = UserPromptWithFileContent(\\\\n                    file_name=request.filename,\\\\n                    file_content=file_content,\\\\n                    hunks=request.hunks,\\\\n                    language=request.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n```\\\", \\\"line_number\\\": 203}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            except FileNotFoundError:\\\\n                # 파일을 찾을 수 없는 경우도 건너뜁니다\\\\n                continue\\\\n```\\\", \\\"line_number\\\": 215}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n    repo_path: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    repo_path: str\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"design\", \"line_number\": 257, \"file\": \"reviewer/cli.py\", \"description\": \"Git 저장소 경로(`repo_path`)를 파싱 및 리뷰 요청 객체에 전달하도록 변경되었습니다. 이를 통해 사용자가 지정한 경로 또는 탐지된 프로젝트 루트를 기준으로 파일 컨텍스트를 로드할 수 있게 됩니다.\", \"suggestion\": \"이 변경은 다양한 저장소 구조를 지원하고 파일 컨텍스트 로딩의 정확성을 높입니다. 관련 함수 시그니처 및 모델 정의가 일관되게 업데이트되었습니다.\", \"severity\": \"info\", \"original_code\": \"diff_result = parse_git_diff(diff_content, use_full_context)\", \"improved_code\": \"diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\"}, {\"type\": \"quality\", \"line_number\": 72, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"`load_file_content` 함수에서 바이너리 파일 및 인코딩 오류를 명시적으로 처리하도록 개선되었습니다. 바이너리 파일은 읽지 않고, 인코딩 오류 발생 시에도 예외 대신 특정 문자열을 반환하여 안정성을 높였습니다. 또한, 파일 읽기 실패 시 더 상세한 오류 메시지를 제공합니다.\", \"suggestion\": \"이러한 변경은 LLM이 처리할 수 없는 내용을 프롬프트에 포함시키는 것을 방지하고, 파일 로딩 실패 시 디버깅을 용이하게 합니다.\", \"severity\": \"info\", \"original_code\": \"        # 파일 내용 읽기\\n        if os.path.exists(file_path):\\n            with open(file_path, encoding=\\\"utf-8\\\") as f:\\n                return f.read()\\n        else:\\n            raise FileNotFoundError(f\\\"파일을 찾을 수 없습니다: {file_path}\\\")\", \"improved_code\": \"        # 바이너리 파일인지 확인 (파일 확장자 및 이름 기준)\\n        if is_binary_file(filename):\\n            return f\\\"[바이너리 파일: {filename}]\\\"\\n\\n        # UTF-8로 파일 읽기 시도\\n        try:\\n            with open(file_path, encoding=\\\"utf-8\\\") as f:\\n                return f.read()\\n        except UnicodeDecodeError:\\n            # 인코딩 오류 시 바이너리 파일로 간주\\n            return f\\\"[인코딩 오류로 읽을 수 없는 파일: {filename}]\\\"\"}, {\"type\": \"performance\", \"line_number\": 152, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"코드 리뷰 프롬프트 생성 시, 바이너리 파일로 식별된 파일은 처리 대상에서 제외하도록 변경되었습니다. 이는 LLM이 처리할 수 없는 내용을 프롬프트에 포함시키는 것을 방지하고, 불필요한 토큰 사용을 줄입니다.\", \"suggestion\": \"이 변경은 프롬프트의 품질과 LLM 처리 효율성을 향상시킵니다.\", \"severity\": \"info\", \"original_code\": \"        for file in review_request.processed_diff.files:\\n            file_name = file.filename\\n            if file_name not in review_request.file_paths:\\n                review_request.file_paths.append(file_name)\\n\\n            for hunk_idx, hunk in enumerate(file.hunks):\", \"improved_code\": \"        for file in review_request.processed_diff.files:\\n            # 바이너리 파일인지 먼저 확인\\n            if is_binary_file(file.filename):\\n                # 바이너리 파일은 처리하지 않고 건너뜁니다\\n                continue\\n\\n            file_name = file.filename\\n            if file_name not in review_request.file_paths:\\n                review_request.file_paths.append(file_name)\\n\\n            for hunk_idx, hunk in enumerate(file.hunks):\"}, {\"type\": \"quality\", \"line_number\": 255, \"file\": \"reviewer/cli.py\", \"description\": \"`--repo-path .` 옵션 사용 시, 현재 디렉토리에서 프로젝트 루트를 찾지 못하면 `FileNotFoundError`가 발생합니다. 이 예외는 `main` 함수의 일반 예외 처리 블록에서 잡히지만, 사용자에게 \\\"프로젝트 루트를 찾을 수 없습니다\\\"와 같은 더 구체적인 오류 메시지를 직접 제공하면 문제 해결에 도움이 될 수 있습니다.\", \"suggestion\": \"`find_project_root()` 호출 시 발생하는 `FileNotFoundError`를 명시적으로 잡아서 사용자에게 더 유용한 오류 메시지를 출력하도록 개선할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"    repo_path = (\\n        str(Path(args.repo_path)) if args.repo_path != \\\".\\\" else str(find_project_root())\\n    )\", \"improved_code\": \"    try:\\n        repo_path = (\\n            str(Path(args.repo_path)) if args.repo_path != \\\".\\\" else str(find_project_root())\\n        )\\n    except FileNotFoundError as e:\\n        logger.error(f\\\"오류: 프로젝트 루트를 찾을 수 없습니다. Git 저장소 또는 프로젝트 식별 파일(.git, pyproject.toml 등)이 있는 디렉토리에서 실행하거나 --repo-path 옵션을 사용하세요. ({e})\\\")\\n        sys.exit(1)\"}], \"summary\": \"Git 저장소 경로 처리 개선 및 파일 컨텍스트 로딩 안정성 향상. 바이너리 파일 및 인코딩 오류 처리를 추가하여 LLM 프롬프트 생성의 정확성과 효율성을 높였습니다.\", \"score\": 9.0, \"recommendations\": [\"프로젝트 루트 탐색 실패 시 사용자에게 더 명확한 오류 메시지를 제공하도록 개선합니다.\", \"새로운 `--repo-path` 옵션의 동작 방식(특히 \\\".\\\" 입력 시)에 대한 문서를 업데이트합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"file_content\\\": \\\"distributionBase=GRADLE_USER_HOME\\\\ndistributionPath=wrapper/dists\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\nnetworkTimeout=10000\\\\nvalidateDistributionUrl=true\\\\nzipStoreBase=GRADLE_USER_HOME\\\\nzipStorePath=wrapper/dists\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.7-bin.zip\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew.bat\\\", \\\"file_content\\\": \\\"@rem\\\\n@rem Copyright 2015 the original author or authors.\\\\n@rem\\\\n@rem Licensed under the Apache License, Version 2.0 (the \\\\\\\"License\\\\\\\");\\\\n@rem you may not use this file except in compliance with the License.\\\\n@rem You may obtain a copy of the License at\\\\n@rem\\\\n@rem      https://www.apache.org/licenses/LICENSE-2.0\\\\n@rem\\\\n@rem Unless required by applicable law or agreed to in writing, software\\\\n@rem distributed under the License is distributed on an \\\\\\\"AS IS\\\\\\\" BASIS,\\\\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\\\n@rem See the License for the specific language governing permissions and\\\\n@rem limitations under the License.\\\\n@rem\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n\\\\n@if \\\\\\\"%DEBUG%\\\\\\\"==\\\\\\\"\\\\\\\" @echo off\\\\n@rem ##########################################################################\\\\n@rem\\\\n@rem  Gradle startup script for Windows\\\\n@rem\\\\n@rem ##########################################################################\\\\n\\\\n@rem Set local scope for the variables with windows NT shell\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" setlocal\\\\n\\\\nset DIRNAME=%~dp0\\\\nif \\\\\\\"%DIRNAME%\\\\\\\"==\\\\\\\"\\\\\\\" set DIRNAME=.\\\\n@rem This is normally unused\\\\nset APP_BASE_NAME=%~n0\\\\nset APP_HOME=%DIRNAME%\\\\n\\\\n@rem Resolve any \\\\\\\".\\\\\\\" and \\\\\\\"..\\\\\\\" in APP_HOME to make it shorter.\\\\nfor %%i in (\\\\\\\"%APP_HOME%\\\\\\\") do set APP_HOME=%%~fi\\\\n\\\\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\\\\nset DEFAULT_JVM_OPTS=\\\\\\\"-Xmx64m\\\\\\\" \\\\\\\"-Xms64m\\\\\\\"\\\\n\\\\n@rem Find java.exe\\\\nif defined JAVA_HOME goto findJavaFromJavaHome\\\\n\\\\nset JAVA_EXE=java.exe\\\\n%JAVA_EXE% -version >NUL 2>&1\\\\nif %ERRORLEVEL% equ 0 goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:findJavaFromJavaHome\\\\nset JAVA_HOME=%JAVA_HOME:\\\\\\\"=%\\\\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\\\\n\\\\nif exist \\\\\\\"%JAVA_EXE%\\\\\\\" goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:execute\\\\n@rem Setup the command line\\\\n\\\\nset CLASSPATH=%APP_HOME%\\\\\\\\gradle\\\\\\\\wrapper\\\\\\\\gradle-wrapper.jar\\\\n\\\\n\\\\n@rem Execute Gradle\\\\n\\\\\\\"%JAVA_EXE%\\\\\\\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \\\\\\\"-Dorg.gradle.appname=%APP_BASE_NAME%\\\\\\\" -classpath \\\\\\\"%CLASSPATH%\\\\\\\" org.gradle.wrapper.GradleWrapperMain %*\\\\n\\\\n:end\\\\n@rem End local scope for the variables with windows NT shell\\\\nif %ERRORLEVEL% equ 0 goto mainEnd\\\\n\\\\n:fail\\\\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\\\\nrem the _cmd.exe /c_ return code!\\\\nset EXIT_CODE=%ERRORLEVEL%\\\\nif %EXIT_CODE% equ 0 set EXIT_CODE=1\\\\nif not \\\\\\\"\\\\\\\"==\\\\\\\"%GRADLE_EXIT_CONSOLE%\\\\\\\" exit %EXIT_CODE%\\\\nexit /b %EXIT_CODE%\\\\n\\\\n:mainEnd\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" endlocal\\\\n\\\\n:omega\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 9, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\", \"description\": \"`InMemoryDatabase`에서 `users`와 `articles` 맵의 값 타입이 `Any`로 선언되어 있어 타입 안전성이 부족했습니다. 실제 저장되는 객체의 타입(`User`, `Article`)으로 명시하여 타입 안전성을 확보한 것은 좋은 개선입니다.\", \"suggestion\": \"맵의 값 타입을 구체적으로 명시하여 컴파일 시점에 타입 오류를 감지하고 코드의 가독성을 높였습니다.\", \"severity\": \"info\", \"original_code\": \"val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\", \"improved_code\": \"val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\"}, {\"type\": \"스타일\", \"line_number\": 49, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\", \"description\": \"`InMemoryDatabase`의 맵 타입이 구체적인 타입으로 변경됨에 따라, 값을 가져올 때 필요했던 불필요한 캐스팅(`as? User`, `as? Article`)이 제거되었습니다. 이는 코드의 간결성과 가독성을 높입니다.\", \"suggestion\": \"타입 안전성이 확보되어 불필요한 캐스팅 코드가 제거되었습니다.\", \"severity\": \"info\", \"original_code\": \"var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\", \"improved_code\": \"var filtered = InMemoryDatabase.articles.values.toList().map { it }\"}, {\"type\": \"스타일\", \"line_number\": 14, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\", \"description\": \"`replaceAll` 람다에서 사용되지 않는 키 파라미터(`articleId`)를 코틀린 컨벤션에 따라 언더스코어(`_`)로 변경하여 의도를 명확히 했습니다.\", \"suggestion\": \"사용되지 않는 파라미터는 `_`로 표기하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"InMemoryDatabase.articles.replaceAll { articleId, article ->\", \"improved_code\": \"InMemoryDatabase.articles.replaceAll { _, article ->\"}, {\"type\": \"설계\", \"line_number\": 8, \"file\": \"gradle/wrapper/gradle-wrapper.properties\", \"description\": \"`gradle-wrapper.properties` 파일에 특정 개발 환경의 Java 홈 경로가 하드코딩되었습니다. 이 설정은 개발 환경마다 다를 수 있으므로, 공유 저장소에 포함될 경우 다른 개발자의 빌드 환경에서 문제가 발생할 수 있습니다.\", \"suggestion\": \"이 설정은 로컬 환경 설정으로 관리하거나, `.gitignore`에 추가하여 커밋되지 않도록 하는 것이 좋습니다. 또는 환경 변수를 사용하도록 가이드하는 방법을 고려할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"\\\\ No newline at end of file\", \"improved_code\": \"org.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\"}], \"summary\": \"이 변경사항은 주로 테스트 코드의 `InMemoryDatabase`에서 `Any` 타입을 구체적인 타입(`User`, `Article`)으로 변경하여 타입 안전성을 개선하고, 이에 따라 불필요해진 캐스팅 코드를 제거했습니다. 또한, `MockUserRepository`에서 사용되지 않는 람다 파라미터를 `_`로 변경하는 스타일 개선이 있었습니다. Gradle 버전이 8.7에서 8.10으로 업데이트되었고, `gradle-wrapper.properties`에 특정 Java 홈 경로 설정이 추가되었습니다. `gradlew.bat` 파일에는 SPDX 라이선스 식별자가 추가되었습니다.\", \"score\": 9.0, \"recommendations\": [\"`gradle-wrapper.properties`에 하드코딩된 `org.gradle.java.home` 경로는 로컬 환경 설정으로 관리하거나 `.gitignore`에 추가하여 공유 저장소에 포함되지 않도록 수정하는 것을 고려하세요.\", \"테스트 코드의 가독성과 유지보수성을 위해 일관된 코틀린 컨벤션을 적용하는 것을 권장합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.jar\\\", \\\"file_content\\\": \\\"[바이너리 파일: gradle/wrapper/gradle-wrapper.jar]\\\", \\\"formatted_hunks\\\": []}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"file_content\\\": \\\"distributionBase=GRADLE_USER_HOME\\\\ndistributionPath=wrapper/dists\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\nnetworkTimeout=10000\\\\nvalidateDistributionUrl=true\\\\nzipStoreBase=GRADLE_USER_HOME\\\\nzipStorePath=wrapper/dists\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.7-bin.zip\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew\\\", \\\"file_content\\\": \\\"[바이너리 파일: gradlew]\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n# SPDX-License-Identifier: Apache-2.0\\\\n#\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```text\\\\nAPP_HOME=$( cd \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && pwd -P ) || exit\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\nAPP_HOME=$( cd -P \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && printf '%s\\\\n' \\\\\\\"$PWD\\\\\\\" ) || exit\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew.bat\\\", \\\"file_content\\\": \\\"@rem\\\\n@rem Copyright 2015 the original author or authors.\\\\n@rem\\\\n@rem Licensed under the Apache License, Version 2.0 (the \\\\\\\"License\\\\\\\");\\\\n@rem you may not use this file except in compliance with the License.\\\\n@rem You may obtain a copy of the License at\\\\n@rem\\\\n@rem      https://www.apache.org/licenses/LICENSE-2.0\\\\n@rem\\\\n@rem Unless required by applicable law or agreed to in writing, software\\\\n@rem distributed under the License is distributed on an \\\\\\\"AS IS\\\\\\\" BASIS,\\\\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\\\n@rem See the License for the specific language governing permissions and\\\\n@rem limitations under the License.\\\\n@rem\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n\\\\n@if \\\\\\\"%DEBUG%\\\\\\\"==\\\\\\\"\\\\\\\" @echo off\\\\n@rem ##########################################################################\\\\n@rem\\\\n@rem  Gradle startup script for Windows\\\\n@rem\\\\n@rem ##########################################################################\\\\n\\\\n@rem Set local scope for the variables with windows NT shell\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" setlocal\\\\n\\\\nset DIRNAME=%~dp0\\\\nif \\\\\\\"%DIRNAME%\\\\\\\"==\\\\\\\"\\\\\\\" set DIRNAME=.\\\\n@rem This is normally unused\\\\nset APP_BASE_NAME=%~n0\\\\nset APP_HOME=%DIRNAME%\\\\n\\\\n@rem Resolve any \\\\\\\".\\\\\\\" and \\\\\\\"..\\\\\\\" in APP_HOME to make it shorter.\\\\nfor %%i in (\\\\\\\"%APP_HOME%\\\\\\\") do set APP_HOME=%%~fi\\\\n\\\\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\\\\nset DEFAULT_JVM_OPTS=\\\\\\\"-Xmx64m\\\\\\\" \\\\\\\"-Xms64m\\\\\\\"\\\\n\\\\n@rem Find java.exe\\\\nif defined JAVA_HOME goto findJavaFromJavaHome\\\\n\\\\nset JAVA_EXE=java.exe\\\\n%JAVA_EXE% -version >NUL 2>&1\\\\nif %ERRORLEVEL% equ 0 goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:findJavaFromJavaHome\\\\nset JAVA_HOME=%JAVA_HOME:\\\\\\\"=%\\\\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\\\\n\\\\nif exist \\\\\\\"%JAVA_EXE%\\\\\\\" goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:execute\\\\n@rem Setup the command line\\\\n\\\\nset CLASSPATH=%APP_HOME%\\\\\\\\gradle\\\\\\\\wrapper\\\\\\\\gradle-wrapper.jar\\\\n\\\\n\\\\n@rem Execute Gradle\\\\n\\\\\\\"%JAVA_EXE%\\\\\\\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \\\\\\\"-Dorg.gradle.appname=%APP_BASE_NAME%\\\\\\\" -classpath \\\\\\\"%CLASSPATH%\\\\\\\" org.gradle.wrapper.GradleWrapperMain %*\\\\n\\\\n:end\\\\n@rem End local scope for the variables with windows NT shell\\\\nif %ERRORLEVEL% equ 0 goto mainEnd\\\\n\\\\n:fail\\\\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\\\\nrem the _cmd.exe /c_ return code!\\\\nset EXIT_CODE=%ERRORLEVEL%\\\\nif %EXIT_CODE% equ 0 set EXIT_CODE=1\\\\nif not \\\\\\\"\\\\\\\"==\\\\\\\"%GRADLE_EXIT_CONSOLE%\\\\\\\" exit %EXIT_CODE%\\\\nexit /b %EXIT_CODE%\\\\n\\\\n:mainEnd\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" endlocal\\\\n\\\\n:omega\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 8, \"file\": \"gradle/wrapper/gradle-wrapper.properties\", \"description\": \"gradle-wrapper.properties 파일에 개발자 로컬 환경의 Java 경로가 포함되어 있습니다. 이는 다른 개발자의 환경에서는 유효하지 않으며, 프로젝트 설정 파일에 로컬 경로를 포함하는 것은 좋지 않은 관행입니다.\", \"suggestion\": \"해당 라인을 삭제하여 모든 개발자가 각자의 환경 설정(예: JAVA_HOME 환경 변수)을 사용하도록 하거나, 필요한 경우 로컬 `.gradle/gradle.properties` 파일에 설정하도록 안내합니다.\", \"severity\": \"warning\", \"original_code\": \"zipStorePath=wrapper/dists\", \"improved_code\": \"zipStorePath=wrapper/dists\"}], \"summary\": \"이 변경사항은 테스트 코드의 인메모리 데이터베이스에서 Any 타입을 구체적인 타입(User, Article)으로 변경하여 타입 안정성을 개선하고, 이에 따라 Mock 리포지토리 코드에서 불필요한 타입 캐스팅과 mapNotNull 호출을 제거하여 코드를 간결화했습니다. 또한, Gradle Wrapper 버전을 8.7에서 8.10으로 업데이트하고, wrapper 스크립트에 SPDX 라이선스 식별자를 추가했습니다. MockUserRepository에서는 사용되지 않는 파라미터를 `_`로 변경하고 불필요한 주석을 제거하는 등 사소한 코드 스타일 개선도 포함되었습니다. 다만, gradle-wrapper.properties 파일에 로컬 환경의 Java 경로가 포함된 점은 개선이 필요합니다.\", \"score\": 8.0, \"recommendations\": [\"gradle/wrapper/gradle-wrapper.properties 파일에서 로컬 환경의 Java 경로 설정을 제거하세요.\", \"앞으로도 타입 안전성을 높이고 불필요한 코드를 제거하는 방향으로 코드를 개선해 나가세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.jar\\\", \\\"file_content\\\": \\\"[바이너리 파일: gradle/wrapper/gradle-wrapper.jar]\\\", \\\"formatted_hunks\\\": []}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"file_content\\\": \\\"distributionBase=GRADLE_USER_HOME\\\\ndistributionPath=wrapper/dists\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\nnetworkTimeout=10000\\\\nvalidateDistributionUrl=true\\\\nzipStoreBase=GRADLE_USER_HOME\\\\nzipStorePath=wrapper/dists\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.7-bin.zip\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew\\\", \\\"file_content\\\": \\\"[바이너리 파일: gradlew]\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n# SPDX-License-Identifier: Apache-2.0\\\\n#\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```text\\\\nAPP_HOME=$( cd \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && pwd -P ) || exit\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\nAPP_HOME=$( cd -P \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && printf '%s\\\\n' \\\\\\\"$PWD\\\\\\\" ) || exit\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew.bat\\\", \\\"file_content\\\": \\\"@rem\\\\n@rem Copyright 2015 the original author or authors.\\\\n@rem\\\\n@rem Licensed under the Apache License, Version 2.0 (the \\\\\\\"License\\\\\\\");\\\\n@rem you may not use this file except in compliance with the License.\\\\n@rem You may obtain a copy of the License at\\\\n@rem\\\\n@rem      https://www.apache.org/licenses/LICENSE-2.0\\\\n@rem\\\\n@rem Unless required by applicable law or agreed to in writing, software\\\\n@rem distributed under the License is distributed on an \\\\\\\"AS IS\\\\\\\" BASIS,\\\\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\\\n@rem See the License for the specific language governing permissions and\\\\n@rem limitations under the License.\\\\n@rem\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n\\\\n@if \\\\\\\"%DEBUG%\\\\\\\"==\\\\\\\"\\\\\\\" @echo off\\\\n@rem ##########################################################################\\\\n@rem\\\\n@rem  Gradle startup script for Windows\\\\n@rem\\\\n@rem ##########################################################################\\\\n\\\\n@rem Set local scope for the variables with windows NT shell\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" setlocal\\\\n\\\\nset DIRNAME=%~dp0\\\\nif \\\\\\\"%DIRNAME%\\\\\\\"==\\\\\\\"\\\\\\\" set DIRNAME=.\\\\n@rem This is normally unused\\\\nset APP_BASE_NAME=%~n0\\\\nset APP_HOME=%DIRNAME%\\\\n\\\\n@rem Resolve any \\\\\\\".\\\\\\\" and \\\\\\\"..\\\\\\\" in APP_HOME to make it shorter.\\\\nfor %%i in (\\\\\\\"%APP_HOME%\\\\\\\") do set APP_HOME=%%~fi\\\\n\\\\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\\\\nset DEFAULT_JVM_OPTS=\\\\\\\"-Xmx64m\\\\\\\" \\\\\\\"-Xms64m\\\\\\\"\\\\n\\\\n@rem Find java.exe\\\\nif defined JAVA_HOME goto findJavaFromJavaHome\\\\n\\\\nset JAVA_EXE=java.exe\\\\n%JAVA_EXE% -version >NUL 2>&1\\\\nif %ERRORLEVEL% equ 0 goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:findJavaFromJavaHome\\\\nset JAVA_HOME=%JAVA_HOME:\\\\\\\"=%\\\\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\\\\n\\\\nif exist \\\\\\\"%JAVA_EXE%\\\\\\\" goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:execute\\\\n@rem Setup the command line\\\\n\\\\nset CLASSPATH=%APP_HOME%\\\\\\\\gradle\\\\\\\\wrapper\\\\\\\\gradle-wrapper.jar\\\\n\\\\n\\\\n@rem Execute Gradle\\\\n\\\\\\\"%JAVA_EXE%\\\\\\\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \\\\\\\"-Dorg.gradle.appname=%APP_BASE_NAME%\\\\\\\" -classpath \\\\\\\"%CLASSPATH%\\\\\\\" org.gradle.wrapper.GradleWrapperMain %*\\\\n\\\\n:end\\\\n@rem End local scope for the variables with windows NT shell\\\\nif %ERRORLEVEL% equ 0 goto mainEnd\\\\n\\\\n:fail\\\\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\\\\nrem the _cmd.exe /c_ return code!\\\\nset EXIT_CODE=%ERRORLEVEL%\\\\nif %EXIT_CODE% equ 0 set EXIT_CODE=1\\\\nif not \\\\\\\"\\\\\\\"==\\\\\\\"%GRADLE_EXIT_CONSOLE%\\\\\\\" exit %EXIT_CODE%\\\\nexit /b %EXIT_CODE%\\\\n\\\\n:mainEnd\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" endlocal\\\\n\\\\n:omega\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 9, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\", \"description\": \"`InMemoryDatabase`의 맵 제네릭 타입을 `Any`에서 구체적인 도메인 모델(`User`, `Article`)로 변경하여 타입 안전성을 높였습니다. 이는 테스트 코드의 가독성과 안정성을 향상시키는 좋은 개선입니다.\", \"suggestion\": \"이러한 타입 구체화는 코드의 의도를 명확히 하고 잠재적인 런타임 오류를 줄이는 데 도움이 됩니다.\", \"severity\": \"info\", \"original_code\": \"val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\", \"improved_code\": \"val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\"}, {\"type\": \"스타일\", \"line_number\": 50, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\", \"description\": \"`InMemoryDatabase`의 맵 타입이 구체화됨에 따라, 불필요한 `as?` 캐스팅과 `mapNotNull` 호출이 제거되었습니다. 이는 코드의 간결성과 명확성을 높입니다.\", \"suggestion\": \"타입 안전성이 확보된 상태에서는 이러한 불필요한 변환 로직을 제거하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\", \"improved_code\": \"var filtered = InMemoryDatabase.articles.values.toList().map { it }\"}, {\"type\": \"스타일\", \"line_number\": 15, \"file\": \"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\", \"description\": \"`replaceAll` 람다에서 사용되지 않는 키 파라미터(`articleId`)를 코틀린 컨벤션에 따라 `_`로 변경하여 의도를 명확히 했습니다.\", \"suggestion\": \"사용되지 않는 파라미터에 `_`를 사용하는 것은 좋은 코틀린 스타일이며 코드 가독성을 높입니다.\", \"severity\": \"info\", \"original_code\": \"InMemoryDatabase.articles.replaceAll { articleId, article ->\", \"improved_code\": \"InMemoryDatabase.articles.replaceAll { _, article ->\"}, {\"type\": \"설정\", \"line_number\": 7, \"file\": \"gradle/wrapper/gradle-wrapper.properties\", \"description\": \"`org.gradle.java.home` 속성에 특정 개발자의 로컬 환경 경로가 하드코딩되어 있습니다. 이는 다른 환경(다른 개발자 머신, CI/CD 환경 등)에서 빌드 시 문제를 일으킬 수 있습니다.\", \"suggestion\": \"이 속성은 로컬 환경 설정이므로 커밋하지 않거나, 환경 변수 등을 사용하여 동적으로 설정되도록 변경하는 것이 좋습니다. 일반적으로 `gradle-wrapper.properties` 파일에는 환경에 독립적인 설정만 포함되어야 합니다.\", \"severity\": \"warning\", \"original_code\": null, \"improved_code\": \"org.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\"}], \"summary\": \"이 변경사항은 테스트 코드의 `InMemoryDatabase`에서 사용되는 맵의 제네릭 타입을 `Any`에서 구체적인 도메인 모델로 변경하여 타입 안전성을 크게 향상시켰습니다. 이에 따라 관련 Mock Repository 코드에서 불필요한 캐스팅 및 변환 로직이 제거되어 코드가 더 간결해졌습니다. 또한, Gradle Wrapper 버전이 업데이트되었고, `gradlew` 및 `gradlew.bat` 스크립트의 사소한 개선이 포함되었습니다. `gradle-wrapper.properties` 파일에 로컬 환경 경로가 포함된 잠재적인 설정 문제가 발견되었습니다.\", \"score\": 9.0, \"recommendations\": [\"`gradle-wrapper.properties` 파일에 커밋된 로컬 환경 경로(`org.gradle.java.home`)를 제거하거나 환경 변수 등으로 대체하여 모든 개발 환경에서 일관된 빌드를 보장하도록 수정하세요.\", \"테스트 코드 전반에 걸쳐 타입 안전성을 높이는 노력을 지속하고, 불필요한 캐스팅이나 `Any` 타입 사용을 최소화하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\nobject InMemoryDatabase {\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n\\\\n    val followings: MutableMap<UserId, MutableSet<UserId>> = mutableMapOf()\\\\n    val favorites: MutableMap<ArticleId, MutableSet<UserId>> = mutableMapOf()\\\\n\\\\n    // 테스트 실행 전후 데이터를 초기화하기 위한 메서드\\\\n    fun clear() {\\\\n        users.clear()\\\\n        articles.clear()\\\\n        followings.clear()\\\\n        favorites.clear()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.article.model.ArticleId\\\\nimport io.github.gunkim.realworld.domain.article.model.Slug\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleCountProjection\\\\nimport io.github.gunkim.realworld.domain.article.repository.ArticleRepository\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\n\\\\ndata class ArticleCountProjectionImpl(\\\\n    override val articleId: ArticleId,\\\\n    override val count: Int,\\\\n) : ArticleCountProjection\\\\n\\\\nclass MockArticleRepository : ArticleRepository {\\\\n    override fun save(article: Article): Article {\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n        val updatedArticle = if (article is Article.Companion.Model) {\\\\n            article.copy(author = updatedAuthor)\\\\n        } else {\\\\n            article\\\\n        }\\\\n        InMemoryDatabase.articles[updatedArticle.id] = updatedArticle\\\\n        return updatedArticle\\\\n    }\\\\n\\\\n    override fun delete(article: Article) {\\\\n        InMemoryDatabase.articles.remove(article.id)\\\\n        InMemoryDatabase.favorites.remove(article.id)\\\\n    }\\\\n\\\\n    override fun favorite(article: Article, user: User) {\\\\n        val favoritesSet = InMemoryDatabase.favorites.getOrPut(article.id) { mutableSetOf() }\\\\n        favoritesSet.add(user.id)\\\\n    }\\\\n\\\\n    override fun unFavorite(article: Article, user: User) {\\\\n        InMemoryDatabase.favorites[article.id]?.remove(user.id)\\\\n    }\\\\n\\\\n    override fun find(\\\\n        tag: String?,\\\\n        author: String?,\\\\n        favoritedUsername: String?,\\\\n        limit: Int,\\\\n        offset: Int,\\\\n    ): List<Article> {\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n\\\\n        if (tag != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.tags.any { it.name == tag }\\\\n            }\\\\n        }\\\\n\\\\n        if (author != null) {\\\\n            filtered = filtered.filter { article ->\\\\n                article.author.name == author\\\\n            }\\\\n        }\\\\n\\\\n        if (favoritedUsername != null) {\\\\n            val favoriter = InMemoryDatabase.users.values\\\\n                .map { it }\\\\n                .find { it.name == favoritedUsername }\\\\n            filtered = if (favoriter != null) {\\\\n                filtered.filter { article ->\\\\n                    InMemoryDatabase.favorites[article.id]?.contains(favoriter.id) ?: false\\\\n                }\\\\n            } else {\\\\n                emptyList()\\\\n            }\\\\n        }\\\\n\\\\n        return filtered.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun findFeedArticles(userId: UserId, limit: Int, offset: Int): List<Article> {\\\\n        val followedUserIds = InMemoryDatabase.followings[userId] ?: emptySet()\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n            .filter { article ->\\\\n                followedUserIds.contains(article.author.id)\\\\n            }\\\\n        return feedArticles.drop(offset).take(limit)\\\\n    }\\\\n\\\\n    override fun getCountAllByArticleIds(articleIds: List<ArticleId>): List<ArticleCountProjection> {\\\\n        return articleIds.map { articleId ->\\\\n            val count = InMemoryDatabase.favorites[articleId]?.size ?: 0\\\\n            ArticleCountProjectionImpl(articleId, count)\\\\n        }\\\\n    }\\\\n\\\\n    override fun getFavoritesArticleIds(userId: UserId): List<ArticleId> {\\\\n        return InMemoryDatabase.favorites.filter { (_, userIds) ->\\\\n            userIds.contains(userId)\\\\n        }.keys.toList()\\\\n    }\\\\n\\\\n    override fun findBySlug(slug: Slug): Article? {\\\\n        return InMemoryDatabase.articles.values\\\\n            .map { it }\\\\n            .find { it.slug == slug }\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"file_content\\\": \\\"package io.github.gunkim.realworld.share\\\\n\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\nimport io.github.gunkim.realworld.domain.user.model.UserId\\\\nimport io.github.gunkim.realworld.domain.user.repository.UserRepository\\\\n\\\\nclass MockUserRepository : UserRepository {\\\\n    override fun save(user: User): User {\\\\n        val existingUser = InMemoryDatabase.users[user.id]\\\\n        InMemoryDatabase.users[user.id] = user\\\\n\\\\n        if (existingUser != null) {\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n                if (article.author.id == user.id) {\\\\n                    if (article is Article.Companion.Model) {\\\\n                        article.copy(author = user)\\\\n                    } else {\\\\n                        article\\\\n                    }\\\\n                } else {\\\\n                    article\\\\n                }\\\\n            }\\\\n        }\\\\n        return user\\\\n    }\\\\n\\\\n    override fun follow(followerId: UserId, followeeId: UserId) {\\\\n        val followingSet = InMemoryDatabase.followings.getOrPut(followerId) { mutableSetOf() }\\\\n        followingSet.add(followeeId)\\\\n    }\\\\n\\\\n    override fun unfollow(followerId: UserId, followeeId: UserId) {\\\\n        InMemoryDatabase.followings[followerId]?.remove(followeeId)\\\\n    }\\\\n\\\\n    override fun findByEmail(email: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.email == email }\\\\n    }\\\\n\\\\n    override fun findById(userId: UserId): User? {\\\\n        return InMemoryDatabase.users[userId]\\\\n    }\\\\n\\\\n    override fun findByUserName(name: String): User? {\\\\n        return InMemoryDatabase.users.values.find { it.name == name }\\\\n    }\\\\n\\\\n    override fun findFollowedUserIdsFor(userId: UserId): List<UserId> {\\\\n        return InMemoryDatabase.followings[userId]?.toList() ?: emptyList()\\\\n    }\\\\n}\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.jar\\\", \\\"file_content\\\": \\\"[바이너리 파일: gradle/wrapper/gradle-wrapper.jar]\\\", \\\"formatted_hunks\\\": []}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"file_content\\\": \\\"distributionBase=GRADLE_USER_HOME\\\\ndistributionPath=wrapper/dists\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\nnetworkTimeout=10000\\\\nvalidateDistributionUrl=true\\\\nzipStoreBase=GRADLE_USER_HOME\\\\nzipStorePath=wrapper/dists\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.7-bin.zip\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew\\\", \\\"file_content\\\": \\\"[바이너리 파일: gradlew]\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n# SPDX-License-Identifier: Apache-2.0\\\\n#\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```text\\\\nAPP_HOME=$( cd \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && pwd -P ) || exit\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\nAPP_HOME=$( cd -P \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && printf '%s\\\\n' \\\\\\\"$PWD\\\\\\\" ) || exit\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"gradlew.bat\\\", \\\"file_content\\\": \\\"@rem\\\\n@rem Copyright 2015 the original author or authors.\\\\n@rem\\\\n@rem Licensed under the Apache License, Version 2.0 (the \\\\\\\"License\\\\\\\");\\\\n@rem you may not use this file except in compliance with the License.\\\\n@rem You may obtain a copy of the License at\\\\n@rem\\\\n@rem      https://www.apache.org/licenses/LICENSE-2.0\\\\n@rem\\\\n@rem Unless required by applicable law or agreed to in writing, software\\\\n@rem distributed under the License is distributed on an \\\\\\\"AS IS\\\\\\\" BASIS,\\\\n@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\\\n@rem See the License for the specific language governing permissions and\\\\n@rem limitations under the License.\\\\n@rem\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n\\\\n@if \\\\\\\"%DEBUG%\\\\\\\"==\\\\\\\"\\\\\\\" @echo off\\\\n@rem ##########################################################################\\\\n@rem\\\\n@rem  Gradle startup script for Windows\\\\n@rem\\\\n@rem ##########################################################################\\\\n\\\\n@rem Set local scope for the variables with windows NT shell\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" setlocal\\\\n\\\\nset DIRNAME=%~dp0\\\\nif \\\\\\\"%DIRNAME%\\\\\\\"==\\\\\\\"\\\\\\\" set DIRNAME=.\\\\n@rem This is normally unused\\\\nset APP_BASE_NAME=%~n0\\\\nset APP_HOME=%DIRNAME%\\\\n\\\\n@rem Resolve any \\\\\\\".\\\\\\\" and \\\\\\\"..\\\\\\\" in APP_HOME to make it shorter.\\\\nfor %%i in (\\\\\\\"%APP_HOME%\\\\\\\") do set APP_HOME=%%~fi\\\\n\\\\n@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\\\\nset DEFAULT_JVM_OPTS=\\\\\\\"-Xmx64m\\\\\\\" \\\\\\\"-Xms64m\\\\\\\"\\\\n\\\\n@rem Find java.exe\\\\nif defined JAVA_HOME goto findJavaFromJavaHome\\\\n\\\\nset JAVA_EXE=java.exe\\\\n%JAVA_EXE% -version >NUL 2>&1\\\\nif %ERRORLEVEL% equ 0 goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:findJavaFromJavaHome\\\\nset JAVA_HOME=%JAVA_HOME:\\\\\\\"=%\\\\nset JAVA_EXE=%JAVA_HOME%/bin/java.exe\\\\n\\\\nif exist \\\\\\\"%JAVA_EXE%\\\\\\\" goto execute\\\\n\\\\necho. 1>&2\\\\necho ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2\\\\necho. 1>&2\\\\necho Please set the JAVA_HOME variable in your environment to match the 1>&2\\\\necho location of your Java installation. 1>&2\\\\n\\\\ngoto fail\\\\n\\\\n:execute\\\\n@rem Setup the command line\\\\n\\\\nset CLASSPATH=%APP_HOME%\\\\\\\\gradle\\\\\\\\wrapper\\\\\\\\gradle-wrapper.jar\\\\n\\\\n\\\\n@rem Execute Gradle\\\\n\\\\\\\"%JAVA_EXE%\\\\\\\" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% \\\\\\\"-Dorg.gradle.appname=%APP_BASE_NAME%\\\\\\\" -classpath \\\\\\\"%CLASSPATH%\\\\\\\" org.gradle.wrapper.GradleWrapperMain %*\\\\n\\\\n:end\\\\n@rem End local scope for the variables with windows NT shell\\\\nif %ERRORLEVEL% equ 0 goto mainEnd\\\\n\\\\n:fail\\\\nrem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\\\\nrem the _cmd.exe /c_ return code!\\\\nset EXIT_CODE=%ERRORLEVEL%\\\\nif %EXIT_CODE% equ 0 set EXIT_CODE=1\\\\nif not \\\\\\\"\\\\\\\"==\\\\\\\"%GRADLE_EXIT_CONSOLE%\\\\\\\" exit %EXIT_CODE%\\\\nexit /b %EXIT_CODE%\\\\n\\\\n:mainEnd\\\\nif \\\\\\\"%OS%\\\\\\\"==\\\\\\\"Windows_NT\\\\\\\" endlocal\\\\n\\\\n:omega\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n```\\\", \\\"line_number\\\": 16}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 8, \"file\": \"gradle/wrapper/gradle-wrapper.properties\", \"description\": \"gradle-wrapper.properties 파일에 개발자 로컬 환경의 Java 경로가 포함되어 있습니다. 이는 다른 개발자의 환경에서는 유효하지 않으며, 프로젝트 설정 파일에 로컬 경로를 포함하는 것은 좋지 않은 관행입니다.\", \"suggestion\": \"해당 라인을 삭제하여 모든 개발자가 각자의 환경 설정(예: JAVA_HOME 환경 변수)을 사용하도록 하거나, 필요한 경우 로컬 `.gradle/gradle.properties` 파일에 설정하도록 안내합니다.\", \"severity\": \"warning\", \"original_code\": \"zipStorePath=wrapper/dists\", \"improved_code\": \"zipStorePath=wrapper/dists\"}], \"summary\": \"이 변경사항은 테스트 코드의 인메모리 데이터베이스에서 Any 타입을 구체적인 타입(User, Article)으로 변경하여 타입 안정성을 개선하고, 이에 따라 Mock 리포지토리 코드에서 불필요한 타입 캐스팅과 mapNotNull 호출을 제거하여 코드를 간결화했습니다. 또한, Gradle Wrapper 버전을 8.7에서 8.10으로 업데이트하고, wrapper 스크립트에 SPDX 라이선스 식별자를 추가했습니다. MockUserRepository에서는 사용되지 않는 파라미터를 `_`로 변경하고 불필요한 주석을 제거하는 등 사소한 코드 스타일 개선도 포함되었습니다. 다만, gradle-wrapper.properties 파일에 로컬 환경의 Java 경로가 포함된 점은 개선이 필요합니다.\", \"score\": 8.0, \"recommendations\": [\"gradle/wrapper/gradle-wrapper.properties 파일에서 로컬 환경의 Java 경로 설정을 제거하세요.\", \"앞으로도 타입 안전성을 높이고 불필요한 코드를 제거하는 방향으로 코드를 개선해 나가세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.article.model.Article\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\nimport io.github.gunkim.realworld.domain.user.model.User\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/InMemoryDatabase.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, Any> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Any> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n    val users: MutableMap<UserId, User> = mutableMapOf() // User 저장소\\\\n    val articles: MutableMap<ArticleId, Article> = mutableMapOf() // Article 저장소\\\\n```\\\", \\\"line_number\\\": 9, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] as? User ?: article.author\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val updatedAuthor: User = InMemoryDatabase.users[article.author.id] ?: article.author\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        var filtered = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n                .mapNotNull { it as? User }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n                .map { it }\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n        val feedArticles = InMemoryDatabase.articles.values.toList().map { it }\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"5\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockArticleRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            .mapNotNull { it as? Article }\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            .map { it }\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { articleId, article ->\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n            InMemoryDatabase.articles.replaceAll { _, article ->\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"core/src/test/kotlin/io/github/gunkim/realworld/share/MockUserRepository.kt\\\", \\\"original_code\\\": \\\"```kotlin\\\\n        // followerId가 followeeId를 팔로우하도록 followings 맵을 업데이트합니다.\\\\n```\\\", \\\"modified_code\\\": \\\"```kotlin\\\\n\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"kotlin\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"original_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.7-bin.zip\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\ndistributionUrl=https\\\\\\\\://services.gradle.org/distributions/gradle-8.10-bin.zip\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"gradle/wrapper/gradle-wrapper.properties\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\norg.gradle.java.home=/Users/yunmin-u/Library/Java/JavaVirtualMachines/corretto-21.0.6/Contents/Home\\\\n\\\\\\\\ No newline at end of file\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"gradlew\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n# SPDX-License-Identifier: Apache-2.0\\\\n#\\\\n```\\\", \\\"line_number\\\": 18, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"gradlew\\\", \\\"original_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"gradlew\\\", \\\"original_code\\\": \\\"```text\\\\nAPP_HOME=$( cd \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && pwd -P ) || exit\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\nAPP_HOME=$( cd -P \\\\\\\"${APP_HOME:-./}\\\\\\\" > /dev/null && printf '%s\\\\n' \\\\\\\"$PWD\\\\\\\" ) || exit\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"text\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"gradlew.bat\\\", \\\"original_code\\\": \\\"```text\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```text\\\\n@rem SPDX-License-Identifier: Apache-2.0\\\\n@rem\\\\n```\\\", \\\"line_number\\\": 16, \\\"language\\\": \\\"text\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line\": null, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"코드에서 `_get_language_prompt` 메서드와 해당 호출부를 제거하면서 시스템 프롬프트에 언어 정보가 더 이상 포함되지 않습니다. 이로 인해 LLM이 리뷰 대상 코드의 언어를 인식하지 못해 분석 정확도가 저하될 수 있습니다.\", \"suggestion\": \"언어 정보를 시스템 프롬프트에 다시 포함하도록 로직을 추가하세요. `_get_language_prompt` 메서드를 유지하거나, 인라인 f-string을 사용해 `generate_prompt` 내에서 직접 언어 프롬프트를 삽입합니다.\", \"severity\": \"warning\", \"original_code\": \"def _get_language_prompt(self, language: str) -> str:\\n    \\\"\\\"\\\"언어 정보 프롬프트를 반환합니다.\\n\\n    Args:\\n        language: 언어 정보\\n\\n    Returns:\\n        str: 언어 정보 프롬프트\\n    \\\"\\\"\\\"\\n    return f\\\"\\\\n\\\\n코드는 {language} 언어로 작성되었습니다.\\\"  \\n\\n# generate_prompt 내 호출부\\nif review_request.language:\\n    system_prompt += self._get_language_prompt(review_request.language)\", \"improved_code\": \"# generate_prompt 내 인라인 적용 예시\\nif review_request.language:\\n    system_prompt += f\\\"\\\\n\\\\n코드는 {review_request.language} 언어로 작성되었습니다.\\\"  \"}, {\"type\": \"스타일\", \"line\": null, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"`if review_request.file_paths and len(review_request.file_paths) > 0` 조건이 중복됩니다. 빈 리스트를 검사하는 것만으로 충분하므로 가독성이 떨어집니다.\", \"suggestion\": \"단순히 `if review_request.file_paths:` 형태로 변경해 코드 가독성을 높이세요.\", \"severity\": \"info\", \"original_code\": \"if review_request.file_paths and len(review_request.file_paths) > 0:\\n    system_prompt += self._get_file_paths_prompt(review_request.file_paths)\", \"improved_code\": \"if review_request.file_paths:\\n    system_prompt += self._get_file_paths_prompt(review_request.file_paths)  \"}, {\"type\": \"스타일\", \"line\": null, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"hunk 메타데이터에 추가된 `language` 필드를 문자열로 캐스팅하지 않아, None 또는 숫자가 들어올 경우 타입 불일치가 발생할 수 있습니다.\", \"suggestion\": \"`language` 값을 `str()` 로 감싸 명시적 캐스팅을 수행해 타입 일관성을 확보하세요.\", \"severity\": \"warning\", \"original_code\": \"\\\"language\\\": hunk.get(\\\"language\\\", \\\"\\\"),\", \"improved_code\": \"\\\"language\\\": str(hunk.get(\\\"language\\\", \\\"\\\")),\"}], \"summary\": \"`prompt_generator.py`에서 언어 정보 관련 메서드와 호출부를 제거하고 파일 경로 처리와 hunk 메타데이터에 `language` 필드를 추가했습니다. 그러나 언어 프롬프트 누락, 불필요한 조건 중복, 데이터 타입 일관성 문제 등이 발견되었습니다.\", \"score\": 7.0, \"recommendations\": [\"시스템 프롬프트에 언어 정보 포함 로직을 재도입하세요.\", \"조건문 간소화로 가독성을 개선하세요.\", \"메타데이터 필드 값을 명시적으로 캐스팅해 타입 안정성을 확보하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\\\", \\\"file_content\\\": \\\"package com.hoangtien2k3.userservice.service.impl;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.entity.UserRole;\\\\nimport com.hoangtien2k3.userservice.repository.UserRepository;\\\\nimport com.hoangtien2k3.userservice.repository.UserRoleRepository;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.stereotype.Service;\\\\n\\\\nimport java.util.List;\\\\n\\\\n@Service\\\\npublic class UserServiceImpl implements UserService {\\\\n\\\\n    @Autowired\\\\n    private UserRepository userRepository;\\\\n\\\\n    @Autowired\\\\n    private UserRoleRepository userRoleRepository;\\\\n\\\\n    @Override\\\\n    public List<User> getAllUser() {\\\\n        return userRepository.findAll();\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserById(Long id) {\\\\n\\\\n        return userRepository.getReferenceById(id);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserByName(String userName) {\\\\n        return userRepository.findByUserName(userName);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User saveUser(User user) {\\\\n\\\\n        user.setActive(1); // active success\\\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\\\\\"ROLE_USER\\\\\\\");\\\\n        user.setRole(role);\\\\n\\\\n        return userRepository.save(user);\\\\n    }\\\\n}\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```java\\\\n        return userRepository.getOne(id);\\\\n```\\\", \\\"modified_code\\\": \\\"```java\\\\n        return userRepository.getReferenceById(id);\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 30, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"`userRepository.getOne(id)` 메서드는 Spring Data JPA 2.2에서 deprecated 되었으며, `getReferenceById(id)`로 대체되었습니다. 이 변경은 최신 API를 사용하는 좋은 개선입니다. `getReferenceById`는 엔티티가 실제로 사용될 때까지 데이터베이스 조회를 지연시키는 프록시 객체를 반환합니다. 만약 해당 ID의 엔티티가 존재하지 않으면, 프록시 객체의 속성에 접근할 때 `EntityNotFoundException`이 발생합니다.\", \"suggestion\": \"변경된 `getReferenceById` 사용을 유지합니다. 이 메서드의 동작 방식(lazy loading 및 존재하지 않는 ID에 대한 `EntityNotFoundException`)을 이해하고, 필요한 경우 호출하는 쪽에서 예외 처리를 고려해야 합니다.\", \"severity\": \"info\", \"original_code\": \"```java\\n        return userRepository.getOne(id);\\n```\", \"improved_code\": \"```java\\n        return userRepository.getReferenceById(id);\\n```\"}, {\"type\": \"bug\", \"line_number\": 43, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"`userRoleRepository.findUserRoleByRoleName(\\\"ROLE_USER\\\")` 호출 결과가 `null`일 경우, `user.setRole(role)`에서 `NullPointerException`이 발생할 수 있습니다. 이는 \\\"ROLE_USER\\\" 역할이 데이터베이스에 존재하지 않는 경우 발생합니다.\", \"suggestion\": \"역할이 존재하지 않는 경우에 대한 예외 처리를 추가해야 합니다. 예를 들어, 역할이 `null`이면 기본 역할을 할당하거나, 예외를 발생시켜 클라이언트에게 알릴 수 있습니다.\", \"severity\": \"error\", \"original_code\": \"```java\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\"ROLE_USER\\\");\\n        user.setRole(role);\\n```\", \"improved_code\": \"```java\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\"ROLE_USER\\\");\\n        if (role == null) {\\n            // 예: 역할이 없을 경우 예외 발생\\n            throw new IllegalArgumentException(\\\"Role 'ROLE_USER' not found\\\");\\n            // 또는 기본 역할 할당 또는 로깅 등\\n        } else {\\n            user.setRole(role);\\n        }\\n```\"}, {\"type\": \"style\", \"line_number\": 16, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"필드 주입(`@Autowired` on fields)은 테스트 용이성 및 의존성 관리 측면에서 생성자 주입보다 선호되지 않습니다. 순환 의존성을 숨길 수도 있습니다.\", \"suggestion\": \"생성자 주입을 사용하여 의존성을 명시적으로 관리하는 것이 좋습니다.\", \"severity\": \"warning\", \"original_code\": \"```java\\n    @Autowired\\n    private UserRepository userRepository;\\n\\n    @Autowired\\n    private UserRoleRepository userRoleRepository;\\n```\", \"improved_code\": \"```java\\n    private final UserRepository userRepository;\\n    private final UserRoleRepository userRoleRepository;\\n\\n    // @Autowired는 Spring 4.3+에서 생성자가 하나일 경우 생략 가능\\n    public UserServiceImpl(UserRepository userRepository, UserRoleRepository userRoleRepository) {\\n        this.userRepository = userRepository;\\n        this.userRoleRepository = userRoleRepository;\\n    }\\n```\"}], \"summary\": \"제공된 diff는 deprecated된 `getOne` 메서드를 최신 `getReferenceById`로 변경하는 좋은 개선을 포함하고 있습니다. 코드 전반적으로는 필드 주입 대신 생성자 주입을 사용하는 것이 권장되며, 사용자 저장 시 \\\"ROLE_USER\\\" 역할이 존재하지 않을 경우 `NullPointerException`이 발생할 수 있는 잠재적인 버그가 있습니다. 이 부분에 대한 예외 처리가 필요합니다.\", \"score\": 7.5, \"recommendations\": [\"필드 주입 대신 생성자 주입을 사용하여 의존성을 관리하세요.\", \"사용자 저장 시 \\\"ROLE_USER\\\" 역할이 존재하지 않는 경우에 대한 예외 처리를 추가하세요.\", \"상태 값(예: active=1)에 매직 넘버 대신 상수를 사용하는 것을 고려하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n        repo_path=repo_path,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.prompt_generator import (\\\\n    PromptGenerator,\\\\n    find_project_root,\\\\n)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        repo_path=repo_path,\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/diff_parser/parser.py\\\", \\\"file_content\\\": \\\"import re\\\\n\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.utils.prompts import load_file_content\\\\n\\\\nfrom .models import DiffResult, FileDiff, Hunk\\\\n\\\\n_PATTERN_DIFF_SPLIT = re.compile(r\\\\\\\"(?=^diff --git)\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_HUNK_SPLIT = re.compile(r\\\\\\\"(?=^@@ )\\\\\\\", flags=re.MULTILINE)\\\\n_PATTERN_FILE_HEADER = re.compile(r\\\\\\\"^diff --git a/(\\\\\\\\S+) b/(\\\\\\\\S+)\\\\\\\", flags=re.MULTILINE)\\\\n\\\\n\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 텍스트를 파싱하여 구조화된 DiffResult 객체를 반환합니다.\\\\n\\\\n    Args:\\\\n        diff_text (str): git diff 명령어의 출력 텍스트\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n\\\\n    Returns:\\\\n        DiffResult: Git diff 결과를 나타내는 객체\\\\n\\\\n    Raises:\\\\n        DiffParsingError: diff가 비어있거나 유효하지 않은 형식인 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not diff_text:\\\\n        raise DiffParsingError(\\\\\\\"빈 diff가 제공되었습니다.\\\\\\\")\\\\n\\\\n    file_diffs = _PATTERN_DIFF_SPLIT.split(diff_text)\\\\n    result = DiffResult()\\\\n\\\\n    for raw_diff in file_diffs:\\\\n        if not raw_diff.strip():\\\\n            continue\\\\n        header_match = _PATTERN_FILE_HEADER.search(raw_diff)\\\\n        if header_match:\\\\n            filename = header_match.group(2)\\\\n        else:\\\\n            continue\\\\n\\\\n        hunks = _PATTERN_HUNK_SPLIT.split(raw_diff)\\\\n        hunk_list = [\\\\n            Hunk.from_hunk_text(h) for h in hunks if h.lstrip().startswith(\\\\\\\"@@\\\\\\\")\\\\n        ]\\\\n\\\\n        if use_full_context:\\\\n            file_content = load_file_content(filename, repo_path)\\\\n        else:\\\\n            file_content = None\\\\n\\\\n        parsed_diff = FileDiff(\\\\n            filename=filename, file_content=file_content, hunks=hunk_list\\\\n        )\\\\n        parsed_diff.detect_language()\\\\n        parsed_diff.calculate_changes()\\\\n        result.files.append(parsed_diff)\\\\n\\\\n    if not result.files:\\\\n        raise DiffParsingError(\\\\\\\"유효하지 않은 diff 형식입니다.\\\\\\\")\\\\n\\\\n    return result\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\ndef parse_git_diff(diff_text: str, use_full_context: bool) -> DiffResult:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef parse_git_diff(\\\\n    diff_text: str, use_full_context: bool, repo_path: str\\\\n) -> DiffResult:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        use_full_context (bool): 전체 파일 컨텍스트를 사용할지 여부\\\\n        repo_path (str): Git 저장소 경로\\\\n```\\\", \\\"line_number\\\": 20}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            file_content = load_file_content(filename, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(repo_path, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef load_file_content(filename: str, repo_path: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 지정된 저장소 경로를 기준으로 파일을 찾습니다.\\\\n\\\\n    Args:\\\\n        filename (str): 읽을 파일 경로\\\\n        repo_path (str): 저장소 경로\\\\n\\\\n    Returns:\\\\n        str: 파일 내용\\\\n```\\\", \\\"line_number\\\": 49}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    Raises:\\\\n        FileNotFoundError: 파일을 찾을 수 없는 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n```\\\", \\\"line_number\\\": 59}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        file_path = os.path.join(project_root, filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        file_path = os.path.join(repo_path, filename)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n        # 저장소 경로는 리뷰 요청에서 가져옵니다.\\\\n        repo_path = review_request.repo_path\\\\n\\\\n```\\\", \\\"line_number\\\": 173}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n                file_content = load_file_content(request.filename)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                file_content = load_file_content(request.filename, repo_path)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n    repo_path: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    repo_path: str\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 68, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"load_file_content 함수에서 너무 일반적인 Exception을 잡고 다시 발생시키고 있습니다. 특정 예외(예: FileNotFoundError, IOError)를 명시적으로 처리하는 것이 좋습니다.\", \"suggestion\": \"보다 구체적인 예외를 잡거나, 최소한 `except Exception:` 대신 `except OSError as e:` 또는 `except (FileNotFoundError, IOError) as e:` 와 같이 파일 관련 예외를 명시하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    except Exception as e:\\n        raise e\\n```\", \"improved_code\": \"```python\\n    except FileNotFoundError as e:\\n        raise FileNotFoundError(f\\\"파일을 찾을 수 없습니다: {file_path}\\\") from e\\n    except IOError as e:\\n        raise IOError(f\\\"파일 읽기 중 오류 발생: {file_path}\\\") from e\\n    except Exception as e:\\n        # 예상치 못한 다른 오류 처리\\n        raise RuntimeError(f\\\"파일 처리 중 예상치 못한 오류 발생: {file_path}\\\") from e\\n```\"}, {\"type\": \"design\", \"line_number\": 20, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"find_project_root 함수는 이제 cli.py에서 주로 사용되어 repo_path를 결정하는 데 기여합니다. 프롬프트 생성기보다는 더 일반적인 유틸리티 모듈(예: reviewer.src.utils)로 이동하는 것을 고려해볼 수 있습니다.\", \"suggestion\": \"find_project_root 함수를 reviewer.src.utils와 같은 더 범용적인 유틸리티 모듈로 이동시켜 코드 구조를 개선할 수 있습니다. 현재 위치도 기능적으로 문제는 없습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n@lru_cache(maxsize=1)\\ndef find_project_root() -> Path:\\n    \\\"\\\"\\\"프로젝트 루트 디렉토리를 찾습니다.\\n\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\n    상위 디렉토리를 찾습니다.\\n\\n    Returns:\\n        Path: 프로젝트 루트 경로\\n    \\\"\\\"\\\"\\n    current_dir = Path(__file__).resolve().parent\\n\\n    # 프로젝트 루트 식별자 파일 목록\\n    root_identifiers = [\\n        \\\".git\\\",\\n        \\\"pyproject.toml\\\",\\n        \\\"setup.py\\\",\\n        \\\"setup.cfg\\\",\\n        \\\"requirements.txt\\\",\\n    ]\\n\\n    while True:\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\n            return current_dir\\n        if current_dir.parent == current_dir:\\n            break\\n        current_dir = current_dir.parent\\n    raise FileNotFoundError(f\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\")\\n```\", \"improved_code\": \"```python\\n# 이 함수를 reviewer/src/utils/path_utils.py 등으로 이동시키는 것을 고려합니다.\\n# (실제 코드 변경은 이동된 파일에서 이루어집니다)\\n# 예시: reviewer/src/utils/path_utils.py\\n\\n# from functools import lru_cache\\n# from pathlib import Path\\n\\n# @lru_cache(maxsize=1)\\n# def find_project_root() -> Path:\\n#     ...\\n```\"}], \"summary\": \"이 변경사항은 코드 리뷰 도구에서 Git 저장소 경로를 처리하는 방식을 개선합니다. 특히 `--repo-path .` 옵션 사용 시 프로젝트 루트를 정확히 찾고, 전체 파일 컨텍스트를 로드할 때 올바른 경로를 사용하도록 `parse_git_diff` 및 `load_file_content` 함수에 `repo_path` 인자를 추가하고, 이를 `ReviewRequest` 모델에 포함시켰습니다. 전반적으로 경로 처리의 견고성이 향상되었습니다.\", \"score\": 9.0, \"recommendations\": [\"load_file_content 함수에서 예외 처리를 좀 더 구체적으로 개선합니다.\", \"find_project_root와 같은 범용 유틸리티 함수를 적절한 유틸리티 모듈로 이동시켜 코드 구조를 명확히 합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\\\", \\\"file_content\\\": \\\"package com.hoangtien2k3.userservice.service.impl;\\\\n\\\\nimport com.hoangtien2k3.userservice.entity.User;\\\\nimport com.hoangtien2k3.userservice.entity.UserRole;\\\\nimport com.hoangtien2k3.userservice.repository.UserRepository;\\\\nimport com.hoangtien2k3.userservice.repository.UserRoleRepository;\\\\nimport com.hoangtien2k3.userservice.service.UserService;\\\\nimport org.springframework.beans.factory.annotation.Autowired;\\\\nimport org.springframework.stereotype.Service;\\\\n\\\\nimport java.util.List;\\\\n\\\\n@Service\\\\npublic class UserServiceImpl implements UserService {\\\\n\\\\n    @Autowired\\\\n    private UserRepository userRepository;\\\\n\\\\n    @Autowired\\\\n    private UserRoleRepository userRoleRepository;\\\\n\\\\n    @Override\\\\n    public List<User> getAllUser() {\\\\n        return userRepository.findAll();\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserById(Long id) {\\\\n\\\\n        return userRepository.getReferenceById(id);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User getUserByName(String userName) {\\\\n        return userRepository.findByUserName(userName);\\\\n    }\\\\n\\\\n    @Override\\\\n    public User saveUser(User user) {\\\\n\\\\n        user.setActive(1); // active success\\\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\\\\\"ROLE_USER\\\\\\\");\\\\n        user.setRole(role);\\\\n\\\\n        return userRepository.save(user);\\\\n    }\\\\n}\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```java\\\\n        return userRepository.getOne(id);\\\\n```\\\", \\\"modified_code\\\": \\\"```java\\\\n        return userRepository.getReferenceById(id);\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 30, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"`userRepository.getOne(id)` 메서드는 Spring Data JPA 2.2에서 deprecated 되었으며, `getReferenceById(id)`로 대체되었습니다. 이 변경은 최신 API를 사용하는 좋은 개선입니다. `getReferenceById`는 엔티티가 실제로 사용될 때까지 데이터베이스 조회를 지연시키는 프록시 객체를 반환합니다. 만약 해당 ID의 엔티티가 존재하지 않으면, 프록시 객체의 속성에 접근할 때 `EntityNotFoundException`이 발생합니다.\", \"suggestion\": \"변경된 `getReferenceById` 사용을 유지합니다. 이 메서드의 동작 방식(lazy loading 및 존재하지 않는 ID에 대한 `EntityNotFoundException`)을 이해하고, 필요한 경우 호출하는 쪽에서 예외 처리를 고려해야 합니다.\", \"severity\": \"info\", \"original_code\": \"```java\\n        return userRepository.getOne(id);\\n```\", \"improved_code\": \"```java\\n        return userRepository.getReferenceById(id);\\n```\"}, {\"type\": \"bug\", \"line_number\": 43, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"`userRoleRepository.findUserRoleByRoleName(\\\"ROLE_USER\\\")` 호출 결과가 `null`일 경우, `user.setRole(role)`에서 `NullPointerException`이 발생할 수 있습니다. 이는 \\\"ROLE_USER\\\" 역할이 데이터베이스에 존재하지 않는 경우 발생합니다.\", \"suggestion\": \"역할이 존재하지 않는 경우에 대한 예외 처리를 추가해야 합니다. 예를 들어, 역할이 `null`이면 기본 역할을 할당하거나, 예외를 발생시켜 클라이언트에게 알릴 수 있습니다.\", \"severity\": \"error\", \"original_code\": \"```java\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\"ROLE_USER\\\");\\n        user.setRole(role);\\n```\", \"improved_code\": \"```java\\n        UserRole role = userRoleRepository.findUserRoleByRoleName(\\\"ROLE_USER\\\");\\n        if (role == null) {\\n            // 예: 역할이 없을 경우 예외 발생\\n            throw new IllegalArgumentException(\\\"Role 'ROLE_USER' not found\\\");\\n            // 또는 기본 역할 할당 또는 로깅 등\\n        } else {\\n            user.setRole(role);\\n        }\\n```\"}, {\"type\": \"style\", \"line_number\": 16, \"file\": \"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\", \"description\": \"필드 주입(`@Autowired` on fields)은 테스트 용이성 및 의존성 관리 측면에서 생성자 주입보다 선호되지 않습니다. 순환 의존성을 숨길 수도 있습니다.\", \"suggestion\": \"생성자 주입을 사용하여 의존성을 명시적으로 관리하는 것이 좋습니다.\", \"severity\": \"warning\", \"original_code\": \"```java\\n    @Autowired\\n    private UserRepository userRepository;\\n\\n    @Autowired\\n    private UserRoleRepository userRoleRepository;\\n```\", \"improved_code\": \"```java\\n    private final UserRepository userRepository;\\n    private final UserRoleRepository userRoleRepository;\\n\\n    // @Autowired는 Spring 4.3+에서 생성자가 하나일 경우 생략 가능\\n    public UserServiceImpl(UserRepository userRepository, UserRoleRepository userRoleRepository) {\\n        this.userRepository = userRepository;\\n        this.userRoleRepository = userRoleRepository;\\n    }\\n```\"}], \"summary\": \"제공된 diff는 deprecated된 `getOne` 메서드를 최신 `getReferenceById`로 변경하는 좋은 개선을 포함하고 있습니다. 코드 전반적으로는 필드 주입 대신 생성자 주입을 사용하는 것이 권장되며, 사용자 저장 시 \\\"ROLE_USER\\\" 역할이 존재하지 않을 경우 `NullPointerException`이 발생할 수 있는 잠재적인 버그가 있습니다. 이 부분에 대한 예외 처리가 필요합니다.\", \"score\": 7.5, \"recommendations\": [\"필드 주입 대신 생성자 주입을 사용하여 의존성을 관리하세요.\", \"사용자 저장 시 \\\"ROLE_USER\\\" 역할이 존재하지 않는 경우에 대한 예외 처리를 추가하세요.\", \"상태 값(예: active=1)에 매직 넘버 대신 상수를 사용하는 것을 고려하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"user-service/src/main/java/com/hoangtien2k3/userservice/service/impl/UserServiceImpl.java\\\", \\\"file_content\\\": \\\"\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```java\\\\n        return userRepository.getOne(id);\\\\n```\\\", \\\"modified_code\\\": \\\"```java\\\\n        return userRepository.getReferenceById(id);\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": null, \"file\": \"reviewer/cli.py\", \"description\": \"handle_results_command 함수에서 get_default_results_dir()가 문자열을 반환한 후 .exists()를 호출하여 AttributeError가 발생할 수 있습니다.\", \"suggestion\": \"get_default_results_dir()의 반환값을 pathlib.Path로 감싸서 사용합니다.\", \"severity\": \"error\", \"original_code\": \"results_dir = get_default_results_dir()\\nif not results_dir.exists():\\n    print(f\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\")\\n    return\", \"improved_code\": \"from pathlib import Path\\n\\nresults_dir = Path(get_default_results_dir())\\nif not results_dir.exists():\\n    print(f\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\")\\n    return\"}, {\"type\": \"design\", \"line_number\": null, \"file\": \"reviewer/src/diff_parser/parser.py\", \"description\": \"parse_git_diff에서 load_file_content를 통해 파일을 로드할 때 현재 작업 디렉터리 기준으로만 동작하여 --repo-path 옵션을 반영하지 못합니다.\", \"suggestion\": \"parse_git_diff에 repo_path 인자를 추가하고, load_file_content 호출 시 Path(repo_path)/filename을 사용하여 올바른 경로에서 파일을 읽어오도록 수정하세요.\", \"severity\": \"warning\", \"original_code\": \"if use_full_context:\\n    file_content = load_file_content(filename)\\nelse:\\n    file_content = None\", \"improved_code\": \"if use_full_context:\\n    full_path = Path(repo_path) / filename  # repo_path 전달 필요\\n    file_content = load_file_content(str(full_path))\\nelse:\\n    file_content = None\"}, {\"type\": \"design\", \"line_number\": 66, \"file\": \"reviewer/cli.py\", \"description\": \"--commit-range와 --diff-file 인수가 상호 배타적으로 동작하지 않아 사용자가 두 옵션을 동시에 지정할 수 있습니다.\", \"suggestion\": \"argparse의 add_mutually_exclusive_group()를 사용하여 두 인수를 그룹으로 묶고, 둘 중 하나만 허용하도록 설정하세요.\", \"severity\": \"info\", \"original_code\": \"review_parser.add_argument(\\n    \\\"--commit-range\\\", type=str, help=\\\"비교할 커밋 범위\\\"\\n)\\nreview_parser.add_argument(\\n    \\\"--diff-file\\\", type=str, help=\\\"Git diff 파일 경로\\\"\\n)\", \"improved_code\": \"group = review_parser.add_mutually_exclusive_group()\\ngroup.add_argument(\\n    \\\"--commit-range\\\", type=str, help=\\\"비교할 커밋 범위\\\"\\n)\\ngroup.add_argument(\\n    \\\"--diff-file\\\", type=str, help=\\\"Git diff 파일 경로\\\"\\n)\"}, {\"type\": \"security\", \"line_number\": null, \"file\": \"reviewer/cli.py\", \"description\": \"save_review_request에서 파일명에 review_request.model 값을 그대로 사용하여 파일명에 허용되지 않는 문자가 포함될 수 있습니다.\", \"suggestion\": \"파일명에 사용되는 모델 이름을 re.sub 등을 이용해 알파벳·숫자·언더스코어만 허용하도록 정규화 후 사용하세요.\", \"severity\": \"warning\", \"original_code\": \"filename = f\\\"review_request_{timestamp}_{review_request.model}.json\\\"\", \"improved_code\": \"import re\\nsafe_model = re.sub(r\\\"[^A-Za-z0-9_]\\\", \\\"\\\", review_request.model)\\nfilename = f\\\"review_request_{timestamp}_{safe_model}.json\\\"\"}], \"summary\": \"이번 변경에서는 --diff-only 옵션 추가로 full-context 모드를 제어하고, diff 파서 및 CLI의 save_review_request 함수 시그니처 변경, LLM 게이트웨이에서 review_prompt 변수 일관화 등이 적용되었습니다. 전반적으로 기능 확장은 되었으나, 경로 처리, 인수 검증, 파일명 안전성 등에서 보완이 필요합니다.\", \"score\": 7.0, \"recommendations\": [\"get_default_results_dir 반환값은 pathlib.Path로 변환하여 일관된 경로 처리를 적용하세요.\", \"parse_git_diff에 repo_path를 전달하여 파일 로드 시 올바른 경로를 사용하도록 개선하세요.\", \"argparse 상호 배타적 인수 그룹(mutually exclusive group)을 활용하여 사용자 입력 오류를 방지하세요.\", \"파일 생성 시 사용자 입력값을 파일명에 직접 사용하지 않도록, 반드시 안전한 문자열로 정규화하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"html\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: html)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"html\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: html)\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 47}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/review_processor.py\\\", \\\"file_content\\\": \\\"import html\\\\nimport json\\\\nfrom typing import Any, Dict, List\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewIssue, ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_json(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 JSON 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: JSON 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return json.dumps(review.model_dump(), indent=2, ensure_ascii=False)\\\\n\\\\n\\\\nclass ReviewAnalyzer:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 분석하는 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def get_severity_counts(review: ReviewResponse) -> Dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"심각도별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, int]: 심각도별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {\\\\\\\"info\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 0, \\\\\\\"error\\\\\\\": 0}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.severity] = counts.get(issue.severity, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_type_counts(review: ReviewResponse) -> Dict[str, int]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"유형별 이슈 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, int]: 유형별 이슈 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        counts = {}\\\\n\\\\n        for issue in review.issues:\\\\n            counts[issue.type] = counts.get(issue.type, 0) + 1\\\\n\\\\n        return counts\\\\n\\\\n    @staticmethod\\\\n    def get_file_issues(review: ReviewResponse) -> Dict[str, List[ReviewIssue]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"파일별 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, List[ReviewIssue]]: 파일별 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        file_issues = {}\\\\n\\\\n        for issue in review.issues:\\\\n            if issue.file:\\\\n                if issue.file not in file_issues:\\\\n                    file_issues[issue.file] = []\\\\n                file_issues[issue.file].append(issue)\\\\n\\\\n        return file_issues\\\\n\\\\n    @staticmethod\\\\n    def get_most_critical_issues(\\\\n        review: ReviewResponse, limit: int = 3\\\\n    ) -> List[ReviewIssue]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"가장 중요한 이슈 목록을 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            limit: 반환할 이슈 수\\\\n\\\\n        Returns:\\\\n            List[ReviewIssue]: 중요한 이슈 목록\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 심각도 순으로 정렬 (error > warning > info)\\\\n        severity_order = {\\\\\\\"error\\\\\\\": 0, \\\\\\\"warning\\\\\\\": 1, \\\\\\\"info\\\\\\\": 2}\\\\n        sorted_issues = sorted(\\\\n            review.issues, key=lambda x: severity_order.get(x.severity, 3)\\\\n        )\\\\n\\\\n        return sorted_issues[:limit]\\\\n\\\\n\\\\nclass ReviewPostProcessor:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 후처리기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self):\\\\n        self.formatter = ReviewFormatter()\\\\n        self.analyzer = ReviewAnalyzer()\\\\n\\\\n    def process_review(\\\\n        self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\"\\\\n    ) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 처리하고 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html, json)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.formatter.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.formatter.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    def get_review_summary(self, review: ReviewResponse) -> Dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 요약 정보를 반환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            Dict[str, Any]: 리뷰 요약 정보\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        severity_counts = self.analyzer.get_severity_counts(review)\\\\n        type_counts = self.analyzer.get_type_counts(review)\\\\n        most_critical = self.analyzer.get_most_critical_issues(review)\\\\n\\\\n        return {\\\\n            \\\\\\\"summary\\\\\\\": review.summary,\\\\n            \\\\\\\"score\\\\\\\": review.score,\\\\n            \\\\\\\"total_issues\\\\\\\": len(review.issues),\\\\n            \\\\\\\"severity_counts\\\\\\\": severity_counts,\\\\n            \\\\\\\"type_counts\\\\\\\": type_counts,\\\\n            \\\\\\\"most_critical_issues\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"type\\\\\\\": issue.type,\\\\n                    \\\\\\\"severity\\\\\\\": issue.severity,\\\\n                    \\\\\\\"description\\\\\\\": issue.description,\\\\n                }\\\\n                for issue in most_critical\\\\n            ],\\\\n            \\\\\\\"recommendations\\\\\\\": review.recommendations,\\\\n        }\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        elif output_format == \\\\\\\"json\\\\\\\":\\\\n            return self.formatter.to_json(review)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 285}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 `--review-focus` 명령줄 인자와 관련된 기능을 제거합니다. `cli.py`에서 해당 인자 정의가 삭제되었고, `models.py`의 `ReviewRequest` 모델에서 `review_focus` 필드가 제거되었습니다. 또한, `prompt_generator.py`에서 `review_focus`를 시스템 프롬프트에 추가하는 관련 로직과 헬퍼 메소드가 삭제되었습니다. 이는 특정 리뷰 포커스를 지정하여 코드 리뷰를 수행하는 기능이 제거되었음을 의미합니다.\", \"score\": 9.5, \"recommendations\": [\"이 기능 제거가 의도된 변경이라면, 사용자 문서에 해당 내용이 반영되었는지 확인하세요.\", \"향후 특정 리뷰 포커스 기능이 다시 필요할 경우, 더 유연하거나 확장 가능한 방식으로 구현하는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 `--review-focus` 명령줄 인자와 관련된 기능을 제거합니다. `cli.py`에서 해당 인자 정의가 삭제되었고, `models.py`의 `ReviewRequest` 모델에서 `review_focus` 필드가 제거되었습니다. 또한, `prompt_generator.py`에서 `review_focus`를 시스템 프롬프트에 추가하는 관련 로직과 헬퍼 메소드가 삭제되었습니다. 이는 특정 리뷰 포커스를 지정하여 코드 리뷰를 수행하는 기능이 제거되었음을 의미합니다.\", \"score\": 9.5, \"recommendations\": [\"이 기능 제거가 의도된 변경이라면, 사용자 문서에 해당 내용이 반영되었는지 확인하세요.\", \"향후 특정 리뷰 포커스 기능이 다시 필요할 경우, 더 유연하거나 확장 가능한 방식으로 구현하는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 `--review-focus` 명령줄 인자와 관련된 기능을 제거합니다. `cli.py`에서 해당 인자 정의가 삭제되었고, `models.py`의 `ReviewRequest` 모델에서 `review_focus` 필드가 제거되었습니다. 또한, `prompt_generator.py`에서 `review_focus`를 시스템 프롬프트에 추가하는 관련 로직과 헬퍼 메소드가 삭제되었습니다. 이는 특정 리뷰 포커스를 지정하여 코드 리뷰를 수행하는 기능이 제거되었음을 의미합니다.\", \"score\": 9.5, \"recommendations\": [\"이 기능 제거가 의도된 변경이라면, 사용자 문서에 해당 내용이 반영되었는지 확인하세요.\", \"향후 특정 리뷰 포커스 기능이 다시 필요할 경우, 더 유연하거나 확장 가능한 방식으로 구현하는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 50, \"file\": \"reviewer/cli.py\", \"description\": \"'--review-focus' CLI 인자 및 관련 기능이 제거되었습니다. 이로 인해 사용자는 LLM 리뷰 시 특정 검토 영역(예: 보안, 성능)을 지정할 수 없게 됩니다. 이 변경은 도구의 복잡성을 줄이는 이점이 있을 수 있으나, 세밀한 리뷰 제어를 원했던 사용자에게는 기능 축소로 인식될 수 있습니다.\", \"suggestion\": \"기능 제거 결정이 확정된 경우, 해당 변경 사항을 사용자 문서 및 릴리스 노트에 명확히 고지하고, 제거 이유 또는 프롬프트 수정을 통해 유사한 효과를 얻는 방법 등 대안을 안내하는 것을 권장합니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    review_parser.add_argument(\\n        \\\"--review-focus\\\", type=str, help=\\\"리뷰 집중 영역 (예: '보안', '성능')\\\"\\n    )\\n```\", \"improved_code\": null}, {\"type\": \"스타일\", \"line_number\": 409, \"file\": \"reviewer/cli.py\", \"description\": \"`review_code` 함수 내 API 키 설정 로직(409행 부근)이 여러 단계의 `if/else` 및 `try/except` 블록으로 중첩되어 있어 가독성이 저하될 수 있습니다. 특히 API 키가 없을 경우 사용자에게 설정 여부를 묻고 입력받는 과정이 복잡하게 느껴집니다.\", \"suggestion\": \"API 키를 확인하고, 없는 경우 사용자에게 입력을 요청하여 설정하는 과정을 별도의 헬퍼 함수(예: `_ensure_api_key_configured`)로 추출하는 것을 고려해 보십시오. 이를 통해 `review_code` 함수의 주 로직을 더 명확하게 만들고 중첩을 줄일 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    # API 키 확인\\n    api_key = get_api_key(\\\"openai\\\")  # 기본적으로 OpenAI 모델 사용\\n    if not api_key:\\n        logger.warning(\\\"API 키가 설정되지 않았습니다.\\\")\\n        logger.info(\\\"다음 명령어로 API 키를 설정하세요:\\\")\\n        logger.info(\\\"  reviewer config api-key openai\\\")\\n\\n        # 대화형으로 키 설정 제안\\n        try:\\n            response = input(\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\")\\n            if response.lower() == \\\"y\\\":\\n                try:\\n                    new_api_key = getpass.getpass(\\n                        \\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\"\\n                    )\\n                    if new_api_key:\\n                        if set_api_key(new_api_key, \\\"openai\\\"):\\n                            logger.info(\\\"API 키가 성공적으로 저장되었습니다.\\\")\\n                            api_key = new_api_key\\n                        else:\\n                            logger.error(\\\"API 키 저장에 실패했습니다.\\\")\\n                            return\\n                    else:\\n                        logger.warning(\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\")\\n                        return\\n                except KeyboardInterrupt:\\n                    logger.info(\\\"\\\\n설정이 취소되었습니다.\\\")\\n                    return\\n            else:\\n                return\\n        except KeyboardInterrupt:\\n            logger.info(\\\"\\\\n실행이 취소되었습니다.\\\")\\n            return\\n```\", \"improved_code\": \"```python\\n    # # 예시: 헬퍼 함수 사용\\n    # def _ensure_api_key_configured(provider: str) -> Optional[str]:\\n    #     api_key = get_api_key(provider)\\n    #     if api_key:\\n    #         return api_key\\n    # \\n    #     logger.warning(f\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\")\\n    #     # ... (사용자에게 설정 여부 확인 및 입력 요청 로직) ...\\n    #     # 성공 시 키 반환, 실패 또는 취소 시 None 반환\\n    #     return new_key_or_none\\n    # \\n    # # review_code 함수 내에서 호출\\n    # api_key = _ensure_api_key_configured(\\\"openai\\\")\\n    # if not api_key:\\n    #     logger.error(\\\"OpenAI API 키 설정이 필요합니다. 리뷰를 진행할 수 없습니다.\\\")\\n    #     return\\n```\"}, {\"type\": \"스타일\", \"line_number\": 320, \"file\": \"reviewer/cli.py\", \"description\": \"`show_result` 함수에서 파일 내용을 화면에 표시하기 위해 `print(content)`를 직접 사용하고 있습니다. 애플리케이션의 다른 부분에서는 `logger`를 통한 출력을 주로 사용하고 있어, 출력 방식의 일관성이 다소 부족해 보일 수 있습니다.\", \"suggestion\": \"파일 내용을 표시할 때도 `logger.info()`를 사용하거나 (내용이 길 경우 여러 줄로 나뉘어 로깅될 수 있음을 고려), 혹은 콘솔에 직접적인 원시 데이터 출력을 위한 별도의 유틸리티 함수를 마련하여 사용하는 것을 고려해 보세요. 만약 `print` 사용이 의도된 것이라면 (예: 로거 포맷팅을 피하기 위함), 해당 부분에 주석을 추가하여 그 의도를 명확히 하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    with open(file_path, encoding=\\\"utf-8\\\") as f:\\n        content = f.read()\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\n        print(content)\\n```\", \"improved_code\": \"```python\\n    with open(file_path, encoding=\\\"utf-8\\\") as f:\\n        content = f.read()\\n        # 파일 내용을 직접 출력. 로거 포맷팅을 피하기 위해 print 사용.\\n        # 또는 logger.info(f\\\"\\\\n{content}\\\") 등으로 로거 사용 고려.\\n        print(content)\\n```\"}], \"summary\": \"이번 코드 변경은 '--review-focus' CLI 인자와 관련된 '리뷰 집중 영역' 지정 기능을 완전히 제거하는 데 중점을 둡니다. 이로 인해 CLI 인수 파싱, `ReviewRequest` 데이터 모델, 그리고 LLM 프롬프트 생성 로직에서 해당 기능과 관련된 코드들이 삭제되었습니다. 이 변경은 도구의 인터페이스와 내부 로직을 단순화하는 효과가 있으나, 특정 검토 영역에 대한 세밀한 제어를 원했던 사용자에게는 기능 축소로 느껴질 수 있습니다. 코드 변경 자체는 관련된 여러 파일에 걸쳐 일관성 있게 적용되었습니다.\", \"score\": 8.0, \"recommendations\": [\"'리뷰 집중 영역' 기능 제거에 대한 배경과 그로 인한 사용자 경험 변화(예: 기능 축소 또는 대안 안내)를 내부적으로 명확히 하고, 필요시 사용자 문서나 릴리스 노트를 통해 관련 내용을 전달하는 것을 권장합니다.\", \"`reviewer/cli.py`의 `review_code` 함수 내 API 키 입력 처리 로직(409행 부근)은 중첩된 제어 구조로 인해 가독성이 낮으므로, 이를 별도 함수로 분리하거나 로직을 단순화하여 개선하는 것을 고려해볼 수 있습니다.\", \"애플리케이션 전반의 출력 일관성을 위해 `reviewer/cli.py`의 `show_result` 함수(320행)에서 파일 내용 출력 시 `print` 대신 로거 사용 또는 다른 일관된 방식을 검토하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"이 변경사항은 `--review-focus` 명령줄 인자와 관련된 기능을 제거합니다. `cli.py`에서 해당 인자 정의가 삭제되었고, `models.py`의 `ReviewRequest` 모델에서 `review_focus` 필드가 제거되었습니다. 또한, `prompt_generator.py`에서 `review_focus`를 시스템 프롬프트에 추가하는 관련 로직과 헬퍼 메소드가 삭제되었습니다. 이는 특정 리뷰 포커스를 지정하여 코드 리뷰를 수행하는 기능이 제거되었음을 의미합니다.\", \"score\": 9.5, \"recommendations\": [\"이 기능 제거가 의도된 변경이라면, 사용자 문서에 해당 내용이 반영되었는지 확인하세요.\", \"향후 특정 리뷰 포커스 기능이 다시 필요할 경우, 더 유연하거나 확장 가능한 방식으로 구현하는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 50}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        review_focus=args.review_focus,\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompts/prompt_generator.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport os\\\\nfrom functools import lru_cache\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\nfrom .models import (\\\\n    ReviewPrompt,\\\\n    ReviewPromptWithFileContent,\\\\n    SystemPrompt,\\\\n    UserPrompt,\\\\n    UserPromptWithFileContent,\\\\n)\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef find_project_root() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프로젝트 루트 디렉토리를 찾습니다.\\\\n\\\\n    일반적인 프로젝트 식별 파일(예: .git, pyproject.toml, setup.py)이 있는\\\\n    상위 디렉토리를 찾습니다.\\\\n\\\\n    Returns:\\\\n        Path: 프로젝트 루트 경로\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    current_dir = Path(__file__).resolve().parent\\\\n\\\\n    # 프로젝트 루트 식별자 파일 목록\\\\n    root_identifiers = [\\\\n        \\\\\\\".git\\\\\\\",\\\\n        \\\\\\\"pyproject.toml\\\\\\\",\\\\n        \\\\\\\"setup.py\\\\\\\",\\\\n        \\\\\\\"setup.cfg\\\\\\\",\\\\n        \\\\\\\"requirements.txt\\\\\\\",\\\\n    ]\\\\n\\\\n    while True:\\\\n        if any((current_dir / identifier).exists() for identifier in root_identifiers):\\\\n            return current_dir\\\\n        if current_dir.parent == current_dir:\\\\n            break\\\\n        current_dir = current_dir.parent\\\\n    raise FileNotFoundError(f\\\\\\\"프로젝트 루트 디렉토리를 찾을 수 없습니다: {current_dir}\\\\\\\")\\\\n\\\\n\\\\n@lru_cache(maxsize=1)\\\\ndef load_file_content(filename: str) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 전체 내용을 읽어옵니다. 상대 경로로 된 파일을 Git 루트 디렉토리 기준으로 찾습니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # Git 루트 디렉토리 찾기\\\\n        project_root = find_project_root()\\\\n\\\\n        # 파일 경로 완성\\\\n        file_path = os.path.join(project_root, filename)\\\\n\\\\n        # 파일 내용 읽기\\\\n        if os.path.exists(file_path):\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                return f.read()\\\\n        else:\\\\n            raise FileNotFoundError(f\\\\\\\"파일을 찾을 수 없습니다: {file_path}\\\\\\\")\\\\n    except Exception as e:\\\\n        raise e\\\\n\\\\n\\\\nclass PromptGenerator:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 생성기 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @classmethod\\\\n    @lru_cache(maxsize=1)\\\\n    def _get_code_review_system_prompt(cls) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 시스템 프롬프트를 불러옵니다.\\\\n\\\\n        Returns:\\\\n            str: 코드 리뷰 시스템 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        project_root = find_project_root()\\\\n        prompt_path = (\\\\n            project_root\\\\n            / \\\\\\\"resources\\\\\\\"\\\\n            / \\\\\\\"prompt\\\\\\\"\\\\n            / \\\\\\\"v1\\\\\\\"\\\\n            / \\\\\\\"code_review_system_prompt.txt\\\\\\\"\\\\n        )\\\\n\\\\n        if not prompt_path.exists():\\\\n            raise FileNotFoundError(\\\\n                f\\\\\\\"시스템 프롬프트 파일을 찾을 수 없습니다: {prompt_path}\\\\\\\"\\\\n            )\\\\n\\\\n        with open(prompt_path, encoding=\\\\\\\"utf-8\\\\\\\") as file:\\\\n            return file.read()\\\\n\\\\n    def create_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt | ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 프롬프트를 생성합니다.\\\\n\\\\n        use_full_context 플래그에 따라 적절한 프롬프트 생성 메소드를 호출합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt | ReviewPromptWithFileContent: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if review_request.use_full_context:\\\\n            return self._create_full_context_code_review_prompt(review_request)\\\\n        else:\\\\n            return self._create_simple_code_review_prompt(review_request)\\\\n\\\\n    def _create_simple_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPrompt:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"기본 코드 리뷰 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPrompt: 생성된 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts = []\\\\n\\\\n        for file in review_request.processed_diff.files:\\\\n            file_name = file.filename\\\\n            if file_name not in review_request.file_paths:\\\\n                review_request.file_paths.append(file_name)\\\\n\\\\n            for hunk_idx, hunk in enumerate(file.hunks):\\\\n                safe_original = hunk.get_safe_original_code()\\\\n                safe_modified = hunk.get_safe_modified_code()\\\\n                user_prompt = UserPrompt(\\\\n                    hunk_idx=str(hunk_idx + 1),\\\\n                    file_name=file_name,\\\\n                    original_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_original}\\\\\\\\n```\\\\\\\",\\\\n                    modified_code=f\\\\\\\"```{file.language}\\\\\\\\n{safe_modified}\\\\\\\\n```\\\\\\\",\\\\n                    line_number=hunk.start_line_modified,\\\\n                    language=file.language,\\\\n                )\\\\n                user_prompts.append(user_prompt)\\\\n\\\\n        return ReviewPrompt(system_prompt=system_prompt, user_prompts=user_prompts)\\\\n\\\\n    def _create_full_context_code_review_prompt(\\\\n        self, review_request: ReviewRequest\\\\n    ) -> ReviewPromptWithFileContent:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청으로부터 파일 내용을 포함한 프롬프트를 생성합니다.\\\\n\\\\n        Args:\\\\n            review_request: 리뷰 요청 객체\\\\n\\\\n        Returns:\\\\n            ReviewPromptWithFileContent: 생성된 파일 내용 포함 리뷰 프롬프트 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt_content = self._get_code_review_system_prompt()\\\\n\\\\n        # 시스템 프롬프트 생성\\\\n        system_prompt = SystemPrompt(role=\\\\\\\"system\\\\\\\", content=system_prompt_content)\\\\n        user_prompts: list[UserPromptWithFileContent] = []\\\\n        for request in review_request.processed_diff.files:\\\\n            try:\\\\n                file_content = load_file_content(request.filename)\\\\n            except FileNotFoundError:\\\\n                file_content = \\\\\\\"\\\\\\\"\\\\n\\\\n            user_prompt = UserPromptWithFileContent(\\\\n                file_name=request.filename,\\\\n                file_content=file_content,\\\\n                hunks=request.hunks,\\\\n                language=request.language,\\\\n            )\\\\n            user_prompts.append(user_prompt)\\\\n\\\\n        review_prompt_with_file_content = ReviewPromptWithFileContent(\\\\n            system_prompt=system_prompt,\\\\n            user_prompts=user_prompts,\\\\n        )\\\\n\\\\n        return review_prompt_with_file_content\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    def _get_review_focus_prompt(self, review_focus: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 포커스 프롬프트를 반환합니다.\\\\n\\\\n        Args:\\\\n            review_focus: 리뷰 포커스\\\\n\\\\n        Returns:\\\\n            str: 리뷰 포커스 프롬프트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"\\\\\\\\n\\\\\\\\n특별히 다음 측면에 집중하세요: {review_focus}\\\\\\\"\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 95}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # 리뷰 포커스가 있는 경우 시스템 프롬프트에 추가\\\\n        if review_request.review_focus:\\\\n            system_prompt_content += self._get_review_focus_prompt(\\\\n                review_request.review_focus\\\\n            )\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 161}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_focus: Optional[str] = None\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 46, \"file\": \"reviewer/cli.py\", \"description\": \"코드 리뷰의 집중 영역을 지정하는 `--review-focus` 명령줄 인수가 정의되어 있지만, 관련 기능이 코드에서 제거되어 이 인수의 값이 더 이상 사용되지 않습니다. 이는 사용자에게 혼란을 줄 수 있으며 불필요한 코드를 남깁니다.\", \"suggestion\": \"기능이 제거되었으므로 `--review-focus` 인수의 정의도 함께 제거해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    review_parser.add_argument(\\n        \\\"--review-focus\\\", type=str, help=\\\"리뷰 집중 영역 (예: '보안', '성능')\\\"\\n    )\\n```\", \"improved_code\": \"```python\\n    # --review-focus 인수는 기능 제거로 인해 삭제됨\\n    # review_parser.add_argument(\\n    #     \\\"--review-focus\\\", type=str, help=\\\"리뷰 집중 영역 (예: '보안', '성능')\\\"\\n    # )\\n```\"}], \"summary\": \"이 변경사항은 코드 리뷰의 집중 영역을 지정하는 `review_focus` 기능을 제거합니다. CLI 인자, `ReviewRequest` 모델 필드, 프롬프트 생성 로직에서 관련 코드가 삭제되었습니다. 다만, CLI에서 `--review-focus` 인자를 정의하는 부분이 남아있어 불필요한 코드가 존재합니다.\", \"score\": 8.5, \"recommendations\": [\"--review-focus` 명령줄 인자 정의를 제거하여 불필요한 코드를 정리하고 사용자 혼란을 방지하세요.\", \"기능 제거에 대한 배경이나 이유를 커밋 메시지에 명확히 기록하는 것이 좋습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), None)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 43}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    return run_git_diff(str(repo_path), None)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"설계\", \"line_number\": 43, \"file\": \"reviewer/cli.py\", \"description\": \"--commit-range 명령줄 인자 정의(43행)와 이를 get_diff_content 함수에서 run_git_diff에 전달하는 로직(128행)이 제거되었습니다. 이로 인해 사용자가 특정 커밋 범위를 지정하여 코드 리뷰를 수행하는 기능이 사라졌습니다. 이제 도구는 기본 git diff 결과만 사용하게 됩니다.\", \"suggestion\": \"이 변경이 의도된 기능 축소라면, 사용자에게 이 기능이 제거되었음을 명확히 알리고 문서화해야 합니다. 만약 특정 커밋 범위 리뷰 기능이 필요하다면, --commit-range 인자를 복원하고 get_diff_content 함수에서 이를 다시 사용하도록 수정해야 합니다. 또는, git diff 결과를 파이프(|)를 통해 입력받는 방식을 고려할 수도 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n    review_parser.add_argument(\\n        \\\"--commit-range\\\", type=str, help=\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\"\\n    )\\n```\", \"improved_code\": \"```python\\n\\n```\"}], \"summary\": \"코드 리뷰 명령어에서 --commit-range 인자와 해당 기능을 제거하여, 특정 커밋 범위에 대한 diff 리뷰 기능을 비활성화했습니다. 이제 기본 git diff 결과만 사용합니다.\", \"score\": 8.5, \"recommendations\": [\"기능 제거의 의도를 명확히 하고 사용자 문서에 반영합니다.\", \"만약 특정 커밋 범위 리뷰 기능이 필요하다면, 인자를 복원하거나 diff 내용을 표준 입력으로 받는 방식을 고려합니다.\", \"제거된 기능에 대한 테스트 코드가 있었다면 함께 제거하거나 수정합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 46}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"line_number\\\": 152}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 125}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\nfrom .token_utils import TokenUtils\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\nfrom .models import EstimatedCost\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nimport os\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom .models import EstimatedCost\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 183}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"code quality\", \"line_number\": 183, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"사용되지 않는 `analyze_diff_file` 메서드와 관련 임포트(`os`, `DiffAnalysisResult`)가 제거되었습니다. 이 메서드는 제거된 `--diff-file` CLI 옵션과 연결되어 있었을 가능성이 높습니다. 사용되지 않는 코드를 제거하는 것은 코드베이스를 간결하게 유지하고 유지보수 부담을 줄이는 좋은 관행입니다.\", \"suggestion\": null, \"severity\": \"info\", \"original_code\": \"```python\\n\\n    @staticmethod\\n    def analyze_diff_file(file_path: str, model: str = \\\"gpt-4o\\\") -> DiffAnalysisResult:\\n        \\\"\\\"\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\n\\n        Args:\\n            file_path: diff 파일 경로\\n            model: 사용할 모델 이름\\n\\n        Returns:\\n            DiffAnalysisResult: 분석 결과 객체\\n        \\\"\\\"\\\"\\n        try:\\n            with open(file_path, encoding=\\\"utf-8\\\") as f:\\n                diff_content = f.read()\\n\\n            # 비용 추정\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\n\\n            return DiffAnalysisResult(\\n                model=cost_info.model,\\n                input_tokens=cost_info.input_tokens,\\n                input_cost_usd=cost_info.input_cost_usd,\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\n                within_context_limit=cost_info.within_context_limit,\\n                character_count=len(diff_content),\\n                line_count=diff_content.count(\\\"\\\\n\\\") + 1,\\n                file_path=file_path,\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\n            )\\n        except Exception as e:\\n            return DiffAnalysisResult(\\n                model=model,  # 에러 시 모델명이라도 전달\\n                input_tokens=0,\\n                input_cost_usd=0.0,\\n                estimated_output_tokens=0,\\n                estimated_output_cost_usd=0.0,\\n                estimated_total_cost_usd=0.0,\\n                within_context_limit=False,\\n                character_count=0,\\n                line_count=0,\\n                file_path=file_path,\\n                file_size_kb=0.0,\\n                error=str(e),\\n            )\\n```\", \"improved_code\": \"```python\\n\\n```\"}, {\"type\": \"style\", \"line_number\": 0, \"file\": \"reviewer/src/utils/token/__init__.py\", \"description\": \"`TokenUtils`에 대한 지연 임포트 래퍼(`_TokenUtilsWrapper`)가 제거되고, `__init__.py` 및 `base_gateway.py`에서 직접 임포트하도록 변경되었습니다. 이는 임포트 메커니즘을 단순화하고 코드의 가독성을 향상시킵니다. 지연 임포트는 특정 상황에서 유용할 수 있지만, 핵심 유틸리티의 경우 직접 임포트가 더 명확할 수 있습니다.\", \"suggestion\": null, \"severity\": \"info\", \"original_code\": \"```python\\n\\n\\n# 지연 임포트를 위한 래퍼 클래스\\nclass _TokenUtilsWrapper:\\n    \\\"\\\"\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\n\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\n    \\\"\\\"\\\"\\n\\n    def __getattr__(self, name):\\n        from .token_utils import TokenUtils\\n\\n        return getattr(TokenUtils, name)\\n\\n\\n# TokenUtils 대신 래퍼 인스턴스 제공\\nTokenUtils = _TokenUtilsWrapper()\\n```\", \"improved_code\": \"```python\\nfrom .token_utils import TokenUtils\\n```\"}], \"summary\": \"제공된 diff는 CLI에서 `--diff-file` 옵션을 제거하고, 파일에서 diff 내용을 읽어오는 기능을 삭제합니다. 또한, `TokenUtils` 유틸리티 클래스에 대한 지연 임포트 메커니즘을 제거하고 직접 임포트하도록 변경하여 코드 구조를 단순화했습니다. 사용되지 않는 `analyze_diff_file` 메서드도 함께 제거되었습니다.\", \"score\": 8.5, \"recommendations\": [\"제거된 `--diff-file` 기능에 대한 사용자 문서가 업데이트되었는지 확인하세요.\", \"`TokenUtils`의 직접 임포트가 애플리케이션 시작 시간에 미치는 영향(미미할 것으로 예상되지만)을 확인하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 46}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"line_number\\\": 152}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\nfrom .token_utils import TokenUtils\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"design\", \"line_number\": 46, \"file\": \"reviewer/cli.py\", \"description\": \"CLI 옵션 `--diff-file`이 제거되어 사용자가 파일로부터 직접 diff를 입력하는 기능이 사라졌습니다. 이는 하위 호환성을 깨뜨릴 수 있으며, 문서 및 테스트가 이 변경사항을 반영하지 않을 경우 혼란을 초래할 수 있습니다.\", \"suggestion\": \"`--diff-file` 옵션을 다시 도입하거나, 제거할 경우 사용자에게 사전 경고를 제공하고 README 및 테스트 케이스를 모두 최신화하세요. 또한, 메이저 버전 업데이트를 고려하여 breaking change를 명시하세요.\", \"severity\": \"warning\", \"original_code\": \"review_parser.add_argument(\\n    \\\"--diff-file\\\", type=str, help=\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\"\\n)\", \"improved_code\": \"review_parser.add_argument(\\n    \\\"--diff-file\\\", type=str, help=\\\"(Deprecated) Git diff 파일 경로 (향후 제거 예정, 대신 --commit-range 사용)\\\"\\n)\\n# 이후 get_diff_content에서 diff_file 사용 지원 로직 유지\"}, {\"type\": \"bug\", \"line_number\": 152, \"file\": \"reviewer/cli.py\", \"description\": \"`get_diff_content` 함수에서 `args.commit_range`가 None인 경우를 처리하지 않고 있어, 기본값이 지정되지 않으면 `run_git_diff` 호출 시 의도치 않은 동작이나 예외가 발생할 수 있습니다.\", \"suggestion\": \"commit_range가 None일 때 기본값(예: HEAD~1..HEAD 또는 워킹 디렉토리 변경)을 명시적으로 설정하고, 사용자에게 적절한 피드백을 제공하도록 로직을 추가하세요.\", \"severity\": \"warning\", \"original_code\": \"def get_diff_content(args: argparse.Namespace) -> str:\\n    # Git 명령으로 diff 내용 가져오기\\n    repo_path = Path(args.repo_path)\\n    if not repo_path.exists() or not (repo_path / \\\".git\\\").exists():\\n        raise ValueError(f\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\")\\n    return run_git_diff(str(repo_path), args.commit_range)\", \"improved_code\": \"def get_diff_content(args: argparse.Namespace) -> str:\\n    repo_path = Path(args.repo_path)\\n    if not repo_path.exists() or not (repo_path / \\\".git\\\").exists():\\n        raise ValueError(f\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\")\\n    commit_range = args.commit_range or \\\"HEAD~1..HEAD\\\"\\n    return run_git_diff(str(repo_path), commit_range)\"}, {\"type\": \"performance\", \"line_number\": null, \"file\": \"reviewer/src/utils/token/__init__.py\", \"description\": \"직접 `TokenUtils`를 임포트하면서 모듈 로딩 시점에 모든 종속성을 즉시 로드하게 되어, 초기 실행 속도가 저하될 수 있습니다.\", \"suggestion\": \"PEP 562의 모듈 수준 `__getattr__`을 사용하여 `TokenUtils`를 지연 임포트하거나, `importlib` 기반의 LazyLoader를 활용해 필요한 시점에만 로드되도록 개선하세요.\", \"severity\": \"info\", \"original_code\": \"# 지연 임포트를 위한 래퍼 클래스\\nclass _TokenUtilsWrapper:\\n    \\\"\\\"\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\n    ...\\nTokenUtils = _TokenUtilsWrapper()\", \"improved_code\": \"def __getattr__(name: str):\\n    if name == \\\"TokenUtils\\\":\\n        from .token_utils import TokenUtils\\n        return TokenUtils\\n    raise AttributeError(f\\\"module {__name__!r} has no attribute {name!r}\\\")\\n\\n__all__ = [ ... ]\"}], \"summary\": \"이번 커밋에서는 CLI의 `--diff-file` 옵션과 관련 로직을 제거하고, `TokenUtils` 래퍼를 삭제하여 직접 임포트 방식으로 변경했습니다. 이 과정에서 파일 기반 diff 입력 기능이 사라지고, `args.commit_range` 미지정 시 처리가 누락되었으며, lazy import 구조가 제거되어 초기 로딩 성능에 영향이 있을 수 있습니다.\", \"score\": 6.0, \"recommendations\": [\"엔드유저 영향을 최소화하도록 변경사항을 명세하고 문서화하세요.\", \"CLI 주요 옵션 제거 시, 하위 호환성 보장을 위해 deprecated 경고 및 테스트 업데이트를 수행하세요.\", \"`get_diff_content`에서 commit_range 기본값을 처리하도록 개선해 UX를 보강하세요.\", \"Lazy import가 필요한 경우 모듈 수준 `__getattr__` 또는 `importlib` 기반 LazyLoader를 활용하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef _validate_api_key(api_key: str, provider: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키의 유효성을 검증합니다.\\\\n\\\\n    Args:\\\\n        api_key: 검증할 API 키\\\\n        provider: API 제공자 이름\\\\n\\\\n    Raises:\\\\n        InvalidAPIKeyError: API 키가 빈 값이거나 너무 짧은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not api_key or api_key.strip() == \\\\\\\"\\\\\\\":\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키가 비어 있습니다.\\\\\\\")\\\\n        raise InvalidAPIKeyError(provider, \\\\\\\"API 키가 비어 있습니다\\\\\\\")\\\\n\\\\n    if len(api_key) < 8:\\\\n        logger.error(\\\\n            f\\\\\\\"{provider.upper()} API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다.\\\\\\\"\\\\n        )\\\\n        raise InvalidAPIKeyError(\\\\n            provider, \\\\\\\"API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키\\\\n\\\\n    Raises:\\\\n        APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        InvalidAPIKeyError: API 키가 유효하지 않은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        api_key = config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n        _validate_api_key(api_key, provider)\\\\n        return api_key\\\\n\\\\n    logger.error(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n    raise APIKeyNotFoundError(provider)\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # API 키 유효성 검증\\\\n        _validate_api_key(api_key, provider)\\\\n\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except InvalidAPIKeyError:\\\\n        # 이미 로그는 _validate_api_key에서 기록됨\\\\n        return False\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\ndef _validate_api_key(api_key: str, provider: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키의 유효성을 검증합니다.\\\\n\\\\n    Args:\\\\n        api_key: 검증할 API 키\\\\n        provider: API 제공자 이름\\\\n\\\\n    Raises:\\\\n        InvalidAPIKeyError: API 키가 빈 값이거나 너무 짧은 경우\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not api_key or api_key.strip() == \\\\\\\"\\\\\\\":\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키가 비어 있습니다.\\\\\\\")\\\\n        raise InvalidAPIKeyError(provider, \\\\\\\"API 키가 비어 있습니다\\\\\\\")\\\\n\\\\n    if len(api_key) < 8:\\\\n        logger.error(\\\\n            f\\\\\\\"{provider.upper()} API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다.\\\\\\\"\\\\n        )\\\\n        raise InvalidAPIKeyError(\\\\n            provider, \\\\\\\"API 키가 너무 짧습니다. 최소 8자 이상이어야 합니다\\\\\\\"\\\\n        )\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 61}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        API 키 (키가 없는 경우 ValueError 발생)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        API 키\\\\n\\\\n    Raises:\\\\n        APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        InvalidAPIKeyError: API 키가 유효하지 않은 경우\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        return config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        api_key = config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n        _validate_api_key(api_key, provider)\\\\n        return api_key\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n    raise ValueError(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.error(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n    raise APIKeyNotFoundError(provider)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # API 키 유효성 검증\\\\n        _validate_api_key(api_key, provider)\\\\n\\\\n```\\\", \\\"line_number\\\": 120}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    except InvalidAPIKeyError:\\\\n        # 이미 로그는 _validate_api_key에서 기록됨\\\\n        return False\\\\n```\\\", \\\"line_number\\\": 127}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/exceptions/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n예외 클래스들을 정의하는 패키지입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.exceptions.diff_parsing_error import DiffParsingError\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.exceptions.llm_gateway_error import LLMGatewayError\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"LLMGatewayError\\\\\\\",\\\\n    \\\\\\\"APIKeyNotFoundError\\\\\\\",\\\\n    \\\\\\\"InvalidModelProviderError\\\\\\\",\\\\n    \\\\\\\"UnsupportedModelError\\\\\\\",\\\\n    \\\\\\\"UnsupportedProviderError\\\\\\\",\\\\n    \\\\\\\"DiffParsingError\\\\\\\",\\\\n    \\\\\\\"ContextLimitExceededError\\\\\\\",\\\\n    \\\\\\\"InvalidAPIKeyError\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.exceptions.invalid_api_key_error import InvalidAPIKeyError\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"InvalidAPIKeyError\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"design\", \"line_number\": 139, \"file\": \"reviewer/src/config.py\", \"description\": \"기본 디렉토리 경로를 가져오는 함수들(get_default_results_dir, get_default_raw_log_dir 등)에서 설정 파일을 확인하고 플랫폼별 기본 경로를 결정하는 로직이 반복됩니다. 이는 코드 중복을 야기하며 유지보수를 어렵게 만들 수 있습니다.\", \"suggestion\": \"설정에서 경로를 가져오거나 플랫폼별 기본 경로를 결정하는 공통 헬퍼 함수를 만들어 코드 중복을 줄이세요. 이 헬퍼 함수는 설정 키와 플랫폼별 기본 경로 로직을 인자로 받아 처리할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"def get_default_results_dir() -> Path:\\n    \\\"\\\"\\\"결과 저장 기본 디렉토리를 반환합니다.\\\"\\\"\\\"\\n    config = load_config()\\n\\n    # 설정 파일에 지정된 경우\\n    if \\\"default_results_dir\\\" in config[\\\"paths\\\"]:\\n        path = config[\\\"paths\\\"][\\\"default_results_dir\\\"]\\n        return Path(os.path.expanduser(path))\\n\\n    # 기본 위치\\n    if sys.platform == \\\"darwin\\\":\\n        return MAC_CONFIG_DIR / \\\"results\\\"\\n    else:\\n        return Path.home() / \\\".local\\\" / \\\"share\\\" / \\\"reviewer\\\" / \\\"results\\\"\", \"improved_code\": \"def _get_default_path(config_key: str, macos_subdir: str, other_path: Path) -> Path:\\n    config = load_config()\\n    if config_key in config[\\\"paths\\\"]:\\n        path = config[\\\"paths\\\"][config_key]\\n        return Path(os.path.expanduser(path))\\n    \\n    if sys.platform == \\\"darwin\\\":\\n        return MAC_CONFIG_DIR / macos_subdir\\n    else:\\n        return other_path\\n\\ndef get_default_results_dir() -> Path:\\n    \\\"\\\"\\\"결과 저장 기본 디렉토리를 반환합니다.\\\"\\\"\\\"\\n    return _get_default_path(\\n        \\\"default_results_dir\\\", \\n        \\\"results\\\", \\n        Path.home() / \\\".local\\\" / \\\"share\\\" / \\\"reviewer\\\" / \\\"results\\\"\\n    )\"}, {\"type\": \"style\", \"line_number\": 20, \"file\": \"reviewer/src/config.py\", \"description\": \"`MAC_CONFIG_DIR` 상수는 macOS의 설정 디렉토리를 의미하지만, 코드 내에서 다른 플랫폼의 기본 경로와 macOS의 서브 디렉토리 경로 결정 방식이 일관되지 않아 혼동을 줄 수 있습니다. 이 상수는 macOS의 특정 기본 경로만 나타냅니다.\", \"suggestion\": \"상수 이름을 `MACOS_APP_SUPPORT_BASE_DIR`과 같이 더 명확하게 변경하여 해당 상수가 나타내는 범위를 명확히 하거나, 플랫폼별 기본 디렉토리를 결정하는 로직을 추상화하여 사용하세요.\", \"severity\": \"info\", \"original_code\": \"MAC_CONFIG_DIR = Path.home() / \\\"Library\\\" / \\\"Application Support\\\" / \\\"reviewer\\\"\", \"improved_code\": \"MACOS_APP_SUPPORT_BASE_DIR = Path.home() / \\\"Library\\\" / \\\"Application Support\\\" / \\\"reviewer\\\"\\n# 이후 코드에서 MAC_CONFIG_DIR 대신 MACOS_APP_SUPPORT_BASE_DIR 사용\"}], \"summary\": \"이 변경사항은 API 키 유효성 검증 로직(_validate_api_key 함수)과 API 키 관련 특정 예외(APIKeyNotFoundError, InvalidAPIKeyError) 처리를 도입하여 설정 모듈의 견고성을 향상시켰습니다. 설정 파일 저장 시 소유자만 접근 가능하도록 파일 권한을 설정하는 보안 조치도 포함되었습니다. 전반적으로 코드의 안정성과 오류 처리가 개선되었습니다. 다만, 기본 디렉토리 경로를 가져오는 여러 함수에서 유사한 로직이 반복되는 부분과 플랫폼별 경로 관련 상수 이름의 명확성은 개선될 수 있습니다.\", \"score\": 8.5, \"recommendations\": [\"기본 디렉토리 경로 결정 로직의 중복을 제거하기 위해 공통 헬퍼 함수를 구현하여 사용하세요.\", \"플랫폼별 기본 경로를 나타내는 상수 이름을 더 명확하게 변경하여 코드의 가독성을 높이세요.\", \"표준 플랫폼별 디렉토리 위치를 관리하기 위해 `appdirs`와 같은 외부 라이브러리 사용을 고려해 볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\n```\\\", \\\"line_number\\\": 22}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 31}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 198}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"13\\\", \\\"original_code\\\": \\\"```python\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"14\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"15\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"16\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"17\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"18\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"19\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"20\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 275}, {\\\"hunk_idx\\\": \\\"21\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 294}, {\\\"hunk_idx\\\": \\\"22\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"23\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"24\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n```\\\", \\\"line_number\\\": 324}, {\\\"hunk_idx\\\": \\\"25\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"26\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"27\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.warning(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"28\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"29\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 373}, {\\\"hunk_idx\\\": \\\"30\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"31\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"32\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"33\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"34\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"35\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"36\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"37\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"38\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"39\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"40\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 448}, {\\\"hunk_idx\\\": \\\"41\\\", \\\"original_code\\\": \\\"```python\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"42\\\", \\\"original_code\\\": \\\"```python\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"43\\\", \\\"original_code\\\": \\\"```python\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"44\\\", \\\"original_code\\\": \\\"```python\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"45\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"46\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"47\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"48\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"49\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"50\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 537}, {\\\"hunk_idx\\\": \\\"51\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n```\\\", \\\"line_number\\\": 543}, {\\\"hunk_idx\\\": \\\"52\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"53\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키 (키가 없는 경우 ValueError 발생)\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        return config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n\\\\n    raise ValueError(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_raw_log_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n# 로그 디렉토리 설정 및 생성\\\\nLOG_DIR = get_default_raw_log_dir()\\\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n```\\\", \\\"line_number\\\": 29}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 128}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n            raw_response_file = LOG_DIR / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"13\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"14\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"15\\\", \\\"original_code\\\": \\\"```python\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n```\\\", \\\"line_number\\\": 241}, {\\\"hunk_idx\\\": \\\"16\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/claude_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport logging\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\nfrom . import get_api_key\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\nclass ClaudeGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Anthropic Claude API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.debug(\\\\\\\"Claude API 키 로드 시도 중\\\\\\\")\\\\n        api_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n        if not api_key:\\\\n            logger.error(\\\\\\\"Claude API 키를 찾을 수 없습니다\\\\\\\")\\\\n            raise APIKeyNotFoundError(\\\\\\\"claude\\\\\\\")\\\\n        logger.debug(\\\\\\\"Claude API 키 로드 성공\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: Claude 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"claude\\\\\\\":\\\\n            logger.warning(f\\\\\\\"{model_info['full_name']}은(는) Claude 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"Claude\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\n                f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\"\\\\n            )\\\\n            self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Claude API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.debug(\\\\\\\"Claude API 요청 파라미터 생성 중\\\\\\\")\\\\n        # 기본 파라미터 설정\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.get_model_name(),\\\\n            \\\\\\\"messages\\\\\\\": messages,\\\\n            # Claude는 max_tokens 파라미터가 필요합니다, Claude 3.7 Sonnet 기준,\\\\n            # normal 8192, thinking 64000\\\\n            \\\\\\\"max_tokens\\\\\\\": 8192,\\\\n        }\\\\n\\\\n        # 모델별 파라미터 설정\\\\n        model_params = self.model[\\\\\\\"params\\\\\\\"]\\\\n        params.update(model_params)\\\\n\\\\n        logger.debug(f\\\\\\\"Claude API 요청 파라미터 생성 완료: {self.get_model_name()}\\\\\\\")\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport logging\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 15}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"Claude API 키 로드 시도 중\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\\\\"Claude API 키를 찾을 수 없습니다\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"Claude API 키 로드 성공\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) Claude 모델이 아닙니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.warning(f\\\\\\\"{model_info['full_name']}은(는) Claude 모델이 아닙니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"Claude API 요청 파라미터 생성 중\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(f\\\\\\\"Claude API 요청 파라미터 생성 완료: {self.get_model_name()}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/google_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport logging\\\\nfrom typing import Any\\\\n\\\\nfrom google.genai import types\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\nfrom . import get_api_key\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\nclass GoogleGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.debug(\\\\\\\"Google API 키 로드 시도 중\\\\\\\")\\\\n        api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n        if not api_key:\\\\n            logger.error(\\\\\\\"Google API 키를 찾을 수 없습니다\\\\\\\")\\\\n            raise APIKeyNotFoundError(\\\\\\\"google\\\\\\\")\\\\n        logger.debug(\\\\\\\"Google API 키 로드 성공\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: Google 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"google\\\\\\\":\\\\n            logger.warning(f\\\\\\\"{model_info['full_name']}은(는) Google 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"Google\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\n                f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\"\\\\n            )\\\\n            self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.debug(\\\\\\\"Google Gemini API 요청 파라미터 생성 중\\\\\\\")\\\\n        system_prompt = None\\\\n        contents = []\\\\n\\\\n        # 시스템 프롬프트와 유저 메시지 구분\\\\n        for message in messages:\\\\n            role = message.get(\\\\\\\"role\\\\\\\", \\\\\\\"\\\\\\\")\\\\n            content = message.get(\\\\\\\"content\\\\\\\", \\\\\\\"\\\\\\\")\\\\n\\\\n            if role == \\\\\\\"system\\\\\\\":\\\\n                system_prompt = content\\\\n            elif role == \\\\\\\"user\\\\\\\":\\\\n                contents.append(content)\\\\n\\\\n        # 온도 설정 (기본값: 0.0)\\\\n        temperature = self.model[\\\\\\\"params\\\\\\\"].get(\\\\\\\"temperature\\\\\\\", 0.0)\\\\n\\\\n        # config 생성\\\\n        generation_config = types.GenerateContentConfig(\\\\n            temperature=temperature,\\\\n            system_instruction=system_prompt,\\\\n            response_mime_type=\\\\\\\"application/json\\\\\\\",\\\\n            response_schema=StructuredReviewResponse,\\\\n        )\\\\n\\\\n        # Gemini API 요청 파라미터 생성\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.model[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\".join(contents) if contents else \\\\\\\"\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": generation_config,\\\\n        }\\\\n\\\\n        logger.debug(\\\\n            f\\\\\\\"Google Gemini API 요청 파라미터 생성 완료: {self.model['full_name']}\\\\\\\"\\\\n        )\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport logging\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import ReviewResponse, StructuredReviewResponse\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 18}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"Google API 키 로드 시도 중\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\\\\"Google API 키를 찾을 수 없습니다\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"Google API 키 로드 성공\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) Google 모델이 아닙니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.warning(f\\\\\\\"{model_info['full_name']}은(는) Google 모델이 아닙니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"Google Gemini API 요청 파라미터 생성 중\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\n            f\\\\\\\"Google Gemini API 요청 파라미터 생성 완료: {self.model['full_name']}\\\\\\\"\\\\n        )\\\\n```\\\", \\\"line_number\\\": 100}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하여 코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 베이스 클래스의 요청 준비 메소드 활용\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # Google Gemini 클라이언트 초기화\\\\n            client = genai.Client(api_key=self.api_key)\\\\n\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # Gemini API 요청 송신\\\\n            response = client.models.generate_content(**params)\\\\n\\\\n            # 구조화된 응답 생성\\\\n            # 텍스트 응답을 StructuredReviewResponse 형식으로 파싱\\\\n            try:\\\\n                response_text = response.text\\\\n                if response_text is None:\\\\n                    return ReviewResponse.get_empty_response()\\\\n\\\\n                structured_response = StructuredReviewResponse.model_validate_json(\\\\n                    response_text\\\\n                )\\\\n\\\\n                # 원본 응답 저장\\\\n                self.save_raw_response(structured_response)\\\\n\\\\n                # 응답 처리\\\\n                if not structured_response:\\\\n                    return ReviewResponse.get_empty_response()\\\\n\\\\n                return ReviewResponse.from_structured_response(structured_response)\\\\n\\\\n            except Exception as parse_error:\\\\n                print(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                print(f\\\\\\\"원본 응답: {response.text}\\\\\\\")\\\\n                return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 103}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/openai_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"OpenAI API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport logging\\\\nfrom typing import Any\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\nfrom . import get_api_key\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\nclass OpenAIGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"OpenAI API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.debug(\\\\\\\"OpenAI API 키 로드 시도 중\\\\\\\")\\\\n        api_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n        if not api_key:\\\\n            logger.error(\\\\\\\"OpenAI API 키를 찾을 수 없습니다\\\\\\\")\\\\n            raise APIKeyNotFoundError(\\\\\\\"openai\\\\\\\")\\\\n        logger.debug(\\\\\\\"OpenAI API 키 로드 성공\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: model_info 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: OpenAI 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"openai\\\\\\\":\\\\n            logger.warning(f\\\\\\\"{model_info['full_name']}은(는) OpenAI 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"OpenAI\\\\\\\")\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\"\\\\n        )\\\\n        self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"OpenAI API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.debug(\\\\\\\"OpenAI API 요청 파라미터 생성 중\\\\\\\")\\\\n        # 기본 파라미터 설정\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.get_model_name(),\\\\n            \\\\\\\"messages\\\\\\\": messages,\\\\n        }\\\\n\\\\n        # 모델별 파라미터 설정\\\\n        model_params = self.model[\\\\\\\"params\\\\\\\"]\\\\n        params.update(model_params)\\\\n\\\\n        logger.debug(f\\\\\\\"OpenAI API 요청 파라미터 생성 완료: {self.get_model_name()}\\\\\\\")\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport logging\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 15}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"OpenAI API 키 로드 시도 중\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\\\\"OpenAI API 키를 찾을 수 없습니다\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"OpenAI API 키 로드 성공\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) OpenAI 모델이 아닙니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.warning(f\\\\\\\"{model_info['full_name']}은(는) OpenAI 모델이 아닙니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n            f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\"\\\\n        )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(\\\\\\\"OpenAI API 요청 파라미터 생성 중\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.debug(f\\\\\\\"OpenAI API 요청 파라미터 생성 완료: {self.get_model_name()}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .prompt_utils import save_prompt\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=0\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 3}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"오류: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompt_utils.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트와 관련된 유틸리티 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport json\\\\nfrom datetime import datetime\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_prompt_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_prompt_{timestamp}_{model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(messages, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_review_prompt_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n```\\\", \\\"line_number\\\": 19}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/models.py\\\", \\\"file_content\\\": \\\"import logging\\\\nfrom enum import Enum\\\\nfrom typing import Optional\\\\n\\\\nfrom pydantic import BaseModel, Field\\\\n\\\\nfrom reviewer.src.diff_parser.models.diff_result import DiffResult\\\\n\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\n# Structured Outputs용 스키마 클래스 (기본값 없음)\\\\nclass IssueSeverityEnum(str, Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"이슈 심각도 열거형\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    INFO = \\\\\\\"info\\\\\\\"\\\\n    WARNING = \\\\\\\"warning\\\\\\\"\\\\n    ERROR = \\\\\\\"error\\\\\\\"\\\\n\\\\n\\\\nclass StructuredReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int]\\\\n    file: Optional[str]\\\\n    description: str\\\\n    suggestion: Optional[str]\\\\n    severity: IssueSeverityEnum\\\\n    original_code: Optional[str]  # 리뷰 대상 코드\\\\n    improved_code: Optional[str]  # 개선된 코드\\\\n\\\\n\\\\nclass StructuredReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Structured Outputs용 코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[StructuredReviewIssue]\\\\n    summary: str\\\\n    score: Optional[float]\\\\n    recommendations: list[str]\\\\n\\\\n\\\\nclass ReviewRequest(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 요청 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    diff_content: str\\\\n    processed_diff: DiffResult\\\\n    file_paths: list[str] = Field(default_factory=list)\\\\n    review_focus: Optional[str] = None\\\\n    use_full_context: bool = True\\\\n    model: str\\\\n\\\\n\\\\nclass ReviewIssue(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 이슈 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    type: str\\\\n    line_number: Optional[int] = None\\\\n    file: Optional[str] = None\\\\n    description: str\\\\n    suggestion: Optional[str] = None\\\\n    severity: str = \\\\\\\"info\\\\\\\"  # info, warning, error\\\\n    original_code: Optional[str] = None  # 리뷰 대상 코드\\\\n    improved_code: Optional[str] = None  # 개선된 코드\\\\n\\\\n    @staticmethod\\\\n    def from_structured_issue(\\\\n        issue: StructuredReviewIssue, index: int = 0\\\\n    ) -> \\\\\\\"ReviewIssue\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 이슈 객체에서 ReviewIssue 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            issue: 구조화된 이슈 객체\\\\n            index: 디버깅을 위한 이슈 인덱스\\\\n\\\\n        Returns:\\\\n            ReviewIssue: 변환된 이슈 객체\\\\n\\\\n        Raises:\\\\n            Exception: 변환 중 오류 발생 시\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # severity 처리 (모든 게이트웨이에서 동일하게 처리)\\\\n            severity_value = issue.severity.value\\\\n\\\\n            return ReviewIssue(\\\\n                type=issue.type,\\\\n                line_number=issue.line_number,\\\\n                file=issue.file,\\\\n                description=issue.description,\\\\n                suggestion=issue.suggestion,\\\\n                severity=severity_value,\\\\n                original_code=issue.original_code,\\\\n                improved_code=issue.improved_code,\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n            raise\\\\n\\\\n\\\\nclass ReviewResponse(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰 응답 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    issues: list[ReviewIssue] = Field(default_factory=list)\\\\n    summary: str\\\\n    score: Optional[float] = None\\\\n    recommendations: list[str] = Field(default_factory=list)\\\\n\\\\n    @staticmethod\\\\n    def from_structured_response(\\\\n        structured_response: StructuredReviewResponse,\\\\n    ) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"구조화된 응답 객체에서 ReviewResponse 인스턴스를 생성합니다.\\\\n\\\\n        Args:\\\\n            structured_response: 구조화된 응답 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 변환된 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        issues = []\\\\n\\\\n        # 이슈 변환\\\\n        for i, issue in enumerate(structured_response.issues):\\\\n            try:\\\\n                issues.append(ReviewIssue.from_structured_issue(issue, i))\\\\n            except Exception:  # noqa: S112\\\\n                # 개별 이슈 변환 실패는 무시하고 계속 진행\\\\n                continue\\\\n\\\\n        # 옵셔널 필드 안전하게 처리\\\\n        return ReviewResponse(\\\\n            issues=issues,\\\\n            summary=structured_response.summary,\\\\n            score=structured_response.score,\\\\n            recommendations=structured_response.recommendations,\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_empty_response() -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"비어있는 응답 객체를 생성합니다.\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 메시지가 포함된 빈 리뷰 응답\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=\\\\\\\"LLM 응답이 비어있거나 불완전합니다.\\\\\\\",\\\\n            recommendations=[\\\\\\\"다른 프롬프트나 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def get_error_response(error: Exception) -> \\\\\\\"ReviewResponse\\\\\\\":\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"API 오류에 대한 응답 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            error: 발생한 예외\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 에러 정보가 포함된 리뷰 응답\\\\n\\\\n        Raises:\\\\n            Exception: 요청 또는 네트워크 오류인 경우 재발생\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        import traceback\\\\n\\\\n        import requests\\\\n\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n        traceback.print_exc()\\\\n\\\\n        # 요청 또는 네트워크 오류인 경우\\\\n        if isinstance(error, requests.RequestException):\\\\n            raise Exception(f\\\\\\\"API 호출 중 오류 발생: {str(error)}\\\\\\\") from error\\\\n\\\\n        # 기타 예외 처리 (토큰 제한, 파싱 오류 등)\\\\n        return ReviewResponse(\\\\n            issues=[],\\\\n            summary=f\\\\\\\"LLM API 처리 중 오류 발생: {str(error)}\\\\\\\",\\\\n            recommendations=[\\\\\\\"요청 내용을 줄이거나 다른 모델을 사용해보세요.\\\\\\\"],\\\\n        )\\\\n\\\\n\\\\nclass EstimatedCost(BaseModel):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"비용 추정 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    model: str\\\\n    input_tokens: int\\\\n    input_cost_usd: float\\\\n    estimated_output_tokens: int\\\\n    estimated_output_cost_usd: float\\\\n    estimated_total_cost_usd: float\\\\n    within_context_limit: bool\\\\n\\\\n\\\\nclass DiffCheckResult(EstimatedCost):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 크기 및 비용 정보 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    character_count: int\\\\n    line_count: int\\\\n\\\\n\\\\nclass DiffAnalysisResult(DiffCheckResult):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Diff 파일 분석 결과 모델\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    file_path: str\\\\n    file_size_kb: float\\\\n    error: Optional[str] = None  # 오류 발생 시 사용\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nimport logging\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 9}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(f\\\\\\\"이슈 #{index + 1} 변환 중 오류: {str(e)}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.warning(\\\\\\\"응답이 비어있습니다\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"API 처리 중 오류 발생: {str(error)}\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import get_api_key\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 11}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 126, \"file\": \"reviewer/src/ui.py\", \"description\": \"사이드바에 한국어 UI 중 일부만 영어(\\\"reviewRequest\\\")로 표시되어 있어 사용자 경험이 일관성 없고 가독성이 떨어집니다.\", \"suggestion\": \"모든 UI 문구를 한국어로 통일합니다. 예: \\\"reviewRequest 요약 위치\\\" → \\\"리뷰 요청 위치\\\"\", \"severity\": \"warning\", \"original_code\": \"st.sidebar.markdown(f\\\"**reviewRequest 요약 위치**: {request_dir}\\\")\", \"improved_code\": \"st.sidebar.markdown(f\\\"**리뷰 요청 위치**: {request_dir}\\\")\"}, {\"type\": \"style\", \"line_number\": 155, \"file\": \"reviewer/src/ui.py\", \"description\": \"view_type 값이 영어(\\\"reviewRequest\\\")로 지정되어 있어 사용자에게 낯설며 기존 메뉴의 한국어 명칭과 일관되지 않습니다.\", \"suggestion\": \"view_type 옵션과 비교 문자열을 한국어(\\\"리뷰 요청\\\")로 변경하고 selectbox 항목도 동일하게 갱신합니다.\", \"severity\": \"warning\", \"original_code\": \"view_type = st.sidebar.selectbox(\\n    \\\"보기 유형:\\\", [\\\"리뷰 결과\\\", \\\"실행 로그\\\", \\\"reviewRequest\\\", \\\"프롬프트\\\"], index=0\\n)\\nelif view_type == \\\"reviewRequest\\\":\", \"improved_code\": \"view_type = st.sidebar.selectbox(\\n    \\\"보기 유형:\\\", [\\\"리뷰 결과\\\", \\\"실행 로그\\\", \\\"리뷰 요청\\\", \\\"프롬프트\\\"], index=0\\n)\\nelif view_type == \\\"리뷰 요청\\\":\"}, {\"type\": \"style\", \"line_number\": 279, \"file\": \"reviewer/src/ui.py\", \"description\": \"reviewRequest 뷰의 제목이 영어 혼용(\\\"## reviewRequest 내용\\\")으로 표시되어 있어 일관성이 떨어집니다.\", \"suggestion\": \"제목을 한국어(\\\"## 리뷰 요청 내용\\\")로 변경합니다.\", \"severity\": \"warning\", \"original_code\": \"elif view_type == \\\"reviewRequest\\\":\\n    st.markdown(\\\"## reviewRequest 내용\\\")\", \"improved_code\": \"elif view_type == \\\"리뷰 요청\\\":\\n    st.markdown(\\\"## 리뷰 요청 내용\\\")\"}, {\"type\": \"bug\", \"line_number\": 39, \"file\": \"resources/prompt/v1/code_review_system_prompt.txt\", \"description\": \"JSON 예시에서 \\\"line_number\\\" 항목 뒤에 쉼표가 빠져 있어 유효한 JSON이 아닙니다.\", \"suggestion\": \"\\\"line_number\\\" 항목 끝에 쉼표를 추가하여 JSON 문법을 올바르게 만듭니다.\", \"severity\": \"error\", \"original_code\": \"      \\\"line_number\\\": 수정 행 번호\\n      \\\"file\\\": \\\"파일명\\\",\", \"improved_code\": \"      \\\"line_number\\\": 수정 행 번호,\\n      \\\"file\\\": \\\"파일명\\\",\"}, {\"type\": \"bug\", \"line_number\": 133, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"file_info 변수가 문자열(파일명)인데 .get(\\\"language\\\", \\\"\\\")를 호출하여 AttributeError가 발생합니다.\", \"suggestion\": \"file_info 대신 파일 메타데이터를 담은 dict를 사용하거나 language 항목을 제거하고 필요한 경우 review_request 에서 가져오도록 수정합니다.\", \"severity\": \"error\", \"original_code\": \"\\\"language\\\": file_info.get(\\\"language\\\", \\\"\\\"),\", \"improved_code\": \"# 언어 정보가 필요 없다면 제거하거나\\n# 예시: \\\"language\\\" 키를 포함하지 않습니다\\n# \\\"language\\\": review_request.additional_context or \\\"\\\",\\n\"}, {\"type\": \"bug\", \"line_number\": 87, \"file\": \"tests/test_prompt_generator.py\", \"description\": \"테스트에서 삭제된 language 프롬프트와 변경된 hunk 메시지 구조를 그대로 검증하여 테스트가 실패합니다.\", \"suggestion\": \"messages 배열의 JSON 형식을 파싱하여 hunk_idx, file_name, content 등을 검증하도록 테스트를 업데이트합니다.\", \"severity\": \"error\", \"original_code\": \"assert \\\"코드는 Python 언어로 작성되었습니다.\\\" in messages[0][\\\"content\\\"]\", \"improved_code\": \"user_msg = json.loads(messages[1][\\\"content\\\"])\\nassert user_msg[\\\"hunk_idx\\\"] == \\\"1\\\"\\nassert user_msg[\\\"file_name\\\"] == \\\"file.py\\\"\\nassert \\\"```diff\\\\n+print('Hello')\\\\n print('World')\\\\n```\\\" in user_msg[\\\"content\\\"]\"}], \"summary\": \"이번 변경에서는 ReviewIssue와 StructuredReviewIssue 모델의 line 속성을 line_number로 일관화하고, ReviewRequest에서 language 필드를 제거하였습니다. 이에 따라 CLI 및 레거시 테스트, prompt 생성 로직, LLM 게이트웨이 매핑 코드, UI 뷰 타입 등이 대대적으로 리팩토링되었으나, 일부 UI 문구의 언어 혼용, 프롬프트 예시 JSON 문법 오류, prompt_generator 내부 변수 오용에 따른 런타임 에러, 테스트 미반영 이슈가 발견되었습니다.\", \"score\": 6.0, \"recommendations\": [\"UI 문구를 한국어로 일관되게 통일하세요.\", \"resources 디렉토리 내 JSON 예시 문법 오류를 점검하고 수정하세요.\", \"prompt_generator.py 내 변수 사용을 재검토하여 런타임 에러를 방지하세요.\", \"테스트 코드를 리팩토링하여 최신 메시지 포맷을 반영하도록 업데이트하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\n```\\\", \\\"line_number\\\": 22}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 31}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 198}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n```\\\", \\\"line_number\\\": 540}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키 (키가 없는 경우 ValueError 발생)\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        return config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n\\\\n    raise ValueError(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_raw_log_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n# 로그 디렉토리 설정 및 생성\\\\nLOG_DIR = get_default_raw_log_dir()\\\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n```\\\", \\\"line_number\\\": 29}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 128}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n            raw_response_file = LOG_DIR / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"13\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"14\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"15\\\", \\\"original_code\\\": \\\"```python\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n```\\\", \\\"line_number\\\": 241}, {\\\"hunk_idx\\\": \\\"16\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/google_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Any\\\\n\\\\nfrom google.genai import types\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\nfrom . import get_api_key\\\\n\\\\n\\\\nclass GoogleGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n        if not api_key:\\\\n            raise APIKeyNotFoundError(\\\\\\\"google\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: Google 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"google\\\\\\\":\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) Google 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"Google\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n            self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt = None\\\\n        contents = []\\\\n\\\\n        # 시스템 프롬프트와 유저 메시지 구분\\\\n        for message in messages:\\\\n            role = message.get(\\\\\\\"role\\\\\\\", \\\\\\\"\\\\\\\")\\\\n            content = message.get(\\\\\\\"content\\\\\\\", \\\\\\\"\\\\\\\")\\\\n\\\\n            if role == \\\\\\\"system\\\\\\\":\\\\n                system_prompt = content\\\\n            elif role == \\\\\\\"user\\\\\\\":\\\\n                contents.append(content)\\\\n\\\\n        # 온도 설정 (기본값: 0.0)\\\\n        temperature = self.model[\\\\\\\"params\\\\\\\"].get(\\\\\\\"temperature\\\\\\\", 0.0)\\\\n\\\\n        # config 생성\\\\n        generation_config = types.GenerateContentConfig(\\\\n            temperature=temperature,\\\\n            system_instruction=system_prompt,\\\\n            response_mime_type=\\\\\\\"application/json\\\\\\\",\\\\n            response_schema=StructuredReviewResponse,\\\\n        )\\\\n\\\\n        # Gemini API 요청 파라미터 생성\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.model[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\".join(contents) if contents else \\\\\\\"\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": generation_config,\\\\n        }\\\\n\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import ReviewResponse, StructuredReviewResponse\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하여 코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 베이스 클래스의 요청 준비 메소드 활용\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # Google Gemini 클라이언트 초기화\\\\n            client = genai.Client(api_key=self.api_key)\\\\n\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # Gemini API 요청 송신\\\\n            response = client.models.generate_content(**params)\\\\n\\\\n            # 구조화된 응답 생성\\\\n            # 텍스트 응답을 StructuredReviewResponse 형식으로 파싱\\\\n            try:\\\\n                response_text = response.text\\\\n                if response_text is None:\\\\n                    return ReviewResponse.get_empty_response()\\\\n\\\\n                structured_response = StructuredReviewResponse.model_validate_json(\\\\n                    response_text\\\\n                )\\\\n\\\\n                # 원본 응답 저장\\\\n                self.save_raw_response(structured_response)\\\\n\\\\n                # 응답 처리\\\\n                if not structured_response:\\\\n                    return ReviewResponse.get_empty_response()\\\\n\\\\n                return ReviewResponse.from_structured_response(structured_response)\\\\n\\\\n            except Exception as parse_error:\\\\n                print(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                print(f\\\\\\\"원본 응답: {response.text}\\\\\\\")\\\\n                return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 91}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .prompt_utils import save_prompt\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=0\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 3}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"오류: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompt_utils.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트와 관련된 유틸리티 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport json\\\\nfrom datetime import datetime\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_prompt_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_prompt_{timestamp}_{model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(messages, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_review_prompt_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n```\\\", \\\"line_number\\\": 19}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import get_api_key\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 11}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 39, \"file\": \"reviewer/src/llm_gateway/google_gateway.py\", \"description\": \"`_set_model` 메소드 내에 `print` 함수가 사용되고 있습니다. 프로젝트 전반의 로깅 표준화에 따라 `logger` 객체를 사용하는 것이 일관성을 유지하고 로그 관리에 용이합니다.\", \"suggestion\": \"`print` 문을 `logger.warning` 및 `logger.info`로 변경하여 다른 코드베이스와 일관된 로깅 방식을 적용하세요.\", \"severity\": \"info\", \"original_code\": \"        if model_info[\\\"provider\\\"] != \\\"google\\\":\\n            print(f\\\"경고: {model_info['full_name']}은(는) Google 모델이 아닙니다.\\\")\\n            raise InvalidModelProviderError(model_info[\\\"full_name\\\"], \\\"Google\\\")\\n        else:\\n            print(f\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\")\\n            self.model = model_info\", \"improved_code\": \"        if model_info[\\\"provider\\\"] != \\\"google\\\":\\n            logger.warning(f\\\"{model_info['full_name']}은(는) Google 모델이 아닙니다.\\\")\\n            raise InvalidModelProviderError(model_info[\\\"full_name\\\"], \\\"Google\\\")\\n        else:\\n            logger.info(f\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\")\\n            self.model = model_info\"}, {\"type\": \"스타일\", \"line_number\": 460, \"file\": \"reviewer/cli.py\", \"description\": \"`review_code` 함수 내에서 diff 내용이 없을 경우 사용자에게 알리기 위해 `print` 함수가 사용되고 있습니다. 로깅 표준화 리팩토링 과정에서 누락된 부분으로 보이며, `logger`를 사용하도록 수정해야 합니다.\", \"suggestion\": \"`print(\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\")`를 `logger.warning(\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\")` 또는 `logger.info`로 변경하여 일관성을 유지하세요. 내용의 성격상 `logger.warning`이 더 적절할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"    if not diff_content:\\n        print(\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\")\\n        return\", \"improved_code\": \"    if not diff_content:\\n        logger.warning(\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\")\\n        return\"}, {\"type\": \"버그\", \"line_number\": 201, \"file\": \"reviewer/cli.py\", \"description\": \"API 키 마스킹 로직 (`current_key[:4] + \\\"*\\\" * (len(current_key) - 8) + current_key[-4:]`)은 API 키의 길이가 8자 미만일 경우, 올바르게 작동하지 않거나 의도치 않게 키의 일부를 노출할 수 있습니다. 예를 들어, 7자리 키 \\\"1234567\\\"은 \\\"12344567\\\"로 마스킹될 수 있습니다.\", \"suggestion\": \"API 키 길이가 짧은 경우를 처리할 수 있도록 마스킹 로직을 개선해야 합니다. 예를 들어, 키 길이가 8자 미만일 경우, 첫 글자와 마지막 글자만 보여주거나, 별표의 개수가 음수가 되지 않도록 조정하는 방식 등을 고려할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"                masked_key = (\\n                    current_key[:4] + \\\"*\\\" * (len(current_key) - 8) + current_key[-4:]\\n                )\\n                logger.info(f\\\"현재 {provider.upper()} API 키: {masked_key}\\\")\", \"improved_code\": \"                if len(current_key) < 8:\\n                    if len(current_key) <= 2:\\n                        masked_key = \\\"*\\\" * len(current_key)\\n                    elif len(current_key) <= 4: # 예시: 짧은 키는 앞 1자리, 뒤 1자리만\\n                        masked_key = current_key[0] + \\\"*\\\" * (len(current_key) - 2) + current_key[-1] if len(current_key) > 1 else \\\"*\\\"\\n                    else: # 예시: 4자리 초과 8자리 미만은 앞 2자리, 뒤 2자리\\n                         masked_key = current_key[:2] + \\\"*\\\" * (len(current_key) - 4) + current_key[-2:]\\n                else:\\n                    masked_key = (\\n                        current_key[:4] + \\\"*\\\" * (len(current_key) - 8) + current_key[-4:]\\n                    )\\n                logger.info(f\\\"현재 {provider.upper()} API 키: {masked_key}\\\")\"}], \"summary\": \"이번 코드 변경은 주로 로깅 시스템 개선과 Google Gemini 모델 지원 추가에 중점을 두고 있습니다. 전반적으로 `print` 문을 `logger`로 대체하여 로깅의 일관성을 높였고, 순환 참조 방지를 위해 지연 로딩(lazy loading) 패턴을 도입했습니다. 또한, LLM 게이트웨이 로직을 `BaseGateway`로 중앙화하고 오류 처리 및 예외 로깅을 강화하여 코드의 안정성과 유지보수성을 향상시켰습니다. Gemini 모델 지원을 위한 토큰 계산 및 비용 추정 로직도 `TokenUtils`에 추가되었습니다.\", \"score\": 8.5, \"recommendations\": [\"프로젝트 전체에서 사용자 대면 메시지 및 내부 상태/오류 메시지에 `print` 대신 `logger`를 일관되게 사용하도록 모든 파일을 검토하고 수정하세요.\", \"API 키 마스킹 로직을 다양한 길이의 키에 대해 안전하게 작동하도록 개선하고, 이에 대한 테스트 케이스를 추가하는 것을 고려하세요.\", \"CLI에서 `get_diff_content` 실패 시 (예: 잘못된 커밋 범위) 사용자에게 보다 구체적인 오류 원인을 전달하는 방안을 고려하세요. 현재는 일반적인 메시지만 출력됩니다.\", \"무겁거나 상호 의존적인 모듈에 대해 지연 로딩 패턴을 지속적으로 적용하여 애플리케이션 시작 시간 및 유지보수성을 개선하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\n```\\\", \\\"line_number\\\": 22}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 31}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 198}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n```\\\", \\\"line_number\\\": 540}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키 (키가 없는 경우 ValueError 발생)\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        return config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n\\\\n    raise ValueError(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_raw_log_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n# 로그 디렉토리 설정 및 생성\\\\nLOG_DIR = get_default_raw_log_dir()\\\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n```\\\", \\\"line_number\\\": 29}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 128}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n            raw_response_file = LOG_DIR / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"13\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"14\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"15\\\", \\\"original_code\\\": \\\"```python\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n            elif isinstance(client, genai.Client):\\\\n                try:\\\\n                    response = client.models.generate_content(**params)\\\\n                    response_text = response.text\\\\n                    if response_text is None:\\\\n                        return ReviewResponse.get_empty_response()\\\\n\\\\n                    completion = StructuredReviewResponse.model_validate_json(\\\\n                        response_text\\\\n                    )\\\\n                except Exception as parse_error:\\\\n                    logger.error(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                    logger.error(\\\\n                        f\\\\\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\\\\\"\\\\n                    )\\\\n                    return ReviewResponse.get_error_response(parse_error)\\\\n```\\\", \\\"line_number\\\": 241}, {\\\"hunk_idx\\\": \\\"16\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/google_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Any\\\\n\\\\nfrom google.genai import types\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.api_key_not_found_error import APIKeyNotFoundError\\\\nfrom reviewer.src.exceptions.invalid_model_provider_error import (\\\\n    InvalidModelProviderError,\\\\n)\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n\\\\nfrom . import get_api_key\\\\n\\\\n\\\\nclass GoogleGateway(BaseGateway):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하는 LLM 게이트웨이\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google API 키를 로드합니다.\\\\n\\\\n        Returns:\\\\n            str: API 키\\\\n\\\\n        Raises:\\\\n            APIKeyNotFoundError: API 키가 설정되지 않은 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n        if not api_key:\\\\n            raise APIKeyNotFoundError(\\\\\\\"google\\\\\\\")\\\\n        return api_key\\\\n\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정합니다.\\\\n\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n\\\\n        Raises:\\\\n            InvalidModelProviderError: Google 모델이 아닌 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] != \\\\\\\"google\\\\\\\":\\\\n            print(f\\\\\\\"경고: {model_info['full_name']}은(는) Google 모델이 아닙니다.\\\\\\\")\\\\n            raise InvalidModelProviderError(model_info[\\\\\\\"full_name\\\\\\\"], \\\\\\\"Google\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"모델 설정: {model_info['full_name']} - {model_info['description']}\\\\\\\")\\\\n            self.model = model_info\\\\n\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API 요청 파라미터를 생성합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        system_prompt = None\\\\n        contents = []\\\\n\\\\n        # 시스템 프롬프트와 유저 메시지 구분\\\\n        for message in messages:\\\\n            role = message.get(\\\\\\\"role\\\\\\\", \\\\\\\"\\\\\\\")\\\\n            content = message.get(\\\\\\\"content\\\\\\\", \\\\\\\"\\\\\\\")\\\\n\\\\n            if role == \\\\\\\"system\\\\\\\":\\\\n                system_prompt = content\\\\n            elif role == \\\\\\\"user\\\\\\\":\\\\n                contents.append(content)\\\\n\\\\n        # 온도 설정 (기본값: 0.0)\\\\n        temperature = self.model[\\\\\\\"params\\\\\\\"].get(\\\\\\\"temperature\\\\\\\", 0.0)\\\\n\\\\n        # config 생성\\\\n        generation_config = types.GenerateContentConfig(\\\\n            temperature=temperature,\\\\n            system_instruction=system_prompt,\\\\n            response_mime_type=\\\\\\\"application/json\\\\\\\",\\\\n            response_schema=StructuredReviewResponse,\\\\n        )\\\\n\\\\n        # Gemini API 요청 파라미터 생성\\\\n        params = {\\\\n            \\\\\\\"model\\\\\\\": self.model[\\\\\\\"full_name\\\\\\\"],\\\\n            \\\\\\\"contents\\\\\\\": \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\".join(contents) if contents else \\\\\\\"\\\\\\\",\\\\n            \\\\\\\"config\\\\\\\": generation_config,\\\\n        }\\\\n\\\\n        return params\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import ReviewResponse, StructuredReviewResponse\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token.models import StructuredReviewResponse\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Google Gemini API를 사용하여 코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 베이스 클래스의 요청 준비 메소드 활용\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # Google Gemini 클라이언트 초기화\\\\n            client = genai.Client(api_key=self.api_key)\\\\n\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # Gemini API 요청 송신\\\\n            response = client.models.generate_content(**params)\\\\n\\\\n            # 구조화된 응답 생성\\\\n            # 텍스트 응답을 StructuredReviewResponse 형식으로 파싱\\\\n            try:\\\\n                response_text = response.text\\\\n                if response_text is None:\\\\n                    return ReviewResponse.get_empty_response()\\\\n\\\\n                structured_response = StructuredReviewResponse.model_validate_json(\\\\n                    response_text\\\\n                )\\\\n\\\\n                # 원본 응답 저장\\\\n                self.save_raw_response(structured_response)\\\\n\\\\n                # 응답 처리\\\\n                if not structured_response:\\\\n                    return ReviewResponse.get_empty_response()\\\\n\\\\n                return ReviewResponse.from_structured_response(structured_response)\\\\n\\\\n            except Exception as parse_error:\\\\n                print(f\\\\\\\"응답 파싱 오류: {str(parse_error)}\\\\\\\")\\\\n                print(f\\\\\\\"원본 응답: {response.text}\\\\\\\")\\\\n                return ReviewResponse.get_error_response(parse_error)\\\\n\\\\n        except Exception as e:\\\\n            return ReviewResponse.get_error_response(e)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 91}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .prompt_utils import save_prompt\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=0\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 3}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"오류: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompt_utils.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트와 관련된 유틸리티 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport json\\\\nfrom datetime import datetime\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_prompt_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_prompt_{timestamp}_{model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(messages, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_review_prompt_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n```\\\", \\\"line_number\\\": 19}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import get_api_key\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 11}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 188, \"file\": \"reviewer/cli.py\", \"description\": \"정보성 메시지를 표준 출력(print) 대신 로거(logger.info)를 사용하여 출력하도록 변경되었습니다. 이는 애플리케이션의 로깅 전략을 일관성 있게 만들고, 로그 레벨 설정에 따라 메시지 출력을 제어할 수 있게 합니다.\", \"suggestion\": \"애플리케이션 내에서 사용자에게 직접 보여줘야 하는 최종 결과나 중요한 안내 메시지를 제외하고는, 디버깅, 정보, 경고, 오류 등 다양한 수준의 메시지에 대해 로거 사용을 일관되게 유지하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    print(f\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\")\\n```\", \"improved_code\": \"```python\\n    logger.info(f\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\")\\n```\"}, {\"type\": \"design\", \"line_number\": 29, \"file\": \"reviewer/src/llm_gateway/base_gateway.py\", \"description\": \"순환 참조 문제를 해결하기 위해 `LOG_DIR` 변수를 함수 `get_log_dir`로 변경하고 `reviewer.src.config` 모듈을 함수 내부에서 지연 임포트하도록 수정되었습니다. 이는 순환 참조를 깨는 효과적인 방법 중 하나이지만, 코드의 가독성을 약간 저해하고 의존성이 명시적이지 않게 될 수 있습니다.\", \"suggestion\": \"가능하다면 모듈 구조를 재설계하여 순환 참조 자체를 발생시키지 않는 것이 가장 좋습니다. 예를 들어, 공유 유틸리티 함수나 설정 로딩 로직을 별도의 저수준 모듈로 분리하는 것을 고려해 볼 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n# 로그 디렉토리 설정 및 생성\\nLOG_DIR = get_default_raw_log_dir()\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\n```\", \"improved_code\": \"```python\\n# 로거 인스턴스 생성\\nlogger = get_logger(__name__)\\n\\n\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\ndef get_log_dir() -> Path:\\n    \\\"\\\"\\\"로그 디렉토리를 가져옵니다.\\\"\\\"\\\"\\n    from reviewer.src.config import get_default_raw_log_dir\\n\\n    log_dir = get_default_raw_log_dir()\\n    log_dir.mkdir(exist_ok=True, parents=True)\\n    return log_dir\\n```\"}, {\"type\": \"design\", \"line_number\": 150, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`TokenUtils` 클래스에 모델별 컨텍스트 제한이 하드코딩되어 있습니다. 새로운 모델이 추가되거나 기존 모델의 제한이 변경될 경우 코드를 직접 수정해야 하므로 유지보수가 어렵습니다.\", \"suggestion\": \"모델 정보(컨텍스트 제한, 가격 등)를 `available_models` 모듈이나 별도의 설정 파일/데이터 구조에서 관리하도록 변경하세요. `TokenUtils`는 해당 정보를 조회하여 사용하는 방식으로 개선할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n        context_limits = {\\n            \\\"gpt-4o\\\": 128000,\\n            \\\"o3-mini\\\": 200000,\\n            \\\"o4-mini\\\": 200000,\\n            \\\"gpt-4.1\\\": 1047576,\\n            \\\"claude-3-7-sonnet-20250219\\\": 200000,\\n            \\\"claude-3-5-sonnet-20240620\\\": 180000,\\n            \\\"gemini-1.5-pro-001\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\n            \\\"gemini-1.5-flash-001\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\n        }\\n```\", \"improved_code\": \"```python\\n        # 모델 정보는 available_models 모듈 등 중앙 집중식으로 관리하는 것이 좋습니다.\\n        # 예시: from reviewer.src.available_models import get_model_info\\n        # model_info = get_model_info(model)\\n        # return model_info.get(\\\"context_limit\\\", 128000)\\n\\n        context_limits = {\\n            \\\"gpt-4o\\\": 128000,\\n            \\\"o3-mini\\\": 200000,\\n            \\\"o4-mini\\\": 200000,\\n            \\\"gpt-4.1\\\": 1047576,\\n            \\\"claude-3-7-sonnet-20250219\\\": 200000,\\n            \\\"claude-3-5-sonnet-20240620\\\": 180000,\\n            \\\"gemini-1.5-pro-001\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\n            \\\"gemini-1.5-flash-001\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\n        }\\n\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\n        if \\\"claude\\\" in model.lower() and model not in context_limits:\\n            return 180000  # Claude 기본 컨텍스트 제한\\n\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\n        if \\\"gemini\\\" in model.lower() and model not in context_limits:\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\n\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\n```\"}, {\"type\": \"refactoring\", \"line_number\": 540, \"file\": \"reviewer/cli.py\", \"description\": \"`main` 함수에 로깅 설정 초기화가 추가되었고, 전체 실행 로직이 `try...except` 블록으로 감싸져 `KeyboardInterrupt` 및 일반 `Exception`에 대한 예외 처리가 강화되었습니다. 이는 CLI 애플리케이션의 안정성을 높입니다.\", \"suggestion\": \"예외 발생 시 사용자에게 더 유용한 정보를 제공하거나, 특정 예외 유형에 따라 다른 처리를 하도록 예외 처리 로직을 세분화할 수 있습니다. 예를 들어, 특정 설정 오류나 네트워크 오류에 대해 더 구체적인 안내 메시지를 출력하는 것을 고려해 보세요.\", \"severity\": \"info\", \"original_code\": \"```python\\n    \\\"\\\"\\\"메인 함수\\\"\\\"\\\"\\n    args: argparse.Namespace = parse_args()\\n\\n    if args.command == \\\"config\\\":\\n        handle_config_command(args)\\n    elif args.command == \\\"review\\\":\\n        review_code(args)\\n    elif args.command == \\\"results\\\":\\n        handle_results_command(args)\\n    elif args.command == \\\"view\\\":\\n        handle_view_command(args)\\n    else:\\n        print(f\\\"알 수 없는 명령어: {args.command}\\\")\\n```\", \"improved_code\": \"```python\\n    \\\"\\\"\\\"애플리케이션의 메인 진입점.\\\"\\\"\\\"\\n    # 로깅 설정 초기화\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\n\\n    try:\\n        args = parse_args()\\n\\n        if args.command == \\\"review\\\":\\n            review_code(args)\\n        elif args.command == \\\"config\\\":\\n            handle_config_command(args)\\n        elif args.command == \\\"results\\\":\\n            handle_results_command(args)\\n        elif args.command == \\\"view\\\":\\n            handle_view_command(args)\\n    except KeyboardInterrupt:\\n        logger.info(\\\"\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\")\\n        sys.exit(1)\\n    except Exception as e:\\n        logger.error(f\\\"오류 발생: {str(e)}\\\", exc_info=True)\\n        sys.exit(1)\\n```\"}, {\"type\": \"refactoring\", \"line_number\": 241, \"file\": \"reviewer/src/llm_gateway/base_gateway.py\", \"description\": \"`review_code` 메서드에서 `instructor`와 `genai` 클라이언트를 구분하여 응답을 처리하도록 수정되었습니다. 이는 Google Gemini API 통합을 위해 필요했지만, 베이스 클래스가 특정 구현체에 의존하게 되는 결과를 낳았습니다.\", \"suggestion\": \"게이트웨이 패턴의 목적에 맞게, 베이스 클래스는 가능한 추상적인 인터페이스만 정의하고 실제 API 호출 및 응답 파싱 로직은 각 프로바이더별 하위 클래스(`OpenAIGateway`, `GoogleGateway` 등)에서 구현하도록 리팩토링하는 것을 고려해 볼 수 있습니다. 베이스 클래스는 `_call_api`와 같은 추상 메서드를 정의하고, 하위 클래스가 이를 구현하며, `review_code`는 이 추상 메서드를 호출하는 방식입니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n            completion = client.chat.completions.create(\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\n            )\\n```\", \"improved_code\": \"```python\\n            if isinstance(client, instructor.Instructor):\\n                completion = client.chat.completions.create(\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\n                )\\n            elif isinstance(client, genai.Client):\\n                try:\\n                    response = client.models.generate_content(**params)\\n                    response_text = response.text\\n                    if response_text is None:\\n                        return ReviewResponse.get_empty_response()\\n\\n                    completion = StructuredReviewResponse.model_validate_json(\\n                        response_text\\n                    )\\n                except Exception as parse_error:\\n                    logger.error(f\\\"응답 파싱 오류: {str(parse_error)}\\\")\\n                    logger.error(\\n                        f\\\"원본 응답: {response.text if 'response' in locals() else '없음'}\\\"\\n                    )\\n                    return ReviewResponse.get_error_response(parse_error)\\n```\"}], \"summary\": \"이 커밋은 애플리케이션 전반에 걸쳐 로깅 시스템을 도입하고, 오류 처리를 개선하며, Google Gemini 모델 지원을 통합하고, 모듈 간 순환 참조 문제를 해결하기 위한 리팩토링을 포함합니다. CLI 명령어 처리 로직과 설정 관리, 결과 관리 기능도 일부 개선되었습니다.\", \"score\": 7.5, \"recommendations\": [\"모듈 구조를 재설계하여 지연 임포트 없이 순환 참조를 해결합니다.\", \"`TokenUtils`에 하드코딩된 모델별 정보(컨텍스트 제한, 가격)를 외부 설정이나 `available_models` 모듈에서 관리하도록 변경합니다.\", \"게이트웨이 베이스 클래스가 특정 LLM 클라이언트 구현체에 의존하지 않도록 추상화 수준을 높입니다.\", \"CLI의 `config_api_key`와 같은 복잡한 함수를 더 작은 단위로 분리하여 가독성과 유지보수성을 높입니다.\", \"로깅 메시지에 더 많은 컨텍스트 정보를 포함하여 디버깅 효율성을 높입니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기 - 지연 임포트\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\n```\\\", \\\"line_number\\\": 22}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 31}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 198}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n    # LLM 게이트웨이 가져오기\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # LLM 게이트웨이 가져오기 - 지연 임포트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n```\\\", \\\"line_number\\\": 540}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키 (키가 없는 경우 ValueError 발생)\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        return config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n\\\\n    raise ValueError(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_raw_log_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n# 로그 디렉토리 설정 및 생성\\\\nLOG_DIR = get_default_raw_log_dir()\\\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n```\\\", \\\"line_number\\\": 29}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 128}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n            raw_response_file = LOG_DIR / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"13\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"14\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"15\\\", \\\"original_code\\\": \\\"```python\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n```\\\", \\\"line_number\\\": 241}, {\\\"hunk_idx\\\": \\\"16\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .prompt_utils import save_prompt\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=0\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 3}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"오류: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompt_utils.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트와 관련된 유틸리티 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport json\\\\nfrom datetime import datetime\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_prompt_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_prompt_{timestamp}_{model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(messages, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_review_prompt_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n```\\\", \\\"line_number\\\": 19}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\n# 지연 임포트를 위해 제거\\\\n# from reviewer.src.llm_gateway import get_api_key\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import get_api_key\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 지연 임포트를 위해 제거\\\\n# from reviewer.src.llm_gateway import get_api_key\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 241, \"file\": \"reviewer/src/llm_gateway/base_gateway.py\", \"description\": \"BaseGateway의 `review_code` 메서드에서 LLM 클라이언트가 `instructor.Instructor` 인스턴스인 경우에만 API 호출(`client.chat.completions.create`)이 수행됩니다. 만약 클라이언트가 `genai.Client`와 같은 다른 타입이라면 API 호출이 완전히 건너뛰어지고 빈 응답이 반환됩니다. 이는 `instructor`를 사용하지 않는 모델에 대해 리뷰 기능이 제대로 작동하지 않게 만듭니다.\", \"suggestion\": \"`isinstance` 체크 후, 각 클라이언트 타입에 맞는 API 호출 로직을 추가해야 합니다. 예를 들어 `genai.Client`의 경우 `client.generate_content`와 같은 메서드를 사용해야 할 수 있습니다.\", \"severity\": \"error\", \"original_code\": \"```python\\n            if isinstance(client, instructor.Instructor):\\n                completion = client.chat.completions.create(\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\n                )\\n\\n            # 원본 응답 저장\\n            self.save_raw_response(completion)\\n\\n            # 응답 처리\\n            if not completion:\\n                return ReviewResponse.get_empty_response()\\n\\n            return ReviewResponse.from_structured_response(completion)\\n```\", \"improved_code\": \"```python\\n            completion = None\\n            if isinstance(client, instructor.Instructor):\\n                completion = client.chat.completions.create(\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\n                )\\n            # TODO: Add handling for other client types (e.g., genai.Client)\\n            # elif isinstance(client, genai.Client):\\n            #     # Call appropriate method for genai.Client, potentially needing different params\\n            #     # completion = client.generate_content(...) # Example\\n            #     pass # Placeholder - needs actual implementation\\n\\n            # 원본 응답 저장 (completion이 None이 아닐 경우에만)\\n            if completion:\\n                self.save_raw_response(completion)\\n\\n            # 응답 처리\\n            if not completion:\\n                logger.warning(\\\"LLM API 호출 결과가 없습니다 (클라이언트 타입 미지원 또는 오류).\\\")\\n                return ReviewResponse.get_empty_response()\\n\\n            return ReviewResponse.from_structured_response(completion)\\n```\"}, {\"type\": \"bug\", \"line_number\": 60, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`TokenUtils.count_tokens` 메서드에서 Gemini 모델의 토큰 수를 계산할 때, `client.models.count_tokens`의 `contents` 파라미터에 원본 문자열을 직접 전달하고 있습니다. Gemini API의 `count_tokens`는 일반적으로 `glm.Content` 객체의 리스트를 기대합니다. 또한 `model` 파라미터도 `models/model-name` 형식의 전체 모델 이름을 사용하는 것이 더 안전합니다.\", \"suggestion\": \"텍스트를 `google.generativeai.types.glm.Content` 객체로 변환하여 `contents` 파라미터에 전달하고, `model` 파라미터에 전체 모델 이름을 사용하도록 수정해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n                # 토큰 수 계산 (최신 API 사용)\\n                response = client.models.count_tokens(model=model_name, contents=text)\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\n                return (\\n                    response.total_tokens\\n                    if response\\n                    and hasattr(response, \\\"total_tokens\\\")\\n                    and response.total_tokens is not None\\n                    else 0\\n                )\\n```\", \"improved_code\": \"```python\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\n                from reviewer.src.config import get_api_key\\n                import google.generativeai as genai # Import genai here for Content object\\n\\n                api_key = get_api_key(\\\"google\\\")\\n\\n                # Client 객체 생성\\n                client = genai.Client(api_key=api_key)\\n\\n                # 사용 가능한 모델명으로 매핑 및 전체 이름 사용\\n                full_model_name = f\\\"models/{model.lower()}\\\" # Use full model name format\\n\\n                # 텍스트를 Content 객체 리스트로 변환\\n                contents = [genai.types.glm.Content(parts=[genai.types.glm.Part(text=text)])]\\n\\n                # 토큰 수 계산\\n                response = client.models.count_tokens(model=full_model_name, contents=contents)\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\n                return (\\n                    response.total_tokens\\n                    if response\\n                    and hasattr(response, \\\"total_tokens\\\")\\n                    and response.total_tokens is not None\\n                    else 0\\n                )\\n```\"}, {\"type\": \"style\", \"line_number\": 34, \"file\": \"reviewer/cli.py\", \"description\": \"로거 인스턴스 생성 주석이 실제 로거 인스턴스 생성 코드 라인 뒤에 위치하여 가독성을 해칠 수 있습니다.\", \"suggestion\": \"주석을 해당 코드 라인 위로 이동시켜 어떤 코드를 설명하는지 명확히 합니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n# 로거 인스턴스 생성\\nlogger = get_logger(__name__)\\n\\n\\ndef parse_args() -> argparse.Namespace:\\n```\", \"improved_code\": \"```python\\n# 로거 인스턴스 생성\\nlogger = get_logger(__name__)\\n\\ndef parse_args() -> argparse.Namespace:\\n```\"}], \"summary\": \"이 변경사항들은 주로 로깅 시스템을 개선하고, 오류 처리를 강화하며, 잠재적인 순환 참조 문제를 해결하기 위해 지연 임포트(lazy import) 전략을 도입하는 데 중점을 두고 있습니다. `print` 문을 `logger` 호출로 대체하여 일관된 로깅을 구현했고, `try...except` 블록과 `exc_info=True`를 사용하여 예외 발생 시 더 많은 정보를 기록하도록 했습니다. 또한, 여러 모듈 간의 복잡한 의존성을 관리하기 위해 `__init__.py` 파일과 특정 함수 내에서 필요한 모듈을 지연 로딩하는 방식을 사용했습니다.\", \"score\": 8.0, \"recommendations\": [\"LLM 게이트웨이의 `review_code` 메서드에서 `instructor.Instructor` 외의 다른 클라이언트 타입(예: `genai.Client`)에 대한 API 호출 로직을 구현하여 모든 지원 모델이 정상적으로 작동하도록 합니다.\", \"Gemini 모델의 토큰 계산 시 `client.models.count_tokens`에 전달하는 `contents` 파라미터 형식을 API 문서에 맞게 `glm.Content` 객체 리스트로 수정하고, 모델 이름 형식을 `models/model-name`으로 통일합니다.\", \"코드 전반에 걸쳐 사용자에게 보여주는 메시지와 내부 로깅 메시지를 구분하는 기준을 명확히 하고 일관성을 유지합니다. 현재는 `print`와 `logger`가 혼용되어 있습니다.\", \"가능한 경우 일반 `Exception` 대신 더 구체적인 예외 타입을 사용하여 오류 처리의 정확성을 높입니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기 - 지연 임포트\\\\n    from reviewer.src.llm_gateway import get_GatewayFactory\\\\n\\\\n    GatewayFactory = get_GatewayFactory()\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\n```\\\", \\\"line_number\\\": 21}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 30}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 197}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n    # LLM 게이트웨이 가져오기\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # LLM 게이트웨이 가져오기 - 지연 임포트\\\\n    from reviewer.src.llm_gateway import get_GatewayFactory\\\\n\\\\n    GatewayFactory = get_GatewayFactory()\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n```\\\", \\\"line_number\\\": 542}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/config.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n설정 관리 모듈\\\\n\\\\n이 모듈은 API 키 및 기타 설정을 관리합니다.\\\\n설정은 사용자 홈 디렉토리의 .reviewer/config.ini 파일에 저장됩니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport configparser\\\\nimport os\\\\nimport sys\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n# 설정 파일 경로\\\\nMAC_CONFIG_DIR = Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\"\\\\nMAC_CONFIG_FILE = MAC_CONFIG_DIR / \\\\\\\"config.ini\\\\\\\"\\\\n\\\\n\\\\ndef ensure_config_dir() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 디렉토리가 존재하는지 확인하고, 없으면 생성합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    MAC_CONFIG_DIR.mkdir(exist_ok=True, parents=True)\\\\n\\\\n\\\\ndef load_config() -> configparser.ConfigParser:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 파일을 로드합니다. 파일이 없으면 기본 설정을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = configparser.ConfigParser()\\\\n\\\\n    if MAC_CONFIG_FILE.exists():\\\\n        config.read(MAC_CONFIG_FILE)\\\\n\\\\n    # 기본 섹션이 없으면 추가\\\\n    if \\\\\\\"credentials\\\\\\\" not in config:\\\\n        config[\\\\\\\"credentials\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"paths\\\\\\\" not in config:\\\\n        config[\\\\\\\"paths\\\\\\\"] = {}\\\\n\\\\n    if \\\\\\\"default\\\\\\\" not in config:\\\\n        config[\\\\\\\"default\\\\\\\"] = {}\\\\n\\\\n    return config\\\\n\\\\n\\\\ndef save_config(config: configparser.ConfigParser) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정을 파일에 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    ensure_config_dir()\\\\n    with open(MAC_CONFIG_FILE, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        config.write(f)\\\\n\\\\n    # 파일 권한 설정 (Linux/macOS에서만 작동)\\\\n    if sys.platform != \\\\\\\"win32\\\\\\\":\\\\n        os.chmod(MAC_CONFIG_FILE, 0o600)  # 소유자만 읽기/쓰기 가능\\\\n\\\\n\\\\ndef get_api_key(provider: str = \\\\\\\"openai\\\\\\\") -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 가져옵니다.\\\\n\\\\n    API 키를 설정 파일에서 찾습니다.\\\\n\\\\n    Args:\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        API 키 (키가 없는 경우 ValueError 발생)\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n    if provider in config[\\\\\\\"credentials\\\\\\\"]:\\\\n        return config[\\\\\\\"credentials\\\\\\\"][provider]\\\\n\\\\n    raise ValueError(f\\\\\\\"API 키가 없습니다: {provider}\\\\\\\")\\\\n\\\\n\\\\ndef set_api_key(api_key: str, provider: str = \\\\\\\"openai\\\\\\\") -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키를 설정 파일에 저장합니다.\\\\n\\\\n    Args:\\\\n        api_key: 저장할 API 키\\\\n        provider: API 제공자 ('openai', 'claude' 등)\\\\n\\\\n    Returns:\\\\n        bool: 저장 성공 여부\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"credentials\\\\\\\"][provider] = api_key\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_results_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_results_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"results\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_raw_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"원본 로그 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_raw_log_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_raw_log_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"logs\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"logs\\\\\\\"\\\\n\\\\n\\\\ndef set_default_results_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_results_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_request_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_request_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_request\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_request\\\\\\\"\\\\n\\\\n\\\\ndef set_default_review_request_dir(path: str) -> bool:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 저장 기본 디렉토리를 설정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        config = load_config()\\\\n        config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_request_dir\\\\\\\"] = path\\\\n        save_config(config)\\\\n        return True\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        return False\\\\n\\\\n\\\\ndef get_default_review_prompt_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 저장 기본 디렉토리를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    config = load_config()\\\\n\\\\n    # 설정 파일에 지정된 경우\\\\n    if \\\\\\\"default_review_prompt_dir\\\\\\\" in config[\\\\\\\"paths\\\\\\\"]:\\\\n        path = config[\\\\\\\"paths\\\\\\\"][\\\\\\\"default_review_prompt_dir\\\\\\\"]\\\\n        return Path(os.path.expanduser(path))\\\\n\\\\n    # 기본 위치\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":\\\\n        return MAC_CONFIG_DIR / \\\\\\\"review_prompt\\\\\\\"\\\\n    else:\\\\n        return Path.home() / \\\\\\\".local\\\\\\\" / \\\\\\\"share\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"review_prompt\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"API 키 저장 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"결과 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"리뷰 요청 디렉토리 설정 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_model_info\\\\nfrom reviewer.src.config import get_api_key\\\\n\\\\n\\\\n# 순환 참조 방지를 위해 지연 임포트 함수 정의\\\\ndef get_BaseGateway():\\\\n    from .base_gateway import BaseGateway\\\\n\\\\n    return BaseGateway\\\\n\\\\n\\\\ndef get_ClaudeGateway():\\\\n    from .claude_gateway import ClaudeGateway\\\\n\\\\n    return ClaudeGateway\\\\n\\\\n\\\\ndef get_GatewayFactory():\\\\n    from .gateway_factory import GatewayFactory\\\\n\\\\n    return GatewayFactory\\\\n\\\\n\\\\ndef get_OpenAIGateway():\\\\n    from .openai_gateway import OpenAIGateway\\\\n\\\\n    return OpenAIGateway\\\\n\\\\n\\\\n# 패키지 레벨에서 클래스를 바로 노출하는 대신 함수로 접근하도록 함\\\\n__all__ = [\\\\n    \\\\\\\"get_BaseGateway\\\\\\\",\\\\n    \\\\\\\"get_ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"get_OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"get_GatewayFactory\\\\\\\",\\\\n    \\\\\\\"get_api_key\\\\\\\",\\\\n    \\\\\\\"get_model_info\\\\\\\",\\\\n    \\\\\\\"get_default_model\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .base_gateway import BaseGateway\\\\nfrom .claude_gateway import ClaudeGateway\\\\nfrom .gateway_factory import GatewayFactory\\\\nfrom .openai_gateway import OpenAIGateway\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 5}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 순환 참조 방지를 위해 지연 임포트 함수 정의\\\\ndef get_BaseGateway():\\\\n    from .base_gateway import BaseGateway\\\\n\\\\n    return BaseGateway\\\\n\\\\n\\\\ndef get_ClaudeGateway():\\\\n    from .claude_gateway import ClaudeGateway\\\\n\\\\n    return ClaudeGateway\\\\n\\\\n\\\\ndef get_GatewayFactory():\\\\n    from .gateway_factory import GatewayFactory\\\\n\\\\n    return GatewayFactory\\\\n\\\\n\\\\ndef get_OpenAIGateway():\\\\n    from .openai_gateway import OpenAIGateway\\\\n\\\\n    return OpenAIGateway\\\\n\\\\n\\\\n# 패키지 레벨에서 클래스를 바로 노출하는 대신 함수로 접근하도록 함\\\\n```\\\", \\\"line_number\\\": 7}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    \\\\\\\"BaseGateway\\\\\\\",\\\\n    \\\\\\\"ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"GatewayFactory\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"get_BaseGateway\\\\\\\",\\\\n    \\\\\\\"get_ClaudeGateway\\\\\\\",\\\\n    \\\\\\\"get_OpenAIGateway\\\\\\\",\\\\n    \\\\\\\"get_GatewayFactory\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 34}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/base_gateway.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스 정의\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom __future__ import annotations\\\\n\\\\nimport abc\\\\nimport json\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\nfrom reviewer.src.available_models import ModelInfoDict\\\\nfrom reviewer.src.exceptions.context_limit_exceeded_error import (\\\\n    ContextLimitExceededError,\\\\n)\\\\nfrom reviewer.src.utils import save_prompt\\\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\\\nfrom reviewer.src.utils.logging import get_logger\\\\nfrom reviewer.src.utils.prompts.models import ReviewPrompt, ReviewPromptWithFileContent\\\\nfrom reviewer.src.utils.token.models import (\\\\n    DiffCheckResult,\\\\n    EstimatedCost,\\\\n    ReviewResponse,\\\\n    StructuredReviewResponse,\\\\n)\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n\\\\n\\\\nclass BaseGateway(abc.ABC):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이의 추상 기본 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Args:\\\\n            model_info: 모델 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.model: ModelInfoDict\\\\n        self._set_model(model_info)\\\\n        self.api_key = self._load_api_key()\\\\n\\\\n    @abc.abstractmethod\\\\n    def _load_api_key(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Provider에 맞는 API 키를 로드합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _set_model(self, model_info: ModelInfoDict) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"사용할 모델을 설정하고 유효성을 검사합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    @abc.abstractmethod\\\\n    def _create_request_params(self, messages: list[dict[str, Any]]) -> dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        각 프로바이더별 API 요청 파라미터를 생성합니다.\\\\n        각 하위 클래스는 해당 LLM 프로바이더에 맞는 파라미터를 구성해야 합니다.\\\\n\\\\n        Args:\\\\n            messages: 메시지 리스트\\\\n\\\\n        Returns:\\\\n            dict: API 요청 파라미터\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        raise NotImplementedError\\\\n\\\\n    def get_model_name(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 전체 이름을 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"full_name\\\\\\\"]\\\\n\\\\n    def get_provider(self) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 설정된 모델의 프로바이더를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.model[\\\\\\\"provider\\\\\\\"]\\\\n\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"현재 프로바이더에 맞는 LLM 클라이언트를 생성합니다.\\\\n\\\\n        Returns:\\\\n            Instructor: 구조화된 응답을 지원하는 LLM 클라이언트\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return LLMClientFactory.create_client(self.get_provider(), self.api_key)\\\\n\\\\n    def estimate_review_cost(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청의 예상 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체 (ReviewPrompt 또는 ReviewPromptWithFileContent)\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 프롬프트 생성\\\\n        combined_text = \\\\\\\"\\\\\\\"\\\\n        combined_text += review_prompt.system_prompt.content + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n        for user_prompt in review_prompt.user_prompts:\\\\n            combined_text += user_prompt.to_message()[\\\\\\\"content\\\\\\\"] + \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        return TokenUtils.estimate_cost(combined_text, model_name)\\\\n\\\\n    def check_diff_size(self, diff_content: str) -> DiffCheckResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Diff 내용의 크기를 확인하고 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            diff_content: diff 내용\\\\n\\\\n        Returns:\\\\n            DiffCheckResult: 크기 및 비용 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n        # 토큰 수와 비용 계산\\\\n        model_name = self.get_model_name()\\\\n        cost_info = TokenUtils.estimate_cost(diff_content, model_name)\\\\n\\\\n        # DiffCheckResult 객체 생성하여 반환\\\\n        return DiffCheckResult(\\\\n            model=cost_info.model,\\\\n            input_tokens=cost_info.input_tokens,\\\\n            input_cost_usd=cost_info.input_cost_usd,\\\\n            estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n            estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n            estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n            within_context_limit=cost_info.within_context_limit,\\\\n            character_count=len(diff_content),\\\\n            line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n        )\\\\n\\\\n    def save_raw_response(self, completion: StructuredReviewResponse) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"LLM API 원본 응답을 저장합니다.\\\\n\\\\n        Args:\\\\n            completion: API 응답 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            provider = self.get_provider()\\\\n            current_time = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n\\\\n            with open(raw_response_file, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                f.write(f\\\\\\\"# {provider.capitalize()} 원본 응답\\\\\\\\n\\\\\\\\n\\\\\\\")\\\\n                try:\\\\n                    raw_response = completion.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n                    f.write(\\\\n                        json.dumps(\\\\n                            raw_response, indent=2, default=str, ensure_ascii=False\\\\n                        )\\\\n                    )\\\\n                except Exception:\\\\n                    f.write(str(completion))\\\\n            logger.info(\\\\n                f\\\\\\\"{provider.capitalize()} 원본 응답을 {raw_response_file}에 저장했습니다.\\\\\\\"\\\\n            )\\\\n        except Exception as e:\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n\\\\n    def prepare_review_request(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 전 비용 추정 및 메시지 준비를 수행합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            None\\\\n\\\\n        Raises:\\\\n            ContextLimitExceededError: 컨텍스트 제한을 초과한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        estimated_cost = self.estimate_review_cost(review_prompt)\\\\n\\\\n        if not estimated_cost.within_context_limit:\\\\n            raise ContextLimitExceededError(\\\\n                input_tokens=estimated_cost.input_tokens,\\\\n                context_limit=self.model.get(\\\\\\\"context_limit\\\\\\\"),\\\\n            )\\\\n\\\\n        logger.info(\\\\n            f\\\\\\\"모델: {estimated_cost.model}, \\\\\\\"\\\\n            f\\\\\\\"토큰 수: {estimated_cost.input_tokens}, \\\\\\\"\\\\n            f\\\\\\\"비용: {estimated_cost.estimated_total_cost_usd} USD\\\\\\\"\\\\n        )\\\\n\\\\n        # 프롬프트 저장\\\\n        save_prompt(review_prompt.to_messages(), self.get_model_name())\\\\n\\\\n    def review_code(\\\\n        self, review_prompt: ReviewPrompt | ReviewPromptWithFileContent\\\\n    ) -> ReviewResponse:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"코드를 리뷰합니다.\\\\n\\\\n        Args:\\\\n            review_prompt: 리뷰용 프롬프트 객체\\\\n\\\\n        Returns:\\\\n            ReviewResponse: 리뷰 결과\\\\n\\\\n        Raises:\\\\n            Exception: API 호출 중 오류가 발생한 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 요청 준비\\\\n        self.prepare_review_request(review_prompt)\\\\n        messages = review_prompt.to_messages()\\\\n\\\\n        try:\\\\n            # 클라이언트 초기화\\\\n            client = self._create_client()\\\\n\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n\\\\n            # API 요청 파라미터 생성\\\\n            params = self._create_request_params(messages)\\\\n\\\\n            # API 요청 송신\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n\\\\n            # 원본 응답 저장\\\\n            self.save_raw_response(completion)\\\\n\\\\n            # 응답 처리\\\\n            if not completion:\\\\n                return ReviewResponse.get_empty_response()\\\\n\\\\n            return ReviewResponse.from_structured_response(completion)\\\\n\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n            return ReviewResponse.get_error_response(e)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_raw_log_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.token import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n# 로그 디렉토리 설정 및 생성\\\\nLOG_DIR = get_default_raw_log_dir()\\\\nLOG_DIR.mkdir(exist_ok=True, parents=True)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\n# 로그 디렉토리 설정 및 생성 - 지연 임포트로 변경\\\\ndef get_log_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from reviewer.src.config import get_default_raw_log_dir\\\\n\\\\n    log_dir = get_default_raw_log_dir()\\\\n    log_dir.mkdir(exist_ok=True, parents=True)\\\\n    return log_dir\\\\n```\\\", \\\"line_number\\\": 29}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"original_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def _create_client(self) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 106}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # TokenUtils 지연 임포트\\\\n        from reviewer.src.utils.token import TokenUtils\\\\n\\\\n```\\\", \\\"line_number\\\": 128}, {\\\"hunk_idx\\\": \\\"10\\\", \\\"original_code\\\": \\\"```python\\\\n            raw_response_file = LOG_DIR / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            log_dir = get_log_dir()\\\\n            raw_response_file = log_dir / f\\\\\\\"{provider}-raw-response-{current_time}.json\\\\\\\"\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"11\\\", \\\"original_code\\\": \\\"```python\\\\n            print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"12\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(\\\\n                f\\\\\\\"{provider.capitalize()} 응답 저장 중 오류 발생: {str(e)}\\\\\\\",\\\\n                exc_info=True,\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"13\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.info(\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"14\\\", \\\"original_code\\\": \\\"```python\\\\n            print(f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.info(\\\\n                f\\\\\\\"API 요청: 모델={self.get_model_name()}, 메시지 수={len(messages)}\\\\\\\"\\\\n            )\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"15\\\", \\\"original_code\\\": \\\"```python\\\\n            completion = client.chat.completions.create(\\\\n                response_model=StructuredReviewResponse, max_retries=2, **params\\\\n            )\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            if isinstance(client, instructor.Instructor):\\\\n                completion = client.chat.completions.create(\\\\n                    response_model=StructuredReviewResponse, max_retries=2, **params\\\\n                )\\\\n```\\\", \\\"line_number\\\": 241}, {\\\"hunk_idx\\\": \\\"16\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            logger.error(f\\\\\\\"리뷰 요청 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/__init__.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"유틸리티 패키지\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom .git_utils import run_git_diff\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n\\\\n__all__ = [\\\\\\\"run_git_diff\\\\\\\", \\\\\\\"save_prompt\\\\\\\"]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .prompt_utils import save_prompt\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# prompt_utils를 직접 임포트하지 않고 상대 경로로 참조하도록 함수 정의\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    이 함수는 순환 참조를 방지하기 위해 지연 임포트를 사용합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    from .prompt_utils import save_prompt as _save_prompt\\\\n\\\\n    return _save_prompt(messages, model)\\\\n\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/git_utils.py\\\", \\\"file_content\\\": \\\"import subprocess\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef run_git_diff(repo_path: str, commit_range: str | None = None) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지정된 저장소에서 git diff 명령을 실행합니다.\\\\n\\\\n    Args:\\\\n        repo_path (str): Git 저장소 경로\\\\n        commit_range (str | None): 비교할 커밋 범위 (예: \\\\\\\"HEAD~1..HEAD\\\\\\\")\\\\n\\\\n    Returns:\\\\n        str: git diff 명령의 출력\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    cmd = [\\\\\\\"git\\\\\\\", \\\\\\\"-C\\\\\\\", repo_path, \\\\\\\"diff\\\\\\\", \\\\\\\"--unified=0\\\\\\\"]\\\\n\\\\n    try:\\\\n        if commit_range and commit_range.startswith(\\\\\\\"-\\\\\\\"):\\\\n            raise ValueError(\\\\\\\"Invalid commit_range: cannot start with '-'\\\\\\\")\\\\n        if commit_range:\\\\n            cmd.append(commit_range)\\\\n        process_result = subprocess.run(\\\\n            cmd, capture_output=True, text=True, check=True, encoding=\\\\\\\"utf-8\\\\\\\"\\\\n        )\\\\n        return process_result.stdout\\\\n    except subprocess.CalledProcessError as e:\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n    except ValueError as e:\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 3}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"Git diff 명령 실행 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n        print(f\\\\\\\"오류: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        logger.error(f\\\\\\\"오류: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/prompt_utils.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"프롬프트와 관련된 유틸리티 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport json\\\\nfrom datetime import datetime\\\\n\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef save_prompt(messages: list, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트를 파일로 저장합니다.\\\\n\\\\n    Args:\\\\n        messages: 저장할 메시지 목록\\\\n        model: 모델 이름\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_prompt_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_prompt_{timestamp}_{model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(messages, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.config import get_default_review_prompt_dir\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    # 지연 임포트(lazy import)로 순환 참조 방지\\\\n    from reviewer.src.config import get_default_review_prompt_dir\\\\n\\\\n```\\\", \\\"line_number\\\": 19}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n    print(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    logger.info(f\\\\\\\"프롬프트를 {save_path}에 저장했습니다.\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\n# 지연 임포트를 위해 제거\\\\n# from reviewer.src.llm_gateway import get_api_key\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom reviewer.src.llm_gateway import get_api_key\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 지연 임포트를 위해 제거\\\\n# from reviewer.src.llm_gateway import get_api_key\\\\nfrom reviewer.src.utils.logging import get_logger\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                # API 키 가져오기 (기존 메커니즘 사용) - 지연 임포트\\\\n                from reviewer.src.config import get_api_key\\\\n\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n                logger.error(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\", exc_info=True)\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 1, \"file\": \"legacy_tests/test_diff_parser.py\", \"description\": \"테스트 파일에서 open() 호출 시 명시적 인코딩이 지정되지 않아 플랫폼(Windows, macOS, Linux) 간 기본 인코딩 차이로 테스트가 불안정해질 수 있습니다.\", \"suggestion\": \"open()에 encoding=\\\"utf-8\\\" 파라미터를 추가하거나 pathlib.Path.read_text(encoding=\\\"utf-8\\\")를 사용해 일관된 인코딩을 지정하세요.\", \"severity\": \"info\", \"original_code\": \"with open(os.path.join(\\\"tests/sample_data\\\", filename)) as f:\", \"improved_code\": \"with open(os.path.join(\\\"tests/sample_data\\\", filename), encoding=\\\"utf-8\\\") as f:\"}, {\"type\": \"버그\", \"line_number\": 113, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"processed_diff가 DiffResult 타입이 아닐 경우 .files 또는 .hunks 속성 참조 시 AttributeError가 발생해 메시지 생성 로직이 중단될 수 있습니다.\", \"suggestion\": \"원래대로 isinstance(review_request.processed_diff, DiffResult) 체크를 복원하거나, processed_diff가 올바른 타입인지 검증하는 로직을 추가해 런타임 오류를 방지하세요.\", \"severity\": \"error\", \"original_code\": \"for file in review_request.processed_diff.files:\", \"improved_code\": \"if isinstance(review_request.processed_diff, DiffResult):\\n    for file in review_request.processed_diff.files:\\n        # 이하 동일\"}, {\"type\": \"버그\", \"line_number\": 4, \"file\": \"reviewer/src/utils/prompts/prompt_generator.py\", \"description\": \"json.dumps를 사용하는데 json 모듈이 import되어 있지 않으면 NameError가 발생할 수 있습니다.\", \"suggestion\": \"파일 상단에 import json 구문을 추가해 json 모듈을 명시적으로 임포트하세요.\", \"severity\": \"warning\", \"original_code\": \"from pathlib import Path\\n\\nfrom reviewer.src.utils.token.models import ReviewRequest\", \"improved_code\": \"import json\\nfrom pathlib import Path\\n\\nfrom reviewer.src.utils.token.models import ReviewRequest\"}], \"summary\": \"legacy_tests/test_diff_parser.py에서는 pytest 제거 및 open 모드 간소화가 이뤄졌으나 인코딩 지정이 누락되었습니다. prompt_generator.py에서는 DiffResult 의존성 제거와 타입 체크 로직 삭제로 인해 processed_diff의 안전성이 떨어졌고, json 모듈 임포트 여부도 확인이 필요합니다.\", \"score\": 6.0, \"recommendations\": [\"파일 입출력 시 항상 명시적 인코딩 지정\", \"타입 검증 로직을 유지하거나 강화해 런타임 에러 방지\", \"필수 모듈(import) 누락 여부 점검\", \"pathlib.Path 활용해 경로 처리 통일\", \"isort/black 등 코드 스타일 자동화 도구 적용\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 104}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 모듈\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\n\\\\nclass LLMClientFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로바이더에 맞는, 구조화된 응답을 지원하는 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            provider: LLM 프로바이더 (openai 또는 claude)\\\\n            api_key: API 키\\\\n\\\\n        Returns:\\\\n            Instructor: instructor 래핑된 LLM 클라이언트\\\\n            genai.Client: Google Gemini 클라이언트\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 프로바이더인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if provider == \\\\\\\"openai\\\\\\\":\\\\n            from openai import OpenAI\\\\n\\\\n            return instructor.from_openai(OpenAI(api_key=api_key))\\\\n        elif provider == \\\\\\\"claude\\\\\\\":\\\\n            from anthropic import Anthropic\\\\n\\\\n            return instructor.from_anthropic(Anthropic(api_key=api_key))\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 프로바이더입니다: {provider}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            genai.Client: Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 34}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n                from reviewer.src.llm_gateway import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n                from reviewer.src.llm_gateway import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n```\\\", \\\"line_number\\\": 38}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 99}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 107}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n```\\\", \\\"line_number\\\": 139}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 152}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 42, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`get_api_key` 함수가 `count_tokens` 메서드 내의 `try` 블록 안에서 잘못된 경로(`reviewer.src.llm_gateway`)로 임포트되고 있습니다. 임포트는 일반적으로 모듈 최상단에 위치해야 하며, 올바른 경로(`reviewer.src.config`)를 사용해야 합니다. 현재 상태로는 `get_api_key`를 찾을 수 없어 런타임 오류가 발생합니다.\", \"suggestion\": \"`from reviewer.src.llm_gateway import get_api_key` 임포트 문을 파일 최상단으로 이동시키고, 경로를 `from reviewer.src.config import get_api_key`로 수정하세요.\", \"severity\": \"error\", \"original_code\": \"```python\\n                try:\\n                    # API 키 가져오기 (기존 메커니즘 사용)\\n                    from reviewer.src.llm_gateway import get_api_key\\n```\", \"improved_code\": \"```python\\n# 파일 최상단에 추가\\nfrom reviewer.src.config import get_api_key\\n\\n# ... (count_tokens 메서드 내부)\\n            if \\\"gemini\\\" in model.lower():\\n                try:\\n                    # API 키 가져오기 (기존 메커니즘 사용)\\n                    # from reviewer.src.llm_gateway import get_api_key # 이 줄은 삭제\\n```\"}, {\"type\": \"design\", \"line_number\": 45, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`count_tokens` 메서드 내에서 Gemini 클라이언트를 직접 생성하고 있습니다. 이미 `LLMClientFactory`에서 프로바이더별 클라이언트를 생성하는 로직이 있으므로, 이를 재사용하는 것이 코드 중복을 줄이고 일관성을 유지하는 데 좋습니다.\", \"suggestion\": \"`LLMClientFactory.create_client`를 사용하여 Gemini 클라이언트를 가져오도록 코드를 수정하세요. 이를 위해 `reviewer.src.utils.llm_factory.LLMClientFactory`를 파일 최상단에 임포트해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n                # Client 객체 생성\\n                client = genai.Client(api_key=api_key)\\n```\", \"improved_code\": \"```python\\n# 파일 최상단에 추가\\nfrom reviewer.src.utils.llm_factory import LLMClientFactory\\n\\n# ... (count_tokens 메서드 내부)\\n                # LLMClientFactory를 사용하여 클라이언트 가져오기\\n                client = LLMClientFactory.create_client(\\\"google\\\", api_key)\\n```\"}], \"summary\": \"이 변경사항은 Google Gemini 모델 지원을 추가합니다. CLI 인자 파싱, 지원 모델 목록, LLM 게이트웨이 팩토리, LLM 클라이언트 팩토리, 토큰 계산 유틸리티 등 여러 모듈에 걸쳐 Gemini 관련 로직이 통합되었습니다. 전반적으로 기능 확장은 잘 이루어졌으나, 토큰 계산 유틸리티에서 API 키 임포트 경로 오류 및 클라이언트 생성 로직 중복 문제가 발견되었습니다.\", \"score\": 7.5, \"recommendations\": [\"토큰 계산 유틸리티(`token_utils.py`)에서 `get_api_key` 임포트 오류를 수정하고 임포트 위치를 최상단으로 옮기세요.\", \"토큰 계산 유틸리티에서 LLM 클라이언트 생성 시 `LLMClientFactory`를 재사용하여 코드 중복을 제거하세요.\", \"새로 추가된 Gemini 모델에 대한 테스트 케이스를 추가하여 기능이 올바르게 작동하는지 확인하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 104}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 모듈\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\n\\\\nclass LLMClientFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로바이더에 맞는, 구조화된 응답을 지원하는 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            provider: LLM 프로바이더 (openai 또는 claude)\\\\n            api_key: API 키\\\\n\\\\n        Returns:\\\\n            Instructor: instructor 래핑된 LLM 클라이언트\\\\n            genai.Client: Google Gemini 클라이언트\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 프로바이더인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if provider == \\\\\\\"openai\\\\\\\":\\\\n            from openai import OpenAI\\\\n\\\\n            return instructor.from_openai(OpenAI(api_key=api_key))\\\\n        elif provider == \\\\\\\"claude\\\\\\\":\\\\n            from anthropic import Anthropic\\\\n\\\\n            return instructor.from_anthropic(Anthropic(api_key=api_key))\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 프로바이더입니다: {provider}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            genai.Client: Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 34}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\nfrom google import genai\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n                from reviewer.src.llm_gateway import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n                from reviewer.src.llm_gateway import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(api_key=api_key)\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n```\\\", \\\"line_number\\\": 38}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 99}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 107}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n```\\\", \\\"line_number\\\": 139}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 152}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 42, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`get_api_key` 함수가 `count_tokens` 메소드 내부에 지역적으로 import 되고 있습니다. 이는 일반적으로 권장되지 않는 방식이며, 모듈 상단에서 import 하는 것이 가독성과 유지보수성을 높입니다. 또한, `reviewer.src.llm_gateway`에서 `get_api_key`를 가져오고 있는데, 이 함수의 실제 위치는 `reviewer.src.config`일 가능성이 높습니다 (cli.py 참조).\", \"suggestion\": \"`from reviewer.src.config import get_api_key`를 `reviewer/src/utils/token/token_utils.py` 파일 상단으로 옮기십시오. 이렇게 하면 순환 참조 위험을 줄이고 코드 전체의 일관성을 유지할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n        if \\\"gemini\\\" in model.lower():\\n            try:\\n                # API 키 가져오기 (기존 메커니즘 사용)\\n                from reviewer.src.llm_gateway import get_api_key\\n\\n                api_key = get_api_key(\\\"google\\\")\\n```\", \"improved_code\": \"```python\\n# reviewer/src/utils/token/token_utils.py 파일 상단에 추가:\\nfrom reviewer.src.config import get_api_key\\n# ... other imports ...\\n\\nclass TokenUtils:\\n    # ...\\n    @staticmethod\\n    def count_tokens(text: str, model: str = \\\"gpt-4o\\\") -> int:\\n        # ...\\n        if \\\"gemini\\\" in model.lower():\\n            try:\\n                # API 키 가져오기 (기존 메커니즘 사용)\\n                api_key = get_api_key(\\\"google\\\")\\n                if not api_key:\\n                    print(\\\"Google API 키가 설정되지 않았습니다. Gemini 토큰 수를 정확히 계산할 수 없습니다.\\\")\\n                    # API 키가 없으면 API 호출 시도 전에 대체 로직으로 가거나 0을 반환\\n                    # (아래는 기존 대체 로직으로 넘어가는 것을 가정)\\n                    raise ValueError(\\\"Google API 키 없음\\\") # genai.Client 생성 전에 오류 발생 유도\\n                # ... client 생성 및 API 호출 ...\\n```\"}, {\"type\": \"버그\", \"line_number\": 58, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Gemini 토큰 계산 중 발생하는 예외를 `except Exception as e:`로 너무 광범위하게 처리하고 있습니다. 이는 `get_api_key` 실패(API 키 부재)와 같은 다른 종류의 오류까지 포괄하여, 실제 API 호출 오류와 구분하기 어렵게 만들고 디버깅을 복잡하게 합니다. API 키가 없는 경우에도 부정확한 추정치를 반환할 수 있습니다.\", \"suggestion\": \"Google API 호출 시 발생할 수 있는 특정 예외(예: `genai.APIError`, `ValueError`, `AttributeError` 등)를 명시적으로 처리하고, API 키 부재와 같은 사전 조건 실패는 별도로 처리하여 사용자에게 명확한 피드백을 제공하십시오. 모든 예외를 포괄하는 `except Exception`은 최후의 수단으로 사용하고, 오류 발생 시 대체 추정 로직으로 넘어가는 것 외에 로깅을 강화하는 것을 고려하십시오.\", \"severity\": \"warning\", \"original_code\": \"```python\\n            except Exception as e:\\n                print(f\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\")\\n                # 대체 방법으로 계산하거나 추정\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\n                korean_chars = len(re.findall(\\\"[가-힣]\\\", text))\\n                english_chars = len(re.findall(\\\"[a-zA-Z]\\\", text))\\n                other_chars = len(text) - korean_chars - english_chars\\n\\n                estimated_tokens = (\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\n                )\\n                return int(estimated_tokens)\\n```\", \"improved_code\": \"```python\\n            except (genai.APIError, AttributeError) as e: # API 호출 또는 응답 관련 특정 예외\\n                print(f\\\"Gemini 토큰 API 호출 또는 응답 처리 중 오류 발생: {e}. 대체 추정치를 사용합니다.\\\")\\n                # 대체 추정 로직 (정확도에 대한 경고와 함께)\\n                korean_chars = len(re.findall(\\\"[가-힣]\\\", text))\\n                english_chars = len(re.findall(\\\"[a-zA-Z]\\\", text))\\n                other_chars = len(text) - korean_chars - english_chars\\n                estimated_tokens = ((korean_chars / 2) + (english_chars / 4) + (other_chars / 3))\\n                print(f\\\"경고: Gemini 토큰 수 추정치는 정확하지 않을 수 있습니다 (추정치: {int(estimated_tokens)}).\\\")\\n                return int(estimated_tokens)\\n            except ValueError as e: # API 키 부재 등 genai.Client 생성 전 문제\\n                print(f\\\"Gemini 토큰 계산을 위한 설정 오류: {e}. 토큰 수를 0으로 처리합니다.\\\")\\n                return 0\\n            except Exception as e: # 예상치 못한 기타 모든 오류\\n                print(f\\\"Gemini 토큰 계산 중 예상치 못한 오류 발생: {e}. 토큰 수를 0으로 처리합니다.\\\")\\n                return 0\\n```\"}, {\"type\": \"설계\", \"line_number\": 47, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google GenAI 클라이언트 초기화 시 `HttpOptions(api_version=\\\"v1\\\")`와 같이 API 버전이 하드코딩되어 있습니다. GenAI 라이브러리가 업데이트되거나 API 버전 정책이 변경될 경우, 이 부분을 수동으로 업데이트해야 할 수 있습니다.\", \"suggestion\": \"가능하면 라이브러리가 기본적으로 최신 또는 안정적인 버전을 사용하도록 `HttpOptions` 설정을 생략하거나, 이 설정을 외부 설정 파일 또는 상수로 관리하는 것을 고려하십시오. 특정 버전 사용이 필수적이라면, 해당 이유와 함께 나중에 업데이트 필요성을 알리는 주석을 명시하는 것이 좋습니다 (예: `# count_tokens API는 현재 'v1' API 버전을 사용합니다. 라이브러리/API 변경 시 확인 필요`).\", \"severity\": \"info\", \"original_code\": \"```python\\n                client = genai.Client(\\n                    api_key=api_key, http_options=HttpOptions(api_version=\\\"v1\\\")\\n                )\\n```\", \"improved_code\": \"```python\\n                # count_tokens API가 특정 버전을 요구할 수 있으므로 명시. 추후 API 변경 시 확인 필요.\\n                client = genai.Client(\\n                    api_key=api_key, http_options=HttpOptions(api_version=\\\"v1\\\") \\n                )\\n```\"}, {\"type\": \"설계\", \"line_number\": 98, \"file\": \"reviewer/src/available_models.py\", \"description\": \"`AVAILABLE_MODELS` 딕셔너리 내의 각 모델 정보(`ModelInfoDict`)에 `aliases` 필드가 이미 존재합니다. 별도의 `MODEL_NAME_ALIASES` 딕셔너리(line 98에서 정의 시작, hunk 3에서 line 104에 내용 추가)를 유지하는 것은 모델 별칭 정보가 중복 관리될 수 있으며, 모델 정보의 단일 출처 원칙(Single Source of Truth)을 약화시킬 수 있습니다.\", \"suggestion\": \"`MODEL_NAME_ALIASES` 딕셔너리를 제거하고, `get_model_info` 함수 로직을 수정하여 `AVAILABLE_MODELS`의 각 항목에 있는 `aliases` 리스트를 직접 사용하도록 통합하는 것을 고려하십시오. `get_supported_models` 함수도 이에 맞춰 수정해야 합니다. 이렇게 하면 모델 정보 관리가 단순해지고 일관성이 향상됩니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n# reviewer/src/available_models.py, line 28 (ModelInfoDict definition)\\n# class ModelInfoDict(TypedDict):\\n#     aliases: list[str]\\n#     ...\\n\\n# reviewer/src/available_models.py, line 98 (MODEL_NAME_ALIASES definition)\\nMODEL_NAME_ALIASES: dict[str, str] = {\\n    \\\"claude-3-7-sonnet\\\": \\\"claude-3-7-sonnet-20250219\\\",\\n    \\\"claude-3.7-sonnet\\\": \\\"claude-3-7-sonnet-20250219\\\",\\n    \\\"o3-mini-high\\\": \\\"o3-mini\\\",\\n    \\\"o4-mini-high\\\": \\\"o4-mini\\\",\\n    # Hunk 3 adds gemini aliases here (line 104)\\n}\\n\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\n    # ...\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\n    # ...\\n```\", \"improved_code\": \"```python\\n# reviewer/src/available_models.py\\n\\n# MODEL_NAME_ALIASES 딕셔너리 제거\\n\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\n    # 1. 정식 이름으로 직접 검색\\n    if model_name in AVAILABLE_MODELS:\\n        return AVAILABLE_MODELS[model_name]\\n\\n    # 2. AVAILABLE_MODELS 내의 aliases 목록에서 검색\\n    for official_name, info in AVAILABLE_MODELS.items():\\n        if model_name in info.get(\\\"aliases\\\", []):\\n            return AVAILABLE_MODELS[official_name]\\n\\n    raise UnsupportedModelError(model_name)\\n\\ndef get_supported_models() -> list[str]:\\n    supported = set(AVAILABLE_MODELS.keys())\\n    for info in AVAILABLE_MODELS.values():\\n        for alias in info.get(\\\"aliases\\\", []):\\n            supported.add(alias)\\n    return sorted(list(supported))\\n```\"}, {\"type\": \"설계\", \"line_number\": 410, \"file\": \"reviewer/cli.py\", \"description\": \"`review_code` 함수 내에서 API 키를 확인할 때 `get_api_key(\\\"openai\\\")`로 OpenAI 제공자를 하드코딩하여 사용하고 있습니다. 사용자가 `--model` 옵션을 통해 다른 제공자(예: Claude, Google)의 모델을 선택한 경우에도 OpenAI API 키를 우선적으로 확인하고 설정하려고 시도합니다. 이는 사용자 경험에 혼란을 줄 수 있으며, 선택된 모델과 다른 제공자의 키를 요구하게 됩니다.\", \"suggestion\": \"사용자가 `--model` 옵션으로 선택한 모델의 실제 제공자(provider)를 `get_model_info(args.model)[\\\"provider\\\"]`를 통해 동적으로 파악하고, 해당 제공자의 API 키를 확인하고 요청하도록 로직을 수정해야 합니다. 이렇게 하면 사용자가 선택한 모델에 적합한 API 키를 설정하도록 안내할 수 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\ndef review_code(args: argparse.Namespace) -> None:\\n    \\\"\\\"\\\"코드 리뷰를 수행합니다.\\\"\\\"\\\"\\n    # API 키 확인\\n    api_key = get_api_key(\\\"openai\\\")  # 기본적으로 OpenAI 모델 사용\\n    if not api_key:\\n        print(\\\"API 키가 설정되지 않았습니다.\\\")\\n        print(\\\"다음 명령어로 API 키를 설정하세요:\\\")\\n        print(\\\"  reviewer config api-key openai\\\")\\n        # ... (OpenAI 키 설정 로직) ...\\n```\", \"improved_code\": \"```python\\nfrom reviewer.src.available_models import get_model_info # 파일 상단에 import 추가\\n\\ndef review_code(args: argparse.Namespace) -> None:\\n    \\\"\\\"\\\"코드 리뷰를 수행합니다.\\\"\\\"\\\"\\n    # 선택된 모델의 제공자 확인\\n    # args.model은 argparse choices에 의해 유효성이 검증되었다고 가정\\n    model_info = get_model_info(args.model)\\n    provider = model_info[\\\"provider\\\"]\\n\\n    # API 키 확인\\n    api_key = get_api_key(provider)\\n    if not api_key:\\n        print(f\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\")\\n        print(f\\\"다음 명령어로 API 키를 설정하세요:\\\")\\n        print(f\\\"  reviewer config api-key {provider.lower()}\\\")\\n\\n        try:\\n            response = input(f\\\"지금 {provider.upper()} API 키를 설정하시겠습니까? (y/n): \\\")\\n            if response.lower() == \\\"y\\\":\\n                # ... (선택된 provider에 대한 API 키 설정 로직) ...\\n                # new_api_key = getpass.getpass(...)\\n                # set_api_key(new_api_key, provider)\\n                # api_key = new_api_key\\n            else:\\n                print(\\\"API 키 설정이 거부되어 실행을 중단합니다.\\\")\\n                return\\n        except KeyboardInterrupt:\\n            print(\\\"\\\\n실행이 취소되었습니다.\\\")\\n            return\\n    \\n    if not api_key: # 최종적으로 API 키가 설정되었는지 확인\\n        print(f\\\"{provider.upper()} API 키가 없어 코드 리뷰를 진행할 수 없습니다.\\\")\\n        return\\n    # ... (이하 코드 동일)\\n```\"}, {\"type\": \"설계\", \"line_number\": 60, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Gemini 모델의 토큰 수를 API로 계산하지 못할 경우 사용되는 대체 추정 로직(line 60-67)이 제공됩니다. 이 추정 방식(한글 글자당 0.5 토큰, 영어 글자당 0.25 토큰 등)은 Claude 모델의 추정 방식과 다르며, 각 모델의 실제 토큰화 방식과 상당한 차이가 있을 수 있어 비용 추정의 정확도를 크게 떨어뜨릴 수 있습니다.\", \"suggestion\": \"Gemini 모델의 공식적인 토큰화 규칙이나 근사치 계산 가이드라인을 찾아 최대한 반영하십시오. 공식 가이드가 없다면, 추정치가 매우 부정확할 수 있음을 사용자에게 명확히 알리고, API 호출 실패 시(특히 API 키 부재 등)에는 토큰 수를 0으로 반환하거나 예외를 발생시켜 부정확한 비용 계산을 방지하는 것을 고려하십시오. 현재는 API 키가 없어도 부정확한 추정치를 반환할 가능성이 있습니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\n                korean_chars = len(re.findall(\\\"[가-힣]\\\", text))\\n                english_chars = len(re.findall(\\\"[a-zA-Z]\\\", text))\\n                other_chars = len(text) - korean_chars - english_chars\\n\\n                estimated_tokens = (\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\n                )\\n                return int(estimated_tokens)\\n```\", \"improved_code\": \"```python\\n                # 이 대체 추정 방식은 정확도가 낮을 수 있습니다.\\n                # Gemini 공식 문서나 커뮤니티에서 권장하는 추정 방식을 확인하는 것이 좋습니다.\\n                korean_chars = len(re.findall(\\\"[가-힣]\\\", text))\\n                english_chars = len(re.findall(\\\"[a-zA-Z]\\\", text))\\n                other_chars = len(text) - korean_chars - english_chars\\n                \\n                # 예시: Claude와 유사한 가중치 또는 다른 연구된 가중치 적용 고려\\n                # estimated_tokens = (korean_chars * 1.2) + (english_chars * 0.4) + (other_chars * 0.8)\\n                # 임시로 기존 로직 유지하되, 부정확성에 대한 경고 강화\\n                estimated_tokens = ((korean_chars / 2) + (english_chars / 4) + (other_chars / 3))\\n                print(f\\\"경고: Gemini 토큰 수 추정치는 실제와 크게 다를 수 있습니다 (추정치: {int(estimated_tokens)}). 비용 계산에 유의하세요.\\\")\\n                return int(estimated_tokens)\\n```\"}], \"summary\": \"Google Gemini LLM 모델 지원이 코드베이스에 성공적으로 통합되었습니다. 이 변경으로 사용자는 OpenAI, Claude 모델 외에 Google의 Gemini 모델도 코드 리뷰에 활용할 수 있게 되었습니다. 주요 수정 사항은 모델 목록 업데이트, API 제공자 및 클라이언트/게이트웨이 팩토리 로직 확장, Gemini 모델을 위한 토큰 계산 및 비용 추정 기능 추가 등입니다. 전반적으로 기능 확장은 잘 이루어졌으나, API 키 처리, 예외 관리, 일부 설계 측면에서 개선의 여지가 있습니다.\", \"score\": 7.5, \"recommendations\": [\"API 키 처리 로직을 개선하여 사용자가 선택한 모델의 제공자에 맞는 API 키를 명확히 안내하고 설정하도록 하십시오.\", \"모듈 간 의존성 관리 및 코드 스타일 일관성을 위해 지역 import 대신 전역 import를 사용하십시오.\", \"외부 API 호출(특히 토큰 계산) 시 발생할 수 있는 예외를 보다 구체적으로 처리하여 프로그램 안정성을 높이십시오.\", \"모델 정보(특히 별칭) 관리 방식을 단순화하여 중복을 줄이고 단일 출처 원칙을 강화하십시오.\", \"API 버전과 같이 변경 가능성이 있는 설정 값의 하드코딩을 지양하고, 주석이나 설정을 통해 관리하여 유지보수성을 향상시키십시오.\", \"LLM 모델별 토큰 계산 대체 로직의 정확성을 지속적으로 검토하고, 가능한 경우 공식 가이드라인을 반영하여 비용 추정의 신뢰도를 높이십시오.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"original_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-1.5-pro-001\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-1.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 1.5 Pro 모델, 안정적인 성능과 긴 컨텍스트 지원\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-1.5-flash-001\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-1.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 1.5 Flash 모델, 빠른 속도와 경제적인 비용\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-flash\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n    \\\\\\\"gemini-1.5-pro\\\\\\\": \\\\\\\"gemini-1.5-pro-001\\\\\\\",\\\\n    \\\\\\\"gemini-1.5-flash\\\\\\\": \\\\\\\"gemini-1.5-flash-001\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 122, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"original_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            genai.Client: Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 34, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"1\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\nfrom google.genai.types import HttpOptions\\\\n```\\\", \\\"line_number\\\": 5, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"2\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower():\\\\n            try:\\\\n                # API 키 가져오기 (기존 메커니즘 사용)\\\\n                from reviewer.src.llm_gateway import get_api_key\\\\n\\\\n                api_key = get_api_key(\\\\\\\"google\\\\\\\")\\\\n\\\\n                # Client 객체 생성\\\\n                client = genai.Client(\\\\n                    api_key=api_key, http_options=HttpOptions(api_version=\\\\\\\"v1\\\\\\\")\\\\n                )\\\\n\\\\n                # 사용 가능한 모델명으로 매핑\\\\n                model_name = model.lower()\\\\n                if \\\\\\\"2.5\\\\\\\" in model_name:\\\\n                    if \\\\\\\"flash\\\\\\\" in model_name:\\\\n                        model_name = \\\\\\\"gemini-1.5-flash-001\\\\\\\"\\\\n                    else:\\\\n                        model_name = \\\\\\\"gemini-1.5-pro-001\\\\\\\"\\\\n                elif \\\\\\\"1.5\\\\\\\" in model_name:\\\\n                    if \\\\\\\"flash\\\\\\\" in model_name:\\\\n                        model_name = \\\\\\\"gemini-1.5-flash-001\\\\\\\"\\\\n                    else:\\\\n                        model_name = \\\\\\\"gemini-1.5-pro-001\\\\\\\"\\\\n                else:\\\\n                    # 기본값으로 설정\\\\n                    model_name = \\\\\\\"gemini-1.5-flash-001\\\\\\\"\\\\n\\\\n                # 토큰 수 계산 (최신 API 사용)\\\\n                response = client.models.count_tokens(model=model_name, contents=text)\\\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\\\n                return (\\\\n                    response.total_tokens\\\\n                    if response\\\\n                    and hasattr(response, \\\\\\\"total_tokens\\\\\\\")\\\\n                    and response.total_tokens is not None\\\\n                    else 0\\\\n                )\\\\n            except Exception as e:\\\\n                print(f\\\\\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\\\\\")\\\\n                # 대체 방법으로 계산하거나 추정\\\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\\\n                korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n                english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n                other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n                estimated_tokens = (\\\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\\\n                )\\\\n                return int(estimated_tokens)\\\\n\\\\n```\\\", \\\"line_number\\\": 39, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"3\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 116, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"4\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 124, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"5\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-1.5-pro-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\\\n            \\\\\\\"gemini-1.5-flash-001\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\\\n```\\\", \\\"line_number\\\": 156, \\\"language\\\": \\\"python\\\"}\"}, {\"role\": \"user\", \"content\": \"{\\\"hunk_idx\\\": \\\"6\\\", \\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 169, \\\"language\\\": \\\"python\\\"}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"feature\", \"line_number\": 0, \"file\": \"reviewer/cli.py\", \"description\": \"CLI 명령어에 Google 모델 지원 추가\", \"suggestion\": \"CLI 명령어에 Google 모델 지원을 추가하여 사용자가 Google 모델을 선택할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        choices=[\\\"openai\\\", \\\"claude\\\"],\\n```\", \"improved_code\": \"```python\\n        choices=[\\\"openai\\\", \\\"claude\\\", \\\"google\\\"],\\n```\"}, {\"type\": \"feature\", \"line_number\": 0, \"file\": \"reviewer/cli.py\", \"description\": \"CLI 명령어에 Google 모델 지원 추가\", \"suggestion\": \"CLI 명령어에 Google 모델 지원을 추가하여 사용자가 Google 모델을 선택할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        print(\\\"  reviewer config api-key [openai|claude] [KEY]\\\")\\n```\", \"improved_code\": \"```python\\n        print(\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\")\\n```\"}, {\"type\": \"feature\", \"line_number\": 0, \"file\": \"reviewer/src/available_models.py\", \"description\": \"Google 모델 지원 추가\", \"suggestion\": \"Google 모델 지원을 추가하여 사용자가 Google 모델을 선택할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\nModelProvider = Literal[\\\"openai\\\", \\\"claude\\\"]\\n```\", \"improved_code\": \"```python\\nModelProvider = Literal[\\\"openai\\\", \\\"claude\\\", \\\"google\\\"]\\n```\"}, {\"type\": \"feature\", \"line_number\": 78, \"file\": \"reviewer/src/available_models.py\", \"description\": \"Google Gemini 모델 정보 추가\", \"suggestion\": \"Google Gemini 모델 정보를 추가하여 사용자가 Google 모델을 선택할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n    \\\"gemini-2.5-pro-exp-03-25\\\": {\\n        \\\"full_name\\\": \\\"gemini-2.5-pro-exp-03-25\\\",\\n        \\\"aliases\\\": [\\\"gemini-2.5-pro\\\"],\\n        \\\"description\\\": \\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\",\\n        \\\"provider\\\": \\\"google\\\",\\n        \\\"params\\\": {\\n            \\\"temperature\\\": 0.0,\\n        },\\n    },\\n    \\\"gemini-2.5-flash-preview-04-17\\\": {\\n        \\\"full_name\\\": \\\"gemini-2.5-flash-preview-04-17\\\",\\n        \\\"aliases\\\": [\\\"gemini-2.5-flash\\\"],\\n        \\\"description\\\": \\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\",\\n        \\\"provider\\\": \\\"google\\\",\\n        \\\"params\\\": {\\n            \\\"temperature\\\": 0.0,\\n        },\\n    },\\n    \\\"gemini-1.5-pro-001\\\": {\\n        \\\"full_name\\\": \\\"gemini-1.5-pro-001\\\",\\n        \\\"aliases\\\": [\\\"gemini-1.5-pro\\\"],\\n        \\\"description\\\": \\\"Google의 Gemini 1.5 Pro 모델, 안정적인 성능과 긴 컨텍스트 지원\\\",\\n        \\\"provider\\\": \\\"google\\\",\\n        \\\"params\\\": {\\n            \\\"temperature\\\": 0.0,\\n        },\\n    },\\n    \\\"gemini-1.5-flash-001\\\": {\\n        \\\"full_name\\\": \\\"gemini-1.5-flash-001\\\",\\n        \\\"aliases\\\": [\\\"gemini-1.5-flash\\\"],\\n        \\\"description\\\": \\\"Google의 Gemini 1.5 Flash 모델, 빠른 속도와 경제적인 비용\\\",\\n        \\\"provider\\\": \\\"google\\\",\\n        \\\"params\\\": {\\n            \\\"temperature\\\": 0.0,\\n        },\\n    },\\n```\"}, {\"type\": \"feature\", \"line_number\": 122, \"file\": \"reviewer/src/available_models.py\", \"description\": \"Google Gemini 모델 별칭 추가\", \"suggestion\": \"Google Gemini 모델 별칭을 추가하여 사용자가 다양한 이름으로 모델을 선택할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n    \\\"gemini-2.5-pro\\\": \\\"gemini-2.5-pro-exp-03-25\\\",\\n    \\\"gemini-2.5-flash\\\": \\\"gemini-2.5-flash-preview-04-17\\\",\\n    \\\"gemini-1.5-pro\\\": \\\"gemini-1.5-pro-001\\\",\\n    \\\"gemini-1.5-flash\\\": \\\"gemini-1.5-flash-001\\\",\\n```\"}, {\"type\": \"feature\", \"line_number\": 35, \"file\": \"reviewer/src/llm_gateway/gateway_factory.py\", \"description\": \"Google Gateway 지원 추가\", \"suggestion\": \"Google Gateway 지원을 추가하여 Google 모델을 사용할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n        elif model_info[\\\"provider\\\"] == \\\"google\\\":\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\n\\n            return GoogleGateway(model_info=model_info)\\n```\"}, {\"type\": \"feature\", \"line_number\": 0, \"file\": \"reviewer/src/utils/llm_factory.py\", \"description\": \"Google GenAI 라이브러리 임포트\", \"suggestion\": \"Google GenAI 라이브러리를 임포트하여 Google 모델을 사용할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\nfrom google import genai\\n```\"}, {\"type\": \"feature\", \"line_number\": 0, \"file\": \"reviewer/src/utils/llm_factory.py\", \"description\": \"Google GenAI 클라이언트 지원 추가\", \"suggestion\": \"Google GenAI 클라이언트 지원을 추가하여 Google 모델을 사용할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\n```\", \"improved_code\": \"```python\\n    def create_client(\\n        provider: str, api_key: str\\n    ) -> instructor.Instructor | genai.Client:\\n```\"}, {\"type\": \"feature\", \"line_number\": 0, \"file\": \"reviewer/src/utils/llm_factory.py\", \"description\": \"Google GenAI 클라이언트 지원 추가\", \"suggestion\": \"Google GenAI 클라이언트 지원을 추가하여 Google 모델을 사용할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n            genai.Client: Google Gemini 클라이언트\\n```\"}, {\"type\": \"feature\", \"line_number\": 34, \"file\": \"reviewer/src/utils/llm_factory.py\", \"description\": \"Google GenAI 클라이언트 생성\", \"suggestion\": \"Google GenAI 클라이언트를 생성하여 Google 모델을 사용할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n        elif provider == \\\"google\\\":\\n            return genai.Client(api_key=api_key)\\n```\"}, {\"type\": \"feature\", \"line_number\": 5, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google GenAI 라이브러리 임포트\", \"suggestion\": \"Google GenAI 라이브러리를 임포트하여 Google 모델을 사용할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\nfrom google import genai\\nfrom google.genai.types import HttpOptions\\n```\"}, {\"type\": \"feature\", \"line_number\": 39, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google Gemini 토큰 계산 기능 추가\", \"suggestion\": \"Google Gemini 토큰 계산 기능을 추가하여 Google 모델의 토큰 수를 정확하게 계산할 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n        if \\\"gemini\\\" in model.lower():\\n            try:\\n                # API 키 가져오기 (기존 메커니즘 사용)\\n                from reviewer.src.llm_gateway import get_api_key\\n\\n                api_key = get_api_key(\\\"google\\\")\\n\\n                # Client 객체 생성\\n                client = genai.Client(\\n                    api_key=api_key, http_options=HttpOptions(api_version=\\\"v1\\\")\\n                )\\n\\n                # 사용 가능한 모델명으로 매핑\\n                model_name = model.lower()\\n                if \\\"2.5\\\" in model_name:\\n                    if \\\"flash\\\" in model_name:\\n                        model_name = \\\"gemini-1.5-flash-001\\\"\\n                    else:\\n                        model_name = \\\"gemini-1.5-pro-001\\\"\\n                elif \\\"1.5\\\" in model_name:\\n                    if \\\"flash\\\" in model_name:\\n                        model_name = \\\"gemini-1.5-flash-001\\\"\\n                    else:\\n                        model_name = \\\"gemini-1.5-pro-001\\\"\\n                else:\\n                    # 기본값으로 설정\\n                    model_name = \\\"gemini-1.5-flash-001\\\"\\n\\n                # 토큰 수 계산 (최신 API 사용)\\n                response = client.models.count_tokens(model=model_name, contents=text)\\n                # total_tokens가 None일 경우를 대비해 기본값 0을 제공\\n                return (\\n                    response.total_tokens\\n                    if response\\n                    and hasattr(response, \\\"total_tokens\\\")\\n                    and response.total_tokens is not None\\n                    else 0\\n                )\\n            except Exception as e:\\n                print(f\\\"Gemini 토큰 계산 중 오류 발생: {e}\\\")\\n                # 대체 방법으로 계산하거나 추정\\n                # 영어는 약 4자당 1토큰, 한글은 약 2자당 1토큰으로 추정\\n                korean_chars = len(re.findall(\\\"[가-힣]\\\", text))\\n                english_chars = len(re.findall(\\\"[a-zA-Z]\\\", text))\\n                other_chars = len(text) - korean_chars - english_chars\\n\\n                estimated_tokens = (\\n                    (korean_chars / 2) + (english_chars / 4) + (other_chars / 3)\\n                )\\n                return int(estimated_tokens)\\n\\n```\"}, {\"type\": \"feature\", \"line_number\": 116, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google Gemini 모델 컨텍스트 제한 추가\", \"suggestion\": \"Google Gemini 모델의 컨텍스트 제한을 추가하여 사용자가 모델의 컨텍스트 제한을 알 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n            \\\"gemini-1.5-pro-001\\\": 1048576,  # Gemini 1.5 Pro: 약 1M 토큰\\n            \\\"gemini-1.5-flash-001\\\": 1048576,  # Gemini 1.5 Flash: 약 1M 토큰\\n```\"}, {\"type\": \"feature\", \"line_number\": 124, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google Gemini 모델 컨텍스트 제한 처리\", \"suggestion\": \"Google Gemini 모델의 컨텍스트 제한을 처리하여 사용자가 모델의 컨텍스트 제한을 넘지 않도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\n        if \\\"gemini\\\" in model.lower() and model not in context_limits:\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\n\\n```\"}, {\"type\": \"feature\", \"line_number\": 156, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google Gemini 모델 가격 정보 추가\", \"suggestion\": \"Google Gemini 모델의 가격 정보를 추가하여 사용자가 모델의 가격을 알 수 있도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n            \\\"gemini-1.5-pro-001\\\": {\\n                \\\"input\\\": 0.0015,\\n                \\\"output\\\": 0.0060,\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 1.5 Pro)\\n            \\\"gemini-1.5-flash-001\\\": {\\n                \\\"input\\\": 0.00015,\\n                \\\"output\\\": 0.0006,\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 1.5 Flash)\\n```\"}, {\"type\": \"feature\", \"line_number\": 169, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"Google Gemini 모델 가격 처리\", \"suggestion\": \"Google Gemini 모델의 가격을 처리하여 사용자가 모델의 가격을 넘지 않도록 했습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n\\n```\", \"improved_code\": \"```python\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\n        elif \\\"gemini\\\" in model_name.lower() and model_name not in pricing:\\n            # Gemini 기본 가격 (Flash 모델 기준)\\n            model_pricing = {\\\"input\\\": 0.00015, \\\"output\\\": 0.0006}\\n```\"}], \"summary\": \"Google Gemini 모델 지원을 추가했습니다. CLI 명령어, 모델 정보, 게이트웨이, 토큰 계산, 컨텍스트 제한, 가격 정보 등을 업데이트하여 Google 모델을 사용할 수 있도록 했습니다.\", \"score\": 9.0, \"recommendations\": [\"Google 모델 지원을 위한 테스트 케이스 추가\", \"Google 모델의 성능 및 안정성을 지속적으로 모니터링\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    print(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        current_key = get_api_key(provider)\\\\n        if current_key:\\\\n            masked_key = (\\\\n                current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n            )\\\\n            print(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                print(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        print(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        print(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        print(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    print(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        print(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        print(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    print(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    print(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        print(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        print(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        print(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n    print(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    print(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        print(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            print(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            print(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        print(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    print(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    print()\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        print(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        print(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    print(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        print(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        print(\\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            print(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    print(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        print(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        print(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            print(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            print(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        print(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    print(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        print(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    print(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        print(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        print(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        print(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        print(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    args: argparse.Namespace = parse_args()\\\\n\\\\n    if args.command == \\\\\\\"config\\\\\\\":\\\\n        handle_config_command(args)\\\\n    elif args.command == \\\\\\\"review\\\\\\\":\\\\n        review_code(args)\\\\n    elif args.command == \\\\\\\"results\\\\\\\":\\\\n        handle_results_command(args)\\\\n    elif args.command == \\\\\\\"view\\\\\\\":\\\\n        handle_view_command(args)\\\\n    else:\\\\n        print(f\\\\\\\"알 수 없는 명령어: {args.command}\\\\\\\")\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        print(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        print(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"],\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude] [KEY]\\\\\\\")\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        print(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/available_models.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n지원하는 LLM 모델 목록과 관련 정보를 관리하는 모듈입니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom typing import Literal, TypedDict\\\\n\\\\nfrom reviewer.src.exceptions.unsupported_model_error import UnsupportedModelError\\\\n\\\\n# 모델 제공자 타입\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n\\\\n\\\\nclass ModelParamsDict(TypedDict, total=False):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델별 파라미터 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    temperature: float\\\\n    reasoning_effort: str\\\\n    max_tokens: int\\\\n\\\\n\\\\nclass ModelInfoDict(TypedDict):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 정보 타입\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    full_name: str\\\\n    aliases: list[str]\\\\n    description: str\\\\n    provider: ModelProvider\\\\n    params: ModelParamsDict\\\\n\\\\n\\\\n# 지원하는 모든 모델 정보\\\\nAVAILABLE_MODELS: dict[str, ModelInfoDict] = {\\\\n    \\\\\\\"gpt-4o\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4o\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4 Omni 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gpt-4.1\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gpt-4.1\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"GPT-4.1 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"o3-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o3-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"o4-mini\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"o4-mini-high\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"OpenAI의 모델, reasoning에 최적화\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"openai\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"reasoning_effort\\\\\\\": \\\\\\\"high\\\\\\\",\\\\n        },\\\\n    },\\\\n    \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"claude-3-7-sonnet\\\\\\\", \\\\\\\"claude-3.7-sonnet\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Claude 3.7 Sonnet 모델, 균형적인 성능과 경제성\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"claude\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n}\\\\n\\\\n# 모델 이름 축약형을 전체 이름에 매핑\\\\nMODEL_NAME_ALIASES: dict[str, str] = {\\\\n    \\\\\\\"claude-3-7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"claude-3.7-sonnet\\\\\\\": \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\",\\\\n    \\\\\\\"o3-mini-high\\\\\\\": \\\\\\\"o3-mini\\\\\\\",\\\\n    \\\\\\\"o4-mini-high\\\\\\\": \\\\\\\"o4-mini\\\\\\\",\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n}\\\\n\\\\n\\\\ndef get_model_info(model_name: str) -> ModelInfoDict:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 이름에 해당하는 정보를 반환합니다.\\\\n\\\\n    Args:\\\\n        model_name: 모델 이름 (정식 이름 또는 축약형)\\\\n\\\\n    Returns:\\\\n        ModelInfoDict: 모델 정보\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 정식 이름으로 시도\\\\n    if model_name in AVAILABLE_MODELS:\\\\n        return AVAILABLE_MODELS[model_name]\\\\n\\\\n    # 축약형으로 시도\\\\n    full_name = MODEL_NAME_ALIASES.get(model_name)\\\\n    if full_name:\\\\n        return AVAILABLE_MODELS[full_name]\\\\n\\\\n    raise UnsupportedModelError(model_name)\\\\n\\\\n\\\\ndef get_supported_models() -> list[str]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"지원하는 모든 모델 목록을 반환합니다.\\\\n\\\\n    Returns:\\\\n        List[str]: 지원하는 모델 이름 목록\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    return list(AVAILABLE_MODELS.keys()) + list(MODEL_NAME_ALIASES.keys())\\\\n\\\\n\\\\ndef get_default_model() -> str:\\\\n    return \\\\\\\"o4-mini\\\\\\\"\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\"]\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nModelProvider = Literal[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"]\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-pro\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Pro 모델, 코딩 및 복잡한 추론 작업에 탁월\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n    \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\": {\\\\n        \\\\\\\"full_name\\\\\\\": \\\\\\\"gemini-2.5-flash-preview-04-17\\\\\\\",\\\\n        \\\\\\\"aliases\\\\\\\": [\\\\\\\"gemini-2.5-flash\\\\\\\"],\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Google의 Gemini 2.5 Flash 모델, 성능과 속도의 균형이 잘 맞는 모델\\\\\\\",\\\\n        \\\\\\\"provider\\\\\\\": \\\\\\\"google\\\\\\\",\\\\n        \\\\\\\"params\\\\\\\": {\\\\n            \\\\\\\"temperature\\\\\\\": 0.0,\\\\n        },\\\\n    },\\\\n```\\\", \\\"line_number\\\": 78}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    \\\\\\\"gemini-2.5-pro\\\\\\\": \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 0}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/llm_gateway/gateway_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 생성을 담당하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nfrom reviewer.src.available_models import get_default_model\\\\nfrom reviewer.src.exceptions.unsupported_provider_error import UnsupportedProviderError\\\\nfrom reviewer.src.llm_gateway import get_model_info\\\\nfrom reviewer.src.llm_gateway.base_gateway import BaseGateway\\\\n\\\\n\\\\nclass GatewayFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 게이트웨이 객체를 생성하는 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create(model: str) -> BaseGateway:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"주어진 모델 이름에 맞는 LLM 게이트웨이 객체를 생성합니다.\\\\n\\\\n        Args:\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            OpenAIGateway | ClaudeGateway: LLM 게이트웨이 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if not model:\\\\n            model = get_default_model()\\\\n\\\\n        model_info = get_model_info(model)\\\\n\\\\n        if model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"openai\\\\\\\":\\\\n            from reviewer.src.llm_gateway.openai_gateway import OpenAIGateway\\\\n\\\\n            return OpenAIGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"claude\\\\\\\":\\\\n            from reviewer.src.llm_gateway.claude_gateway import ClaudeGateway\\\\n\\\\n            return ClaudeGateway(model_info=model_info)\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n        else:\\\\n            raise UnsupportedProviderError(model_info[\\\\\\\"provider\\\\\\\"])\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif model_info[\\\\\\\"provider\\\\\\\"] == \\\\\\\"google\\\\\\\":\\\\n            from reviewer.src.llm_gateway.google_gateway import GoogleGateway\\\\n\\\\n            return GoogleGateway(model_info=model_info)\\\\n```\\\", \\\"line_number\\\": 35}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/llm_factory.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 모듈\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport instructor\\\\nfrom google import genai\\\\n\\\\n\\\\nclass LLMClientFactory:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"LLM 클라이언트 팩토리 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"프로바이더에 맞는, 구조화된 응답을 지원하는 클라이언트를 생성합니다.\\\\n\\\\n        Args:\\\\n            provider: LLM 프로바이더 (openai 또는 claude)\\\\n            api_key: API 키\\\\n\\\\n        Returns:\\\\n            Instructor: instructor 래핑된 LLM 클라이언트\\\\n            genai.Client: Google Gemini 클라이언트\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 프로바이더인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if provider == \\\\\\\"openai\\\\\\\":\\\\n            from openai import OpenAI\\\\n\\\\n            return instructor.from_openai(OpenAI(api_key=api_key))\\\\n        elif provider == \\\\\\\"claude\\\\\\\":\\\\n            from anthropic import Anthropic\\\\n\\\\n            return instructor.from_anthropic(Anthropic(api_key=api_key))\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 LLM 프로바이더입니다: {provider}\\\\\\\")\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom google import genai\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    def create_client(provider: str, api_key: str) -> instructor.Instructor:\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    def create_client(\\\\n        provider: str, api_key: str\\\\n    ) -> instructor.Instructor | genai.Client:\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            genai.Client: Google Gemini 클라이언트\\\\n```\\\", \\\"line_number\\\": 0}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        elif provider == \\\\\\\"google\\\\\\\":\\\\n            return genai.Client(api_key=api_key)\\\\n```\\\", \\\"line_number\\\": 34}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/token_utils.py\\\", \\\"file_content\\\": \\\"import os\\\\nimport re\\\\n\\\\nimport tiktoken\\\\n\\\\nfrom .models import DiffAnalysisResult, EstimatedCost\\\\n\\\\n\\\\nclass TokenUtils:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"토큰 계산 및 비용 추정 유틸리티 클래스\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    @staticmethod\\\\n    def count_tokens(text: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"텍스트의 토큰 수를 계산합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 토큰 수\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Claude 모델인 경우 근사 토큰 계산 사용\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower():\\\\n            # Claude는 대략 1글자당 0.55 토큰으로 계산 (영어 기준)\\\\n            # 한글은 글자당 약 2-3자가 필요하므로 더 가중치 부여\\\\n            korean_chars = len(re.findall(\\\\\\\"[가-힣]\\\\\\\", text))\\\\n            english_chars = len(re.findall(\\\\\\\"[a-zA-Z]\\\\\\\", text))\\\\n            other_chars = len(text) - korean_chars - english_chars\\\\n\\\\n            # 한글은 글자당 1.5 토큰, 영어는 0.5 토큰, 기타 문자는 1 토큰으로 계산\\\\n            estimated_tokens = (\\\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\\\n            )\\\\n            return int(estimated_tokens)\\\\n\\\\n        # OpenAI 모델인 경우 tiktoken 사용\\\\n        try:\\\\n            encoding = tiktoken.encoding_for_model(model)\\\\n        except KeyError:\\\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\\\n            encoding = tiktoken.get_encoding(\\\\\\\"cl100k_base\\\\\\\")\\\\n\\\\n        return len(encoding.encode(text))\\\\n\\\\n    @staticmethod\\\\n    def get_model_context_limit(model: str) -> int:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"모델의 컨텍스트 제한을 반환합니다.\\\\n\\\\n        Args:\\\\n            model: 모델 이름\\\\n\\\\n        Returns:\\\\n            int: 컨텍스트 제한 (토큰 수)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        context_limits = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": 128000,\\\\n            \\\\\\\"o3-mini\\\\\\\": 200000,\\\\n            \\\\\\\"o4-mini\\\\\\\": 200000,\\\\n            \\\\\\\"gpt-4.1\\\\\\\": 1047576,\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": 200000,\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": 180000,\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 180000  # Claude 기본 컨텍스트 제한\\\\n\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n        return context_limits.get(model, 128000)  # 기본값은 gpt-4o의 제한\\\\n\\\\n    @staticmethod\\\\n    def estimate_cost(text: str, model_name: str = \\\\\\\"gpt-4o\\\\\\\") -> EstimatedCost:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"토큰 수를 기반으로 API 호출 비용을 추정합니다.\\\\n\\\\n        Args:\\\\n            text: 토큰 수를 계산할 텍스트\\\\n            model_name: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            EstimatedCost: 비용 추정 정보 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # 모델별 가격 (1K 토큰당 USD)\\\\n        token_count = TokenUtils.count_tokens(text, model_name)\\\\n        pricing = {\\\\n            \\\\\\\"gpt-4o\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0025, \\\\\\\"output\\\\\\\": 0.01},  # $2.50/$10.00 per 1M tokens\\\\n            \\\\\\\"gpt-4.1\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0020, \\\\\\\"output\\\\\\\": 0.0080},  # $2.00/$8.00 per 1M tokens\\\\n            \\\\\\\"o3-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"o4-mini\\\\\\\": {\\\\\\\"input\\\\\\\": 0.0011, \\\\\\\"output\\\\\\\": 0.0044},  # $1.10/$4.40 per 1M tokens\\\\n            \\\\\\\"claude-3-7-sonnet-20250219\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0075,\\\\n            },  # $1.50/$7.50 per 1M tokens\\\\n            \\\\\\\"claude-3-5-sonnet-20240620\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.003,\\\\n                \\\\\\\"output\\\\\\\": 0.015,\\\\n            },  # $3.00/$15.00 per 1M tokens\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n        }\\\\n\\\\n        # Claude 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"claude\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.0015, \\\\\\\"output\\\\\\\": 0.0075}  # Claude 기본 가격 사용\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n        else:\\\\n            # 모델이 pricing에 없는 경우 기본 모델 가격 사용\\\\n            model_pricing = pricing.get(model_name, pricing[\\\\\\\"gpt-4o\\\\\\\"])\\\\n\\\\n        # 입력 토큰 비용 계산\\\\n        input_cost = (token_count / 1000) * model_pricing[\\\\\\\"input\\\\\\\"]\\\\n\\\\n        # 예상 출력 토큰 수 (입력의 약 20%로 가정)\\\\n        estimated_output_tokens = int(token_count * 0.2)\\\\n        output_cost = (estimated_output_tokens / 1000) * model_pricing[\\\\\\\"output\\\\\\\"]\\\\n\\\\n        # 총 비용\\\\n        total_cost = input_cost + output_cost\\\\n\\\\n        return EstimatedCost(\\\\n            model=model_name,\\\\n            input_tokens=token_count,\\\\n            input_cost_usd=round(input_cost, 6),\\\\n            estimated_output_tokens=estimated_output_tokens,\\\\n            estimated_output_cost_usd=round(output_cost, 6),\\\\n            estimated_total_cost_usd=round(total_cost, 6),\\\\n            within_context_limit=token_count\\\\n            <= TokenUtils.get_model_context_limit(model_name),\\\\n        )\\\\n\\\\n    @staticmethod\\\\n    def analyze_diff_file(file_path: str, model: str = \\\\\\\"gpt-4o\\\\\\\") -> DiffAnalysisResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"diff 파일을 분석하여 토큰 수와 비용을 계산합니다.\\\\n\\\\n        Args:\\\\n            file_path: diff 파일 경로\\\\n            model: 사용할 모델 이름\\\\n\\\\n        Returns:\\\\n            DiffAnalysisResult: 분석 결과 객체\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n                diff_content = f.read()\\\\n\\\\n            # 비용 추정\\\\n            cost_info = TokenUtils.estimate_cost(diff_content, model)\\\\n\\\\n            return DiffAnalysisResult(\\\\n                model=cost_info.model,\\\\n                input_tokens=cost_info.input_tokens,\\\\n                input_cost_usd=cost_info.input_cost_usd,\\\\n                estimated_output_tokens=cost_info.estimated_output_tokens,\\\\n                estimated_output_cost_usd=cost_info.estimated_output_cost_usd,\\\\n                estimated_total_cost_usd=cost_info.estimated_total_cost_usd,\\\\n                within_context_limit=cost_info.within_context_limit,\\\\n                character_count=len(diff_content),\\\\n                line_count=diff_content.count(\\\\\\\"\\\\\\\\n\\\\\\\") + 1,\\\\n                file_path=file_path,\\\\n                file_size_kb=os.path.getsize(file_path) / 1024,\\\\n            )\\\\n        except Exception as e:\\\\n            return DiffAnalysisResult(\\\\n                model=model,  # 에러 시 모델명이라도 전달\\\\n                input_tokens=0,\\\\n                input_cost_usd=0.0,\\\\n                estimated_output_tokens=0,\\\\n                estimated_output_cost_usd=0.0,\\\\n                estimated_total_cost_usd=0.0,\\\\n                within_context_limit=False,\\\\n                character_count=0,\\\\n                line_count=0,\\\\n                file_path=file_path,\\\\n                file_size_kb=0.0,\\\\n                error=str(e),\\\\n            )\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": 1048576,  # Gemini 2.5 Pro: 약 1M 토큰\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": 1048576,  # Gemini 2.5 Flash: 약 1M 토큰\\\\n```\\\", \\\"line_number\\\": 63}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Gemini 모델이지만 정확히 매칭되지 않는 경우\\\\n        if \\\\\\\"gemini\\\\\\\" in model.lower() and model not in context_limits:\\\\n            return 1048576  # Gemini 기본 컨텍스트 제한\\\\n\\\\n```\\\", \\\"line_number\\\": 71}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"gemini-2.5-pro-exp-03-25\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.0015,\\\\n                \\\\\\\"output\\\\\\\": 0.0060,\\\\n            },  # $1.50/$6.00 per 1M tokens (Gemini 2.5 Pro)\\\\n            \\\\\\\"gemini-2.5-flash\\\\\\\": {\\\\n                \\\\\\\"input\\\\\\\": 0.00015,\\\\n                \\\\\\\"output\\\\\\\": 0.0006,\\\\n            },  # $0.15/$0.60 per 1M tokens (Gemini 2.5 Flash)\\\\n```\\\", \\\"line_number\\\": 103}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"original_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\\\n        elif \\\\\\\"gemini\\\\\\\" in model_name.lower() and model_name not in pricing:\\\\n            # Gemini 기본 가격 (Flash 모델 기준)\\\\n            model_pricing = {\\\\\\\"input\\\\\\\": 0.00015, \\\\\\\"output\\\\\\\": 0.0006}\\\\n```\\\", \\\"line_number\\\": 116}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"design\", \"line_number\": 39, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"토큰 계산 로직에서 Claude 모델 외에는 `tiktoken`을 사용하고 있습니다. `tiktoken`은 OpenAI 모델에 최적화되어 있으며, Google Gemini 모델의 정확한 토큰 수를 계산하지 못할 수 있습니다. 정확한 토큰 수는 컨텍스트 제한 확인 및 비용 추정에 중요합니다.\", \"suggestion\": \"Google Gemini 모델에 대해서는 `google-generativeai` 라이브러리 등 Google에서 제공하는 공식 토크나이저를 사용하여 정확한 토큰 수를 계산하도록 로직을 추가해야 합니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n        # OpenAI 모델인 경우 tiktoken 사용\\n        try:\\n            encoding = tiktoken.encoding_for_model(model)\\n        except KeyError:\\n            # 모델이 tiktoken에 없는 경우 기본 인코딩 사용\\n            encoding = tiktoken.get_encoding(\\\"cl100k_base\\\")\\n\\n        return len(encoding.encode(text))\\n```\", \"improved_code\": \"```python\\n        # OpenAI 모델인 경우 tiktoken 사용\\n        if \\\"gemini\\\" in model.lower():\\n            # TODO: Google Gemini 공식 토크나이저 사용\\n            # 예: from google.generativeai import get_tokenizer\\n            # tokenizer = get_tokenizer(model)\\n            # return len(tokenizer.encode(text))\\n            # 현재는 임시로 tiktoken 사용 (정확하지 않을 수 있음)\\n            try:\\n                encoding = tiktoken.encoding_for_model(model)\\n            except KeyError:\\n                encoding = tiktoken.get_encoding(\\\"cl100k_base\\\")\\n            return len(encoding.encode(text))\\n        elif \\\"claude\\\" in model.lower():\\n            # Claude 토큰 계산 로직 유지\\n            korean_chars = len(re.findall(\\\"[가-힣]\\\", text))\\n            english_chars = len(re.findall(\\\"[a-zA-Z]\\\", text))\\n            other_chars = len(text) - korean_chars - english_chars\\n            estimated_tokens = (\\n                (korean_chars * 1.5) + (english_chars * 0.5) + other_chars\\n            )\\n            return int(estimated_tokens)\\n        else:\\n            # 기타 모델 (주로 OpenAI)은 tiktoken 사용\\n            try:\\n                encoding = tiktoken.encoding_for_model(model)\\n            except KeyError:\\n                encoding = tiktoken.get_encoding(\\\"cl100k_base\\\")\\n            return len(encoding.encode(text))\\n```\"}, {\"type\": \"accuracy\", \"line_number\": 115, \"file\": \"reviewer/src/utils/token/token_utils.py\", \"description\": \"`estimate_cost` 함수에서 Google Gemini 모델의 가격 정보가 `pricing` 딕셔너리에 명시적으로 없을 경우, 기본값으로 `gemini-2.5-flash`의 가격을 사용합니다. 이는 더 비싼 Gemini 모델(예: Pro 버전)이 사용될 경우 실제 비용보다 현저히 낮게 추정될 수 있습니다.\", \"suggestion\": \"`pricing` 딕셔너리에 지원하는 모든 Google Gemini 모델의 가격 정보를 명시적으로 추가해야 합니다. 또는 알 수 없는 모델에 대해 더 보수적인(높은) 가격을 사용하거나 경고/오류를 발생시키는 로직을 고려할 수 있습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\n        elif \\\"gemini\\\" in model_name.lower() and model_name not in pricing:\\n            # Gemini 기본 가격 (Flash 모델 기준)\\n            model_pricing = {\\\"input\\\": 0.00015, \\\"output\\\": 0.0006}\\n```\", \"improved_code\": \"```python\\n        # Google 모델이지만 정확히 매칭되지 않는 경우\\n        # TODO: 알 수 없는 Gemini 모델에 대한 가격 정책 재검토 (경고 또는 보수적 가격 사용)\\n        elif \\\"gemini\\\" in model_name.lower() and model_name not in pricing:\\n            # 현재는 Flash 모델 가격 사용 (주의: 실제 비용과 다를 수 있음)\\n            model_pricing = {\\\"input\\\": 0.00015, \\\"output\\\": 0.0006}\\n```\"}], \"summary\": \"이 변경사항은 Google Gemini 모델 지원을 추가합니다. CLI 설정, 지원 모델 목록, 게이트웨이 팩토리, LLM 클라이언트 팩토리, 토큰 유틸리티 등 여러 모듈에 걸쳐 Gemini 관련 코드가 통합되었습니다. 전반적으로 새로운 모델을 시스템에 연결하는 구조는 잘 구현되었습니다.\", \"score\": 8.0, \"recommendations\": [\"Google Gemini 모델에 대한 정확한 토큰 계산을 위해 공식 토크나이저를 사용하도록 `TokenUtils.count_tokens` 함수를 개선하세요.\", \"`TokenUtils.estimate_cost` 함수에서 지원하는 모든 Gemini 모델의 가격 정보를 명시적으로 관리하여 비용 추정의 정확성을 높이세요.\", \"알 수 없는 모델이 사용될 경우 사용자에게 명확한 피드백(경고 또는 오류)을 제공하는 로직을 추가하는 것을 고려하세요.\"]}"
  }
]