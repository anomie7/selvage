[
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. \\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"after_code_start_line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7.  `issues[].line_number` 결정 방법:\\n    a.  `issues[].line_number`는 `target_code` (리뷰 대상 코드 스니펫)가 `file_content` 전체에서 시작하는 **절대적인 1-based 라인 번호**여야 합니다.\\n    b.  이 값을 결정하기 위해 `target_code`가 속한 `hunk`의 다음 정보들을 사용합니다:\\n        i.  `formatted_hunks[].after_code`: 수정 후 코드 블록 문자열입니다.\\n        ii. `formatted_hunks[].after_code_line_numbers`: `after_code`의 각 라인에 해당하는 `file_content` 기준 절대 1-based 라인 번호들이 순서대로 담긴 리스트입니다. 이 리스트의 길이는 `after_code`의 총 라인 수와 정확히 일치해야 합니다.\\n        iii. `target_code`: 리뷰 대상 코드 스니펫으로, `after_code`의 일부여야 합니다.\\n    c.  **계산 단계:**\\n        1.  **`target_code`의 상대 시작 위치 파악:** `target_code`의 첫 번째 라인이 `after_code` 내에서 몇 번째 라인(1-based)에서 시작하는지 정확히 파악합니다. 이를 \\\"상대 시작 라인 번호\\\"라고 합니다. (예: `target_code`의 첫 줄이 `after_code`의 3번째 줄과 내용이 같다면, \\\"상대 시작 라인 번호\\\"는 `3`입니다.)\\n        2.  **절대 라인 번호 조회:** 파악된 \\\"상대 시작 라인 번호\\\"를 사용하여 `after_code_line_numbers` 리스트에서 해당 위치의 값을 가져옵니다. 리스트는 0-based 인덱스를 사용하므로, `issues[].line_number = after_code_line_numbers[ (상대 시작 라인 번호) - 1 ]` 공식을 사용합니다.\\n    d.  **예시:**\\n        `after_code`가 3줄이고, `after_code_line_numbers`가 `[50, 51, 52]`라고 가정합니다.\\n        만약 `target_code`의 첫 번째 라인이 `after_code`의 `2`번째 라인 내용과 일치한다면, \\\"상대 시작 라인 번호\\\"는 `2`입니다.\\n        따라서, `issues[].line_number = after_code_line_numbers[2 - 1] = after_code_line_numbers[1]` 이므로, `issues[].line_number`는 `51`이 됩니다.\\n    e.  `target_code`가 여러 라인에 걸쳐 있는 경우, `target_code`의 **첫 번째 라인**을 기준으로 `issues[].line_number`를 결정합니다.\\n    f.  만약 `target_code`를 `after_code` 내에서 찾을 수 없거나, \\\"상대 시작 라인 번호\\\"를 정확히 특정할 수 없는 경우, `issues[].line_number`는 `null`로 설정하고, 필요한 경우 `description`에 해당 상황을 간략히 언급합니다.\\n    g.  (기존의 파일 전체에 대한 이슈 처리 시 `null` 사용 등 관련 규칙 유지)\\n8. 특정 코드 라인을 삭제하거나 파일을 삭제해야 하는 경우, suggested_code 최상단에 \\\"코드 라인 제거\\\" 또는 \\\"파일 제거\\\" 라는 문구를 명시하고, 그 아래에 제거 대상 코드를 주석 처리하여 제공하세요.\\n   예를 들어, Python 코드 삭제 시 # 코드 라인 제거\\\\n# print(\\\"삭제될 코드\\\") 와 같이 표현합니다. 만약 여러 라인이라면 각 라인을 주석 처리합니다.\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"파일 형식 결정 중 오류 발생: {e}\\\\\\\")\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        file_format = determine_file_format(file_path)\\\\n\\\\n        if file_format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"after_code_start_line_number\\\": 13, \\\"after_code_line_numbers\\\": [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"after_code_start_line_number\\\": 506, \\\"after_code_line_numbers\\\": [506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516]}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 24, \"file\": \"reviewer/src/ui.py\", \"description\": \"상대 경로 임포트를 위한 `sys.path.append` 코드가 제거되었지만, 해당 주석이 남아있어 코드의 의도를 오해하게 만들 수 있습니다. 불필요한 주석과 빈 줄을 제거하는 것이 좋습니다.\", \"suggestion\": \"관련 없는 주석과 빈 줄을 제거하여 코드를 정리하세요.\", \"severity\": \"info\", \"target_code\": \"\\n# 상대 경로 임포트를 위한 경로 설정\\n\\n# 상대 경로 임포트를 위한 경로 설정\", \"suggested_code\": \"\"}], \"summary\": \"불필요한 상대 경로 임포트 설정 코드를 제거하고 관련 주석을 정리했습니다. 함수 내부의 import 문을 파일 상단으로 이동시켜 코드 구조를 개선했습니다.\", \"score\": 9.0, \"recommendations\": [\"코드 변경 시 관련 주석도 함께 수정하거나 제거하여 코드와 주석의 일관성을 유지하는 것이 중요합니다.\", \"import 문은 일반적으로 파일 상단에 모아두는 것이 가독성에 좋습니다. `run_app` 함수 내부에 있던 `import subprocess`도 파일 상단으로 옮기는 것을 고려해볼 수 있습니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. \\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"after_code_start_line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7.  `issues[].line_number` 결정 방법:\\n    a.  `issues[].line_number`는 `target_code` (리뷰 대상 코드 스니펫)가 `file_content` 전체에서 시작하는 **절대적인 1-based 라인 번호**여야 합니다.\\n    b.  이 값을 결정하기 위해 `target_code`가 속한 `hunk`의 다음 정보들을 사용합니다:\\n        i.  `formatted_hunks[].after_code`: 수정 후 코드 블록 문자열입니다.\\n        ii. `formatted_hunks[].after_code_line_numbers`: `after_code`의 각 라인에 해당하는 `file_content` 기준 절대 1-based 라인 번호들이 순서대로 담긴 리스트입니다. 이 리스트의 길이는 `after_code`의 총 라인 수와 정확히 일치해야 합니다.\\n        iii. `target_code`: 리뷰 대상 코드 스니펫으로, `after_code`의 일부여야 합니다.\\n    c.  **계산 단계:**\\n        1.  **`target_code`의 상대 시작 위치 파악:** `target_code`의 첫 번째 라인이 `after_code` 내에서 몇 번째 라인(1-based)에서 시작하는지 정확히 파악합니다. 이를 \\\"상대 시작 라인 번호\\\"라고 합니다. (예: `target_code`의 첫 줄이 `after_code`의 3번째 줄과 내용이 같다면, \\\"상대 시작 라인 번호\\\"는 `3`입니다.)\\n        2.  **절대 라인 번호 조회:** 파악된 \\\"상대 시작 라인 번호\\\"를 사용하여 `after_code_line_numbers` 리스트에서 해당 위치의 값을 가져옵니다. 리스트는 0-based 인덱스를 사용하므로, `issues[].line_number = after_code_line_numbers[ (상대 시작 라인 번호) - 1 ]` 공식을 사용합니다.\\n    d.  **예시:**\\n        `after_code`가 3줄이고, `after_code_line_numbers`가 `[50, 51, 52]`라고 가정합니다.\\n        만약 `target_code`의 첫 번째 라인이 `after_code`의 `2`번째 라인 내용과 일치한다면, \\\"상대 시작 라인 번호\\\"는 `2`입니다.\\n        따라서, `issues[].line_number = after_code_line_numbers[2 - 1] = after_code_line_numbers[1]` 이므로, `issues[].line_number`는 `51`이 됩니다.\\n    e.  `target_code`가 여러 라인에 걸쳐 있는 경우, `target_code`의 **첫 번째 라인**을 기준으로 `issues[].line_number`를 결정합니다.\\n    f.  만약 `target_code`를 `after_code` 내에서 찾을 수 없거나, \\\"상대 시작 라인 번호\\\"를 정확히 특정할 수 없는 경우, `issues[].line_number`는 `null`로 설정하고, 필요한 경우 `description`에 해당 상황을 간략히 언급합니다.\\n    g.  (기존의 파일 전체에 대한 이슈 처리 시 `null` 사용 등 관련 규칙 유지)\\n8. 특정 코드 라인을 삭제하거나 파일을 삭제해야 하는 경우, suggested_code 최상단에 \\\"코드 라인 제거\\\" 또는 \\\"파일 제거\\\" 라는 문구를 명시하고, 그 아래에 제거 대상 코드를 주석 처리하여 제공하세요.\\n   예를 들어, Python 코드 삭제 시 # 코드 라인 제거\\\\n# print(\\\"삭제될 코드\\\") 와 같이 표현합니다. 만약 여러 라인이라면 각 라인을 주석 처리합니다.\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 364, \\\"after_code_line_numbers\\\": [364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375]}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\\n\\\\n    이 클래스는 리뷰 응답을 마크다운, HTML 등 다양한 출력 형식으로 변환하는 기능을 제공합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def format(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info {  }\\\\\\\",\\\\n            \\\\\\\".warning {  }\\\\\\\",\\\\n            \\\\\\\".error {  }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info {  }\\\\\\\",\\\\n            \\\\\\\".warning {  }\\\\\\\",\\\\n            \\\\\\\".error {  }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n```\\\", \\\"after_code_start_line_number\\\": 109, \\\"after_code_line_numbers\\\": [109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124]}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"style\", \"line_number\": 114, \"file\": \"reviewer/src/utils/review_formatter.py\", \"description\": \"HTML 출력 시 이슈 심각도에 따른 시각적 구분을 위한 CSS 스타일(`.issue`, `.info`, `.warning`, `.error`의 `background-color`, `border-left` 등)이 제거되었습니다. 이로 인해 HTML 결과에서 이슈의 심각도를 한눈에 파악하기 어려워졌습니다.\", \"suggestion\": \"이슈 심각도에 따라 다른 배경색이나 테두리 색상을 적용하는 CSS 스타일을 복원하여 가독성을 높이는 것을 고려해 보세요.\", \"severity\": \"info\", \"target_code\": \".issue { padding: 10px; margin-bottom: 15px; }\\n.info {  }\\n.warning {  }\\n.error {  }\", \"suggested_code\": \".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\n.info { border-left-color: #2196F3; }\\n.warning { border-left-color: #FF9800; }\\n.error { border-left-color: #F44336; }\"}], \"summary\": \"Streamlit UI에서 리뷰 결과 표시 형식을 HTML에서 마크다운으로 변경하고, 리뷰 결과 HTML 형식에서 이슈 심각도에 따른 시각적 스타일이 제거되었습니다.\", \"score\": 8.0, \"recommendations\": [\"HTML 출력을 사용하는 다른 부분이 있다면, 해당 부분의 가독성을 위해 `to_html` 메서드의 스타일 복원을 고려하십시오.\", \"Streamlit UI에서 마크다운 형식을 사용하기로 결정했다면, `ReviewFormatter` 클래스에서 `to_html` 메서드를 제거하거나 deprecated 처리하는 것을 고려할 수 있습니다 (만약 다른 곳에서 사용되지 않는다면).\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. \\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"after_code_start_line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7.  `issues[].line_number` 결정 방법:\\n    a.  `issues[].line_number`는 `target_code` (리뷰 대상 코드 스니펫)가 `file_content` 전체에서 시작하는 **절대적인 1-based 라인 번호**여야 합니다.\\n    b.  이 값을 결정하기 위해 `target_code`가 속한 `hunk`의 다음 정보들을 사용합니다:\\n        i.  `formatted_hunks[].after_code`: 수정 후 코드 블록 문자열입니다.\\n        ii. `formatted_hunks[].after_code_line_numbers`: `after_code`의 각 라인에 해당하는 `file_content` 기준 절대 1-based 라인 번호들이 순서대로 담긴 리스트입니다. 이 리스트의 길이는 `after_code`의 총 라인 수와 정확히 일치해야 합니다.\\n        iii. `target_code`: 리뷰 대상 코드 스니펫으로, `after_code`의 일부여야 합니다.\\n    c.  **계산 단계:**\\n        1.  **`target_code`의 상대 시작 위치 파악:** `target_code`의 첫 번째 라인이 `after_code` 내에서 몇 번째 라인(1-based)에서 시작하는지 정확히 파악합니다. 이를 \\\"상대 시작 라인 번호\\\"라고 합니다. (예: `target_code`의 첫 줄이 `after_code`의 3번째 줄과 내용이 같다면, \\\"상대 시작 라인 번호\\\"는 `3`입니다.)\\n        2.  **절대 라인 번호 조회:** 파악된 \\\"상대 시작 라인 번호\\\"를 사용하여 `after_code_line_numbers` 리스트에서 해당 위치의 값을 가져옵니다. 리스트는 0-based 인덱스를 사용하므로, `issues[].line_number = after_code_line_numbers[ (상대 시작 라인 번호) - 1 ]` 공식을 사용합니다.\\n    d.  **예시:**\\n        `after_code`가 3줄이고, `after_code_line_numbers`가 `[50, 51, 52]`라고 가정합니다.\\n        만약 `target_code`의 첫 번째 라인이 `after_code`의 `2`번째 라인 내용과 일치한다면, \\\"상대 시작 라인 번호\\\"는 `2`입니다.\\n        따라서, `issues[].line_number = after_code_line_numbers[2 - 1] = after_code_line_numbers[1]` 이므로, `issues[].line_number`는 `51`이 됩니다.\\n    e.  `target_code`가 여러 라인에 걸쳐 있는 경우, `target_code`의 **첫 번째 라인**을 기준으로 `issues[].line_number`를 결정합니다.\\n    f.  만약 `target_code`를 `after_code` 내에서 찾을 수 없거나, \\\"상대 시작 라인 번호\\\"를 정확히 특정할 수 없는 경우, `issues[].line_number`는 `null`로 설정하고, 필요한 경우 `description`에 해당 상황을 간략히 언급합니다.\\n    g.  (기존의 파일 전체에 대한 이슈 처리 시 `null` 사용 등 관련 규칙 유지)\\n8. 특정 코드 라인을 삭제하거나 파일을 삭제해야 하는 경우, suggested_code 최상단에 \\\"코드 라인 제거\\\" 또는 \\\"파일 제거\\\" 라는 문구를 명시하고, 그 아래에 제거 대상 코드를 주석 처리하여 제공하세요.\\n   예를 들어, Python 코드 삭제 시 # 코드 라인 제거\\\\n# print(\\\"삭제될 코드\\\") 와 같이 표현합니다. 만약 여러 라인이라면 각 라인을 주석 처리합니다.\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n```\\\", \\\"after_code_start_line_number\\\": 9, \\\"after_code_line_numbers\\\": [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174]}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n```\\\", \\\"after_code_start_line_number\\\": 178, \\\"after_code_line_numbers\\\": [178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435]}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n```\\\", \\\"after_code_start_line_number\\\": 437, \\\"after_code_line_numbers\\\": [437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468]}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 475, \\\"after_code_line_numbers\\\": [475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491]}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```python\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n```\\\", \\\"after_code_start_line_number\\\": 493, \\\"after_code_line_numbers\\\": [493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503]}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"before_code\\\": \\\"```python\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n\\\\n                    if show_raw_json:\\\\n                        st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n                        data_to_display = copy.deepcopy(json_data)\\\\n                        target_keys_in_order = [\\\\n                            \\\\\\\"prompt\\\\\\\",\\\\n                            \\\\\\\"review_request\\\\\\\",\\\\n                            \\\\\\\"review_response\\\\\\\",\\\\n                        ]\\\\n\\\\n                        for key_to_expand in target_keys_in_order:\\\\n                            if key_to_expand in data_to_display:\\\\n                                value = data_to_display.pop(key_to_expand)\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                                ):\\\\n                                    if key_to_expand == \\\\\\\"prompt\\\\\\\" and isinstance(\\\\n                                        value, list\\\\n                                    ):\\\\n                                        parsed_prompt_list = []\\\\n                                        for p_item in value:\\\\n                                            p_item_copy = copy.deepcopy(p_item)\\\\n                                            if (\\\\n                                                isinstance(p_item_copy, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in p_item_copy\\\\n                                                and isinstance(\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"], str\\\\n                                                )\\\\n                                            ):\\\\n                                                try:\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        p_item_copy[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_list.append(p_item_copy)\\\\n                                        st.json(parsed_prompt_list, expanded=True)\\\\n                                    elif value:  # Check if value is not None or empty\\\\n                                        st.json(value, expanded=True)\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                        if data_to_display:\\\\n                            st.markdown(\\\\\\\"---\\\\\\\")\\\\n                            st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n                            st.json(json_data, expanded=False)\\\\n                    else:\\\\n                        if (\\\\n                            \\\\\\\"review_response\\\\\\\" in json_data\\\\n                            and json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        ):\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            st.markdown(html_content, unsafe_allow_html=True)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n                    target_keys_in_order = [\\\\n                        \\\\\\\"prompt\\\\\\\",\\\\n                        \\\\\\\"review_request\\\\\\\",\\\\n                        \\\\\\\"review_response\\\\\\\",\\\\n                    ]\\\\n\\\\n                    for key_to_expand in target_keys_in_order:\\\\n                        if key_to_expand in data_to_display:\\\\n                            value = data_to_display.pop(key_to_expand)\\\\n                            with st.expander(\\\\n                                f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                            ):\\\\n                                if key_to_expand == \\\\\\\"prompt\\\\\\\":\\\\n                                    parsed_prompt_content = []\\\\n                                    if isinstance(value, list):\\\\n                                        for item_prompt in value:\\\\n                                            item_c = copy.deepcopy(item_prompt)\\\\n                                            if (\\\\n                                                isinstance(item_c, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in item_c\\\\n                                                and isinstance(item_c[\\\\\\\"content\\\\\\\"], str)\\\\n                                            ):\\\\n                                                try:\\\\n                                                    item_c[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        item_c[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_content.append(item_c)\\\\n                                        st.json(parsed_prompt_content, expanded=True)\\\\n                                    else:\\\\n                                        st.json(value, expanded=True)  # Fallback\\\\n                                elif key_to_expand == \\\\\\\"review_response\\\\\\\":\\\\n                                    if value:\\\\n                                        try:\\\\n                                            review_response_obj = (\\\\n                                                ReviewResponse.model_validate(value)\\\\n                                            )\\\\n                                            formatter = ReviewFormatter()\\\\n                                            html_content = formatter.to_html(\\\\n                                                review_response_obj\\\\n                                            )\\\\n                                            st.markdown(\\\\n                                                html_content, unsafe_allow_html=True\\\\n                                            )\\\\n                                            with st.expander(\\\\n                                                f\\\\\\\"{key_to_expand} 원본 JSON 보기\\\\\\\",\\\\n                                                expanded=False,\\\\n                                            ):\\\\n                                                st.json(value, expanded=True)\\\\n                                        except Exception:\\\\n                                            st.json(\\\\n                                                value, expanded=True\\\\n                                            )  # Fallback to raw JSON\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n                                elif (\\\\n                                    value\\\\n                                ):  # For review_request and other potential future keys\\\\n                                    st.json(value, expanded=True)\\\\n                                else:\\\\n                                    st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                    if data_to_display:\\\\n                        st.markdown(\\\\\\\"---\\\\\\\")\\\\n                        st.markdown(\\\\\\\"### 기타 로그 정보\\\\\\\")\\\\n                        st.json(data_to_display, expanded=False)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n```\\\", \\\"after_code_start_line_number\\\": 506, \\\"after_code_line_numbers\\\": [506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530]}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"design\", \"line_number\": 89, \"file\": \"reviewer/src/ui.py\", \"description\": \"파일명에서 모델 이름을 추출하는 로직이 특정 패턴에만 의존하며, 마지막 부분이 숫자가 아니면 모델명으로 간주하는 부분이 부정확할 수 있습니다. 예상치 못한 파일명 형식에 대해 모델 이름 추출이 실패하거나 잘못된 결과를 반환할 가능성이 있습니다.\", \"suggestion\": \"파일명 명명 규칙을 명확히 정의하고, 해당 규칙에 맞춰 모델 이름을 더 정확하게 파싱하는 로직을 구현하거나, 파싱 실패 시 기본값 처리 등을 개선하는 것이 좋습니다. 또는 파일명 규칙을 UI에 명시하여 사용자가 이해하도록 돕는 방법도 있습니다.\", \"severity\": \"warning\", \"target_code\": \"def extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\", \"suggested_code\": null}, {\"type\": \"style\", \"line_number\": 285, \"file\": \"reviewer/src/ui.py\", \"description\": \"`st.html` 함수는 더 이상 사용되지 않으며, 대신 `st.markdown`에 `unsafe_allow_html=True` 옵션을 사용하는 것이 권장됩니다.\", \"suggestion\": \"`st.html` 호출을 `st.markdown`으로 변경하여 최신 Streamlit API를 따르도록 수정하세요.\", \"severity\": \"info\", \"target_code\": \"st.html(html_content)\", \"suggested_code\": \"st.markdown(html_content, unsafe_allow_html=True)\"}, {\"type\": \"bug\", \"line_number\": 136, \"file\": \"reviewer/src/ui.py\", \"description\": \"`determine_file_format` 함수에서 넓은 범위의 `Exception`을 포착하고 있습니다. 이는 예상치 못한 오류를 숨기고 디버깅을 어렵게 만들 수 있습니다.\", \"suggestion\": \"특정 예외(예: `FileNotFoundError`, `PermissionError` 등)만 포착하거나, 예외 발생 시 로깅을 추가하여 어떤 오류가 발생했는지 파악할 수 있도록 개선하세요.\", \"severity\": \"warning\", \"target_code\": \"except Exception:\", \"suggested_code\": \"except Exception as e:\\n    logger.error(f\\\"Error determining file format for {file_path}: {e}\\\")\\n    return \\\"txt\\\"\"}], \"summary\": \"Streamlit UI 코드에서 파일 정보 추출 및 표시 로직을 여러 함수로 분리하여 모듈성과 가독성을 크게 개선했습니다. 사용되지 않는 코드와 보기 유형을 제거하여 코드를 간소화했습니다. 파일명 파싱의 견고성, deprecated 함수 사용, 넓은 범위의 예외 처리 등 몇 가지 개선할 부분이 있습니다.\", \"score\": 8.0, \"recommendations\": [\"파일명 파싱 로직의 견고성을 높이거나, 예상되는 파일명 패턴에 대한 문서를 추가합니다.\", \"넓은 범위의 `except Exception` 대신 더 구체적인 예외를 처리하거나, 예외 발생 시 상세한 로깅을 추가하여 디버깅을 용이하게 합니다.\", \"새로 추가된 함수들에 대한 단위 테스트를 작성하여 각 함수의 기능이 예상대로 동작하는지 확인합니다.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. \\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"after_code_start_line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7.  `issues[].line_number` 결정 방법:\\n    a.  `issues[].line_number`는 `target_code` (리뷰 대상 코드 스니펫)가 `file_content` 전체에서 시작하는 **절대적인 1-based 라인 번호**여야 합니다.\\n    b.  이 값을 결정하기 위해 `target_code`가 속한 `hunk`의 다음 정보들을 사용합니다:\\n        i.  `formatted_hunks[].after_code`: 수정 후 코드 블록 문자열입니다.\\n        ii. `formatted_hunks[].after_code_line_numbers`: `after_code`의 각 라인에 해당하는 `file_content` 기준 절대 1-based 라인 번호들이 순서대로 담긴 리스트입니다. 이 리스트의 길이는 `after_code`의 총 라인 수와 정확히 일치해야 합니다.\\n        iii. `target_code`: 리뷰 대상 코드 스니펫으로, `after_code`의 일부여야 합니다.\\n    c.  **계산 단계:**\\n        1.  **`target_code`의 상대 시작 위치 파악:** `target_code`의 첫 번째 라인이 `after_code` 내에서 몇 번째 라인(1-based)에서 시작하는지 정확히 파악합니다. 이를 \\\"상대 시작 라인 번호\\\"라고 합니다. (예: `target_code`의 첫 줄이 `after_code`의 3번째 줄과 내용이 같다면, \\\"상대 시작 라인 번호\\\"는 `3`입니다.)\\n        2.  **절대 라인 번호 조회:** 파악된 \\\"상대 시작 라인 번호\\\"를 사용하여 `after_code_line_numbers` 리스트에서 해당 위치의 값을 가져옵니다. 리스트는 0-based 인덱스를 사용하므로, `issues[].line_number = after_code_line_numbers[ (상대 시작 라인 번호) - 1 ]` 공식을 사용합니다.\\n    d.  **예시:**\\n        `after_code`가 3줄이고, `after_code_line_numbers`가 `[50, 51, 52]`라고 가정합니다.\\n        만약 `target_code`의 첫 번째 라인이 `after_code`의 `2`번째 라인 내용과 일치한다면, \\\"상대 시작 라인 번호\\\"는 `2`입니다.\\n        따라서, `issues[].line_number = after_code_line_numbers[2 - 1] = after_code_line_numbers[1]` 이므로, `issues[].line_number`는 `51`이 됩니다.\\n    e.  `target_code`가 여러 라인에 걸쳐 있는 경우, `target_code`의 **첫 번째 라인**을 기준으로 `issues[].line_number`를 결정합니다.\\n    f.  만약 `target_code`를 `after_code` 내에서 찾을 수 없거나, \\\"상대 시작 라인 번호\\\"를 정확히 특정할 수 없는 경우, `issues[].line_number`는 `null`로 설정하고, 필요한 경우 `description`에 해당 상황을 간략히 언급합니다.\\n    g.  (기존의 파일 전체에 대한 이슈 처리 시 `null` 사용 등 관련 규칙 유지)\\n8. 특정 코드 라인을 삭제하거나 파일을 삭제해야 하는 경우, suggested_code 최상단에 \\\"코드 라인 제거\\\" 또는 \\\"파일 제거\\\" 라는 문구를 명시하고, 그 아래에 제거 대상 코드를 주석 처리하여 제공하세요.\\n   예를 들어, Python 코드 삭제 시 # 코드 라인 제거\\\\n# print(\\\"삭제될 코드\\\") 와 같이 표현합니다. 만약 여러 라인이라면 각 라인을 주석 처리합니다.\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 원본 JSON 데이터 보기 체크박스 추가\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n\\\\n                    if show_raw_json:\\\\n                        st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n                        data_to_display = copy.deepcopy(json_data)\\\\n                        target_keys_in_order = [\\\\n                            \\\\\\\"prompt\\\\\\\",\\\\n                            \\\\\\\"review_request\\\\\\\",\\\\n                            \\\\\\\"review_response\\\\\\\",\\\\n                        ]\\\\n\\\\n                        for key_to_expand in target_keys_in_order:\\\\n                            if key_to_expand in data_to_display:\\\\n                                value = data_to_display.pop(key_to_expand)\\\\n                                with st.expander(\\\\n                                    f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                                ):\\\\n                                    if key_to_expand == \\\\\\\"prompt\\\\\\\" and isinstance(\\\\n                                        value, list\\\\n                                    ):\\\\n                                        parsed_prompt_list = []\\\\n                                        for p_item in value:\\\\n                                            p_item_copy = copy.deepcopy(p_item)\\\\n                                            if (\\\\n                                                isinstance(p_item_copy, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in p_item_copy\\\\n                                                and isinstance(\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"], str\\\\n                                                )\\\\n                                            ):\\\\n                                                try:\\\\n                                                    p_item_copy[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        p_item_copy[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_list.append(p_item_copy)\\\\n                                        st.json(parsed_prompt_list, expanded=True)\\\\n                                    elif value:  # Check if value is not None or empty\\\\n                                        st.json(value, expanded=True)\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                        if data_to_display:\\\\n                            st.markdown(\\\\\\\"---\\\\\\\")\\\\n                            st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n                            st.json(json_data, expanded=False)\\\\n                    else:\\\\n                        if (\\\\n                            \\\\\\\"review_response\\\\\\\" in json_data\\\\n                            and json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        ):\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            # st.markdown(html_content, unsafe_allow_html=True)\\\\n                            st.html(html_content)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_results_dir, get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n```\\\", \\\"after_code_start_line_number\\\": 20, \\\"after_code_line_numbers\\\": [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n```\\\", \\\"after_code_start_line_number\\\": 32, \\\"after_code_line_numbers\\\": [32, 33, 34, 35, 36, 37, 38, 39, 40, 41]}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n```\\\", \\\"after_code_start_line_number\\\": 45, \\\"after_code_line_numbers\\\": [45, 46, 47, 48, 49, 50, 51, 52, 53, 54]}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 188, \\\"after_code_line_numbers\\\": [188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211]}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            `​``\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n```\\\", \\\"after_code_start_line_number\\\": 223, \\\"after_code_line_numbers\\\": [223, 224, 225, 226, 227, 228, 229, 230, 231, 232]}, {\\\"hunk_idx\\\": \\\"6\\\", \\\"before_code\\\": \\\"```python\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 원본 JSON 데이터 보기 체크박스 추가\\\\n                    if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                        st.session_state.show_raw_json = False\\\\n                    show_raw_json = st.checkbox(\\\\n                        \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                    )\\\\n```\\\", \\\"after_code_start_line_number\\\": 290, \\\"after_code_line_numbers\\\": [290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300]}, {\\\"hunk_idx\\\": \\\"7\\\", \\\"before_code\\\": \\\"```python\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            st.markdown(html_content, unsafe_allow_html=True)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data, expanded=False)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n                    target_keys_in_order = [\\\\n                        \\\\\\\"prompt\\\\\\\",\\\\n                        \\\\\\\"review_request\\\\\\\",\\\\n                        \\\\\\\"review_response\\\\\\\",\\\\n                    ]\\\\n\\\\n                    for key_to_expand in target_keys_in_order:\\\\n                        if key_to_expand in data_to_display:\\\\n                            value = data_to_display.pop(key_to_expand)\\\\n                            with st.expander(\\\\n                                f\\\\\\\"{key_to_expand} 내용 보기\\\\\\\", expanded=False\\\\n                            ):\\\\n                                if key_to_expand == \\\\\\\"prompt\\\\\\\":\\\\n                                    parsed_prompt_content = []\\\\n                                    if isinstance(value, list):\\\\n                                        for item_prompt in value:\\\\n                                            item_c = copy.deepcopy(item_prompt)\\\\n                                            if (\\\\n                                                isinstance(item_c, dict)\\\\n                                                and \\\\\\\"content\\\\\\\" in item_c\\\\n                                                and isinstance(item_c[\\\\\\\"content\\\\\\\"], str)\\\\n                                            ):\\\\n                                                try:\\\\n                                                    item_c[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                        item_c[\\\\\\\"content\\\\\\\"]\\\\n                                                    )\\\\n                                                except json.JSONDecodeError:\\\\n                                                    pass\\\\n                                            parsed_prompt_content.append(item_c)\\\\n                                        st.json(parsed_prompt_content, expanded=True)\\\\n                                    else:\\\\n                                        st.json(value, expanded=True)  # Fallback\\\\n                                elif key_to_expand == \\\\\\\"review_response\\\\\\\":\\\\n                                    if value:\\\\n                                        try:\\\\n                                            review_response_obj = (\\\\n                                                ReviewResponse.model_validate(value)\\\\n                                            )\\\\n                                            formatter = ReviewFormatter()\\\\n                                            html_content = formatter.to_html(\\\\n                                                review_response_obj\\\\n                                            )\\\\n                                            st.markdown(\\\\n                                                html_content, unsafe_allow_html=True\\\\n                                            )\\\\n                                            with st.expander(\\\\n                                                f\\\\\\\"{key_to_expand} 원본 JSON 보기\\\\\\\",\\\\n                                                expanded=False,\\\\n                                            ):\\\\n                                                st.json(value, expanded=True)\\\\n                                        except Exception:\\\\n                                            st.json(\\\\n                                                value, expanded=True\\\\n                                            )  # Fallback to raw JSON\\\\n                                    else:\\\\n                                        st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n                                elif (\\\\n                                    value\\\\n                                ):  # For review_request and other potential future keys\\\\n                                    st.json(value, expanded=True)\\\\n                                else:\\\\n                                    st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n\\\\n                    if data_to_display:\\\\n                        st.markdown(\\\\\\\"---\\\\\\\")\\\\n                        st.markdown(\\\\\\\"### 기타 로그 정보\\\\\\\")\\\\n                        st.json(data_to_display, expanded=False)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                            review_response = ReviewResponse.model_validate(\\\\n                                json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                            )\\\\n                            formatter = ReviewFormatter()\\\\n                            html_content = formatter.to_html(review_response)\\\\n                            # st.markdown(html_content, unsafe_allow_html=True)\\\\n                            st.html(html_content)\\\\n                        else:\\\\n                            st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n```\\\", \\\"after_code_start_line_number\\\": 352, \\\"after_code_line_numbers\\\": [352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365]}, {\\\"hunk_idx\\\": \\\"8\\\", \\\"before_code\\\": \\\"```python\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 432, \\\"after_code_line_numbers\\\": [432, 433, 434, 435, 436, 437, 438, 439, 440, 441]}, {\\\"hunk_idx\\\": \\\"9\\\", \\\"before_code\\\": \\\"```python\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                                        pass\\\\n                    st.json(display_data, expanded=False)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 482, \\\"after_code_line_numbers\\\": [482, 483, 484, 485, 486, 487, 488, 489, 490, 491]}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"bug\", \"line_number\": 484, \"file\": \"reviewer/src/ui.py\", \"description\": \"파일 형식(format)이 'json'이 아닌 경우, JSON 파싱 오류 예외 처리 블록으로 넘어가 파일 내용이 항상 일반 텍스트(`st.text`)로 표시됩니다. 이로 인해 'html' 또는 'txt' 형식의 파일이 의도된 형식(예: HTML 렌더링, 마크다운)으로 표시되지 않고 단순히 텍스트로만 보입니다. `get_file_info` 함수는 다양한 형식을 식별하지만, `app` 함수에서는 'json'만 특별히 처리하고 있습니다.\", \"suggestion\": \"파일 형식에 따라 적절한 Streamlit 함수(`st.html`, `st.markdown`, `st.text`)를 사용하여 내용을 표시하도록 로직을 수정해야 합니다. `if format == \\\"json\\\":` 블록 이후에 `elif` 및 `else` 블록을 추가하여 다른 형식을 처리하세요.\", \"severity\": \"warning\", \"target_code\": \"            except json.JSONDecodeError:\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\n                st.text(content)\", \"suggested_code\": \"            except json.JSONDecodeError:\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\n                st.text(content)\\n        elif format == \\\"html\\\":\\n            # HTML은 st.html로 표시\\n            st.html(content)\\n        else:\\n            # 그 외 형식 (txt 등)은 st.markdown으로 표시\\n            st.markdown(content, unsafe_allow_html=True)\"}], \"summary\": \"사용되지 않는 파일 보기 옵션 및 관련 함수들을 제거하여 UI 코드를 간소화했습니다. 하지만 파일 내용 표시 로직에서 JSON 형식이 아닌 파일(HTML, TXT 등)에 대한 처리가 누락되어, 해당 파일들이 올바른 형식으로 표시되지 않고 일반 텍스트로만 보이는 버그가 발생했습니다.\", \"score\": 6.0, \"recommendations\": [\"파일 형식에 따른 내용 표시 로직을 복원하여 HTML, TXT 파일 등이 올바르게 렌더링되도록 수정해야 합니다.\", \"파일 읽기 및 JSON 파싱 중 발생하는 예외 처리를 좀 더 구체적으로 분리하여 오류 발생 시 사용자에게 더 명확한 정보를 제공할 수 있도록 개선할 수 있습니다.\", \"코드 전반에 걸쳐 변수명, 함수명 등의 네이밍 컨벤션을 일관되게 유지하는 것이 좋습니다. (예: `review_log` vs `review log`)\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요 규칙\\n  - 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n  - 이슈 설명(description) 및 제안(suggestion)의 명확성(Clarity): 독자가 쉽게 이해할 수 있도록 간결하고 명확한 언어를 사용하세요. \\n  - 코드 예시 제공: suggestion이 코드 변경을 포함한다면, issues 객체의 suggested_code 필드를 적극 활용하세요. 만약 issues가 없다면, recommendations 항목에서 전반적인 개선 방향과 함께 참고할 만한 코드 스타일 또는 간단한 개선 코드 예시를 제시하는 것이 좋습니다. (예: \\\"권장 사항: 전반적으로 변수명에 snake_case를 일관되게 사용하면 가독성이 향상됩니다. (예: existingVariable -> existing_variable)\\\")\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"after_code_start_line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록 (필요시 코드 예시 포함)\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분(target_code)을 언급하며 실질적인 개선 방안(suggested_code)을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7.  `issues[].line_number` 결정 방법:\\n    a.  `issues[].line_number`는 `target_code` (리뷰 대상 코드 스니펫)가 `file_content` 전체에서 시작하는 **절대적인 1-based 라인 번호**여야 합니다.\\n    b.  이 값을 결정하기 위해 `target_code`가 속한 `hunk`의 다음 정보들을 사용합니다:\\n        i.  `formatted_hunks[].after_code`: 수정 후 코드 블록 문자열입니다.\\n        ii. `formatted_hunks[].after_code_line_numbers`: `after_code`의 각 라인에 해당하는 `file_content` 기준 절대 1-based 라인 번호들이 순서대로 담긴 리스트입니다. 이 리스트의 길이는 `after_code`의 총 라인 수와 정확히 일치해야 합니다.\\n        iii. `target_code`: 리뷰 대상 코드 스니펫으로, `after_code`의 일부여야 합니다.\\n    c.  **계산 단계:**\\n        1.  **`target_code`의 상대 시작 위치 파악:** `target_code`의 첫 번째 라인이 `after_code` 내에서 몇 번째 라인(1-based)에서 시작하는지 정확히 파악합니다. 이를 \\\"상대 시작 라인 번호\\\"라고 합니다. (예: `target_code`의 첫 줄이 `after_code`의 3번째 줄과 내용이 같다면, \\\"상대 시작 라인 번호\\\"는 `3`입니다.)\\n        2.  **절대 라인 번호 조회:** 파악된 \\\"상대 시작 라인 번호\\\"를 사용하여 `after_code_line_numbers` 리스트에서 해당 위치의 값을 가져옵니다. 리스트는 0-based 인덱스를 사용하므로, `issues[].line_number = after_code_line_numbers[ (상대 시작 라인 번호) - 1 ]` 공식을 사용합니다.\\n    d.  **예시:**\\n        `after_code`가 3줄이고, `after_code_line_numbers`가 `[50, 51, 52]`라고 가정합니다.\\n        만약 `target_code`의 첫 번째 라인이 `after_code`의 `2`번째 라인 내용과 일치한다면, \\\"상대 시작 라인 번호\\\"는 `2`입니다.\\n        따라서, `issues[].line_number = after_code_line_numbers[2 - 1] = after_code_line_numbers[1]` 이므로, `issues[].line_number`는 `51`이 됩니다.\\n    e.  `target_code`가 여러 라인에 걸쳐 있는 경우, `target_code`의 **첫 번째 라인**을 기준으로 `issues[].line_number`를 결정합니다.\\n    f.  만약 `target_code`를 `after_code` 내에서 찾을 수 없거나, \\\"상대 시작 라인 번호\\\"를 정확히 특정할 수 없는 경우, `issues[].line_number`는 `null`로 설정하고, 필요한 경우 `description`에 해당 상황을 간략히 언급합니다.\\n    g.  (기존의 파일 전체에 대한 이슈 처리 시 `null` 사용 등 관련 규칙 유지)\\n8. 특정 코드 라인을 삭제하거나 파일을 삭제해야 하는 경우, suggested_code 최상단에 \\\"코드 라인 제거\\\" 또는 \\\"파일 제거\\\" 라는 문구를 명시하고, 그 아래에 제거 대상 코드를 주석 처리하여 제공하세요.\\n   예를 들어, Python 코드 삭제 시 # 코드 라인 제거\\\\n# print(\\\"삭제될 코드\\\") 와 같이 표현합니다. 만약 여러 라인이라면 각 라인을 주석 처리합니다.\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom enum import Enum\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_model_info, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_diff_only,\\\\n    get_default_model,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_diff_only,\\\\n    set_default_model,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils.file_utils import find_project_root\\\\nfrom reviewer.src.utils.git_utils import GitDiffUtility\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.models.review_prompt import ReviewPrompt\\\\nfrom reviewer.src.utils.prompts.models.review_prompt_with_file_content import (\\\\n    ReviewPromptWithFileContent,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest, ReviewResponse\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (사용되지 않음, 하위 호환성을 위해 유지됨)\\\\\\\",\\\\n        deprecated=True,\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    # 리뷰 대상 지정을 위한 상호 배타적 그룹\\\\n    review_target_group = review_parser.add_mutually_exclusive_group()\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--staged\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"Staged 변경사항만 리뷰\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-commit\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"특정 커밋부터 HEAD까지의 변경사항을 리뷰 (예: abc1234)\\\\\\\",\\\\n    )\\\\n    review_target_group.add_argument(\\\\n        \\\\\\\"--target-branch\\\\\\\",\\\\n        type=str,\\\\n        help=\\\\\\\"현재 브랜치와 지정된 브랜치 간의 변경사항을 리뷰 (예: main)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=\\\\\\\"사용할 AI 모델 (기본값: %(default)s)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        default=get_default_diff_only(),\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 설정에 따름)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 모델 설정\\\\n    model_parser = config_subparsers.add_parser(\\\\\\\"model\\\\\\\", help=\\\\\\\"모델 설정\\\\\\\")\\\\n    model_parser.add_argument(\\\\n        \\\\\\\"model_name\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=get_supported_models(),\\\\n        help=\\\\\\\"기본으로 사용할 AI 모델\\\\\\\",\\\\n    )\\\\n\\\\n    # diff-only 설정\\\\n    diff_only_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"diff-only\\\\\\\", help=\\\\\\\"diff-only 옵션 설정\\\\\\\"\\\\n    )\\\\n    diff_only_parser.add_argument(\\\\n        \\\\\\\"value\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        choices=[\\\\\\\"true\\\\\\\", \\\\\\\"false\\\\\\\"],\\\\n        help=\\\\\\\"기본 diff-only 값 (true/false)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        git_diff = GitDiffUtility.from_args(args)\\\\n        return git_diff.get_diff()\\\\n    except ValueError as e:\\\\n        logger.error(str(e))\\\\n        return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_model(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모델 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 새 모델 설정이 주어진 경우\\\\n    if hasattr(args, \\\\\\\"model_name\\\\\\\") and args.model_name:\\\\n        if set_default_model(args.model_name):\\\\n            logger.info(f\\\\\\\"기본 모델이 {args.model_name}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 모델 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 모델이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_model = get_default_model()\\\\n        logger.info(f\\\\\\\"현재 기본 모델: {current_model}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 모델을 설정하려면 'reviewer config model <model_name>' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_diff_only(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"diff-only 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if hasattr(args, \\\\\\\"value\\\\\\\") and args.value is not None:\\\\n        diff_only = args.value.lower() == \\\\\\\"true\\\\\\\"\\\\n        if set_default_diff_only(diff_only):\\\\n            logger.info(f\\\\\\\"기본 diff-only 값이 {diff_only}로 설정되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.error(\\\\\\\"기본 diff-only 값 설정에 실패했습니다.\\\\\\\")\\\\n    else:\\\\n        # 값이 지정되지 않은 경우 현재 설정을 표시\\\\n        current_value = get_default_diff_only()\\\\n        logger.info(f\\\\\\\"현재 기본 diff-only 값: {current_value}\\\\\\\")\\\\n        logger.info(\\\\n            \\\\\\\"새로운 값을 설정하려면 'reviewer config diff-only true' 또는 'reviewer config diff-only false' 명령어를 사용하세요.\\\\\\\"\\\\n        )\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n    # 기본 diff-only 설정\\\\n    logger.info(f\\\\\\\"기본 diff-only 값: {get_default_diff_only()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config diff-only [true|false]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"model\\\\\\\":\\\\n        config_model(args)\\\\n    elif args.config_command == \\\\\\\"diff-only\\\\\\\":\\\\n        config_diff_only(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\nclass ReviewStatus(Enum):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 상태를 나타내는 열거형 클래스.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    SUCCESS = \\\\\\\"SUCCESS\\\\\\\"\\\\n    FAILED = \\\\\\\"FAILED\\\\\\\"\\\\n\\\\n\\\\ndef save_review_log(\\\\n    prompt: ReviewPrompt | ReviewPromptWithFileContent | None,\\\\n    review_request: ReviewRequest,\\\\n    review_response: ReviewResponse | None,\\\\n    status: ReviewStatus,\\\\n    error: Exception | None = None,\\\\n) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    now = datetime.now()\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n        \\\\\\\"prompt\\\\\\\": prompt_data,\\\\n        \\\\\\\"review_request\\\\\\\": review_request.model_dump(mode=\\\\\\\"json\\\\\\\"),\\\\n        \\\\\\\"review_response\\\\\\\": response_data,\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    formatted = now.strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    file_name = f\\\\\\\"{formatted}_{model_name}_review_log\\\\\\\"\\\\n    file_path = log_dir / f\\\\\\\"{file_name}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n\\\\n    # repo_path 결정 - 사용자 입력 또는 프로젝트 루트\\\\n    repo_path = (\\\\n        str(Path(args.repo_path)) if args.repo_path != \\\\\\\".\\\\\\\" else str(find_project_root())\\\\n    )\\\\n    diff_result = parse_git_diff(diff_content, use_full_context, repo_path)\\\\n\\\\n    try:\\\\n        # 리뷰 요청 생성\\\\n        review_request = ReviewRequest(\\\\n            diff_content=diff_content,\\\\n            processed_diff=diff_result,\\\\n            file_paths=[file.filename for file in diff_result.files],\\\\n            use_full_context=use_full_context,\\\\n            model=args.model,\\\\n            repo_path=repo_path,\\\\n        )\\\\n\\\\n        # 리뷰 요청 저장\\\\n        save_review_request(review_request)\\\\n\\\\n        # LLM 게이트웨이 가져오기\\\\n        llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n        # 코드 리뷰 수행\\\\n        logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n        review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n        review_response = llm_gateway.review_code(review_prompt)\\\\n        save_review_log(\\\\n            review_prompt, review_request, review_response, ReviewStatus.SUCCESS\\\\n        )\\\\n\\\\n        logger.info(\\\\\\\"코드 리뷰가 완료되었습니다. 리뷰 로그가 저장되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"코드 리뷰 중 오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        save_review_log(\\\\n            review_prompt,\\\\n            review_request,\\\\n            None,\\\\n            ReviewStatus.FAILED,\\\\n            error=e,\\\\n        )\\\\n        return\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 현재 시간\\\\n    now = datetime.now()\\\\n\\\\n    # 로그 ID 생성\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그를 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    model_info = get_model_info(review_request.model)\\\\n    log_dir = get_default_review_log_dir()\\\\n    log_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 프롬프트 직렬화\\\\n    prompt_data = None\\\\n    if prompt:\\\\n        prompt_data = prompt.to_messages()\\\\n\\\\n    # 응답 직렬화\\\\n    response_data = None\\\\n    if review_response:\\\\n        response_data = review_response.model_dump(mode=\\\\\\\"json\\\\\\\")\\\\n\\\\n    now = datetime.now()\\\\n    provider = model_info.get(\\\\\\\"provider\\\\\\\", \\\\\\\"unknown\\\\\\\")\\\\n    model_name = model_info.get(\\\\\\\"full_name\\\\\\\", review_request.model)\\\\n    log_id = f\\\\\\\"{provider}-{model_name}-{int(now.timestamp())}\\\\\\\"\\\\n\\\\n    # JSON 로그 데이터 구성\\\\n    review_log = {\\\\n        \\\\\\\"id\\\\\\\": log_id,\\\\n        \\\\\\\"model\\\\\\\": {\\\\\\\"provider\\\\\\\": provider, \\\\\\\"name\\\\\\\": model_name},\\\\n        \\\\\\\"created_at\\\\\\\": now.isoformat(),\\\\n```\\\", \\\"after_code_start_line_number\\\": 512, \\\"after_code_line_numbers\\\": [512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536]}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    file_path = log_dir / f\\\\\\\"{log_id}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"status\\\\\\\": status.value,\\\\n        \\\\\\\"error\\\\\\\": str(error) if error else None,\\\\n    }\\\\n\\\\n    # 파일 저장\\\\n    formatted = now.strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    file_name = f\\\\\\\"{formatted}_{model_name}_review_log\\\\\\\"\\\\n    file_path = log_dir / f\\\\\\\"{file_name}.json\\\\\\\"\\\\n    with open(file_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(review_log, f, ensure_ascii=False, indent=2)\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 로그가 저장되었습니다: {file_path}\\\\\\\")\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 540, \\\"after_code_line_numbers\\\": [540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552]}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import (\\\\n    get_default_raw_log_dir,\\\\n    get_default_results_dir,\\\\n    get_default_review_log_dir,\\\\n    get_default_review_prompt_dir,\\\\n    get_default_review_request_dir,\\\\n)\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # ui.py 파일의 위치를 기준으로 프로젝트 루트를 찾고, 그 아래 data 폴더를 지정합니다.\\\\n    # reviewer/src/ui.py -> reviewer/ -> project_root\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_default_merged_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"기본 통합 데이터 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 사용자별 Application Support 디렉토리 아래에 reviewer/merged_data 경로를 사용합니다.\\\\n    # macOS 기준 경로입니다. 다른 OS에서는 적절히 수정해야 할 수 있습니다.\\\\n    if sys.platform == \\\\\\\"darwin\\\\\\\":  # macOS\\\\n        return (\\\\n            Path.home() / \\\\\\\"Library\\\\\\\" / \\\\\\\"Application Support\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n        )\\\\n    elif sys.platform == \\\\\\\"win32\\\\\\\":  # Windows\\\\n        return Path(os.getenv(\\\\\\\"APPDATA\\\\\\\", \\\\\\\"\\\\\\\")) / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n    else:  # Linux 등 기타\\\\n        return Path.home() / \\\\\\\".config\\\\\\\" / \\\\\\\"reviewer\\\\\\\" / \\\\\\\"merged_data\\\\\\\"\\\\n\\\\n\\\\ndef get_result_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 디렉토리에서 모든 결과 파일을 가져옵니다. (사용되지 않음)\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 이 함수는 더 이상 사용되지 않습니다. 대신 get_review_log_files()를 사용하세요.\\\\n    logger.warning(\\\\n        \\\\\\\"get_result_files()는 더 이상 사용되지 않습니다. get_review_log_files()를 사용하세요.\\\\\\\"\\\\n    )\\\\n    return []\\\\n\\\\n\\\\ndef get_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"로그 디렉토리에서 모든 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_raw_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_review_request_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청 디렉토리에서 모든 리뷰 요청 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    request_dir = get_default_review_request_dir()\\\\n    if not request_dir.exists():\\\\n        return []\\\\n\\\\n    request_files = list(request_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    request_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return request_files\\\\n\\\\n\\\\ndef get_review_prompt_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 프롬프트 디렉토리에서 모든 프롬프트 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    if not prompt_dir.exists():\\\\n        return []\\\\n\\\\n    prompt_files = list(prompt_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    prompt_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return prompt_files\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    # data 폴더 내 모든 파일을 대상으로 함 (확장자 무관)\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_merged_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"통합 데이터 디렉토리에서 모든 JSON 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    merged_data_dir = get_default_merged_data_dir()\\\\n    if not merged_data_dir.exists():\\\\n        return []\\\\n\\\\n    merged_files = list(merged_data_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    merged_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return merged_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    # 수정 시간 기준으로 정렬 (최신순)\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 파일명에서 모델 이름과 날짜 추출 시도\\\\n    model_name_candidate = \\\\\\\"\\\\\\\"\\\\n    date_candidate = mtime  # 기본값은 파일 수정 시간\\\\n\\\\n    try:\\\\n        parts = file.stem.split(\\\\\\\"_\\\\\\\")\\\\n        # 파일명 규칙: YYYYMMDD_HHMMSS_ModelName 또는 유사 형식\\\\n        # 또는 ModelName_YYYYMMDD_HHMMSS\\\\n        if len(parts) >= 3:\\\\n            # YYYYMMDD_HHMMSS_ModelName 형식 체크\\\\n            if (\\\\n                parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n            # ModelName_YYYYMMDD_HHMMSS 형식 체크 (마지막 두 파트가 날짜/시간)\\\\n            elif (\\\\n                parts[-2].isdigit()\\\\n                and len(parts[-2]) == 8\\\\n                and parts[-1].isdigit()\\\\n                and len(parts[-1]) == 6\\\\n            ):\\\\n                date_str = f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\"\\\\n                date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                model_name_candidate = \\\\\\\"_\\\\\\\".join(parts[:-2])\\\\n            # 기타: 마지막 파트를 모델명으로 가정하고, 날짜는 mtime 사용\\\\n            elif not parts[-1].isdigit():  # 마지막 파트가 숫자가 아니면 모델명으로 간주\\\\n                model_name_candidate = parts[-1]\\\\n                # 날짜/시간 부분 (YYYYMMDD_HHMMSS 형식) - 중간에 있을 경우\\\\n                if (\\\\n                    len(parts) >= 3\\\\n                    and parts[-2].isdigit()\\\\n                    and len(parts[-2]) == 6\\\\n                    and parts[-3].isdigit()\\\\n                    and len(parts[-3]) == 8\\\\n                ):\\\\n                    date_str = f\\\\\\\"{parts[-3]}_{parts[-2]}\\\\\\\"\\\\n                    try:\\\\n                        date_candidate = datetime.strptime(date_str, \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n                    except ValueError:\\\\n                        pass  # 날짜 형식 안맞으면 mtime 유지\\\\n        elif (\\\\n            len(parts) == 2 and not parts[0].isdigit() and not parts[1].isdigit()\\\\n        ):  # Model_Name 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = file.stem\\\\n        elif (\\\\n            len(parts) == 1 and not parts[0].isdigit()\\\\n        ):  # ModelName 형식이고 날짜 정보 없을 때\\\\n            model_name_candidate = parts[0]\\\\n\\\\n    except Exception:  # 날짜/모델명 파싱 중 예외 발생 시 기본값 사용\\\\n        pass  # model_name_candidate = \\\\\\\"\\\\\\\", date_candidate = mtime 유지\\\\n\\\\n    file_suffix = file.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    # 확장자가 없는 파일 처리 로직\\\\n    if not file_suffix:\\\\n        # 1. deepeval 결과 파일인지 확인 (llm_eval_dir 내부에 있는지)\\\\n        try:\\\\n            llm_eval_dir = get_default_llm_eval_data_dir()\\\\n\\\\n            # 경로 비교를 위해 절대 경로로 변환\\\\n            file_parent_resolved = file.parent.resolve()\\\\n            llm_eval_dir_resolved = llm_eval_dir.resolve()\\\\n\\\\n            # 파일이 llm_eval_dir의 하위 경로인지 확인\\\\n            file_parent_str = str(file_parent_resolved)\\\\n            llm_eval_dir_str = str(llm_eval_dir_resolved)\\\\n\\\\n            # llm_eval 디렉토리 내 파일은 모두 JSON으로 처리\\\\n            is_in_llm_eval_dir = file_parent_str.startswith(llm_eval_dir_str)\\\\n\\\\n            # 2. 날짜 형식의 파일명인지 확인\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            # deepeval 결과 파일(llm_eval 디렉토리)이거나 날짜 형식인 경우 JSON으로 처리\\\\n            if is_in_llm_eval_dir:\\\\n                # deepeval 파일은 무조건 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            elif has_date_format:\\\\n                # 날짜 형식은 JSON으로 처리\\\\n                file_format = \\\\\\\"json\\\\\\\"\\\\n            else:\\\\n                file_format = \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            # 예외 발생시 안전하게 txt로 처리\\\\n            file_format = \\\\\\\"txt\\\\\\\"\\\\n    elif file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"]:\\\\n        file_format = file_suffix\\\\n    else:  # 그 외 모르는 확장자는 'txt'로 간주\\\\n        file_format = \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 디렉토리 표시\\\\n    results_dir = get_default_results_dir()\\\\n    log_dir = get_default_raw_log_dir()\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    request_dir = get_default_review_request_dir()\\\\n    prompt_dir = get_default_review_prompt_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n        files = get_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 응답 로그가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n        files = get_review_request_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 요청이 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록을 정보와 함께 저장\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    selected_file_path = selected_file_info[\\\\\\\"path\\\\\\\"]\\\\n\\\\n    # 파일 내용 읽기\\\\n    try:\\\\n        with open(selected_file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        # 파일 정보 표시\\\\n        col1, col2, col3 = st.columns(3)\\\\n        with col1:\\\\n            st.markdown(f\\\\\\\"**파일명**: {selected_file_info['name']}\\\\\\\")\\\\n        with col2:\\\\n            st.markdown(\\\\n                f\\\\\\\"**날짜**: {selected_file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\"\\\\n            )\\\\n        with col3:\\\\n            st.markdown(f\\\\\\\"**크기**: {selected_file_info['size_str']}\\\\\\\")\\\\n\\\\n        # 파일 형식에 따라 다르게 표시\\\\n        format = selected_file_info[\\\\\\\"format\\\\\\\"]\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            try:\\\\n                # JSON 파싱\\\\n                json_data = json.loads(content)\\\\n\\\\n                if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                    # 리뷰 로그에서 review_response 데이터 가져오기\\\\n                    if \\\\\\\"review_response\\\\\\\" in json_data and json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n                        # 딕셔너리를 ReviewResponse 객체로 변환\\\\n                        review_response = ReviewResponse.model_validate(\\\\n                            json_data[\\\\\\\"review_response\\\\\\\"]\\\\n                        )\\\\n\\\\n                        # ReviewFormatter를 사용하여 HTML로 변환\\\\n                        formatter = ReviewFormatter()\\\\n                        html_content = formatter.to_html(review_response)\\\\n\\\\n                        # HTML 내용을 Streamlit에 표시\\\\n                        html_content_with_style = html_content\\\\n                        st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n                    else:\\\\n                        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n                        st.json(json_data)\\\\n                elif view_type == \\\\\\\"응답 로그\\\\\\\":\\\\n                    # 로그 데이터를 보기 좋게 표시\\\\n                    st.markdown(\\\\\\\"## 응답 로그 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"reviewRequest\\\\\\\":\\\\n                    # 리뷰 요청 데이터를 raw JSON으로 표시\\\\n                    st.markdown(\\\\\\\"## reviewRequest 내용\\\\\\\")\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n                    # 프롬프트 데이터 (최상위가 리스트인 경우) 처리\\\\n                    # 각 항목의 'content'가 문자열화된 JSON이면 파싱\\\\n                    st.markdown(\\\\\\\"## 프롬프트 내용\\\\\\\")\\\\n                    if isinstance(json_data, list):\\\\n                        for item in json_data:\\\\n                            if (\\\\n                                isinstance(item, dict)\\\\n                                and \\\\\\\"content\\\\\\\" in item\\\\n                                and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                            ):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n                    # 원본 데이터의 깊은 복사본을 만들어 필터링 및 표시에 사용\\\\n                    display_data = copy.deepcopy(json_data)\\\\n\\\\n                    num_total_cases = 0\\\\n                    if (\\\\n                        isinstance(json_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in json_data\\\\n                        and isinstance(json_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        num_total_cases = len(json_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n                    col_checkbox, col_count = st.columns(\\\\n                        [0.8, 0.2]\\\\n                    )  # 체크박스와 카운트 컬럼 비율 조정\\\\n\\\\n                    with col_checkbox:\\\\n                        filter_failed_tests = st.checkbox(\\\\n                            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n                            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n                        )\\\\n\\\\n                    surviving_test_cases = []\\\\n                    if filter_failed_tests:\\\\n                        if (\\\\n                            isinstance(display_data, dict)\\\\n                            and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                            and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                        ):\\\\n                            surviving_test_cases = []\\\\n                            for tc_original in display_data[\\\\n                                \\\\\\\"testCases\\\\\\\"\\\\n                            ]:  # 원본 리스트 순회\\\\n                                if (\\\\n                                    isinstance(tc_original, dict)\\\\n                                    and tc_original.get(\\\\\\\"success\\\\\\\") is False\\\\n                                ):\\\\n                                    # testCase.success가 false인 경우에만 tc_to_add 로직 수행\\\\n                                    tc_to_add = copy.deepcopy(\\\\n                                        tc_original\\\\n                                    )  # 복사본 사용\\\\n\\\\n                                    # metricsData 내부를 success가 false인 항목만 남도록 필터링\\\\n                                    if \\\\\\\"metricsData\\\\\\\" in tc_to_add and isinstance(\\\\n                                        tc_to_add[\\\\\\\"metricsData\\\\\\\"], list\\\\n                                    ):\\\\n                                        filtered_metrics = [\\\\n                                            m\\\\n                                            for m in tc_to_add[\\\\\\\"metricsData\\\\\\\"]\\\\n                                            if isinstance(m, dict)\\\\n                                            and m.get(\\\\\\\"success\\\\\\\") is False\\\\n                                        ]\\\\n                                        # metricsData가 비어있지 않거나, 원래 metricsData가 있었던 경우에만 할당\\\\n                                        # (항상 metricsData 키를 유지하고 싶다면 이 조건문 제거 가능)\\\\n                                        if (\\\\n                                            filtered_metrics\\\\n                                            or tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics\\\\n                                        elif (\\\\n                                            not filtered_metrics\\\\n                                            and tc_to_add.get(\\\\\\\"metricsData\\\\\\\") is not None\\\\n                                        ):\\\\n                                            # 모든 메트릭이 true여서 filtered_metrics가 비었지만, 원래 metricsData가 있었다면 빈 리스트로 설정\\\\n                                            tc_to_add[\\\\\\\"metricsData\\\\\\\"] = []\\\\n\\\\n                                    surviving_test_cases.append(tc_to_add)\\\\n\\\\n                            display_data[\\\\\\\"testCases\\\\\\\"] = surviving_test_cases\\\\n                            num_displayed_cases = len(\\\\n                                display_data[\\\\\\\"testCases\\\\\\\"]\\\\n                            )  # 필터링 후 개수 업데이트\\\\n                        count_caption_text = f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n                    else:\\\\n                        # 체크박스 해제 시에는 원본 metricsData를 보여주기 위해 display_data를 json_data의 복사본으로 다시 설정할 필요는 없음\\\\n                        # 어차피 매번 json_data의 deepcopy로 시작함.\\\\n                        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n                    with col_count:\\\\n                        st.caption(count_caption_text)\\\\n\\\\n                    # 필터링되었거나 전체 testCases에 대해 내부 필드 파싱 적용\\\\n                    if (\\\\n                        isinstance(display_data, dict)\\\\n                        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n                        and isinstance(display_data[\\\\\\\"testCases\\\\\\\"], list)\\\\n                    ):\\\\n                        for test_case in display_data[\\\\\\\"testCases\\\\\\\"]:\\\\n                            if isinstance(test_case, dict):\\\\n                                # input 필드 처리: 프롬프트와 유사한 구조로 파싱\\\\n                                if \\\\\\\"input\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"input\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                                        if isinstance(parsed_input, list):\\\\n                                            for item in parsed_input:\\\\n                                                if (\\\\n                                                    isinstance(item, dict)\\\\n                                                    and \\\\\\\"content\\\\\\\" in item\\\\n                                                    and isinstance(item[\\\\\\\"content\\\\\\\"], str)\\\\n                                                ):\\\\n                                                    try:\\\\n                                                        item[\\\\\\\"content\\\\\\\"] = json.loads(\\\\n                                                            item[\\\\\\\"content\\\\\\\"]\\\\n                                                        )\\\\n                                                    except json.JSONDecodeError:\\\\n                                                        pass\\\\n                                        test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n\\\\n                                # actualOutput 필드 처리\\\\n                                if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(\\\\n                                    test_case[\\\\\\\"actualOutput\\\\\\\"], str\\\\n                                ):\\\\n                                    try:\\\\n                                        test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(\\\\n                                            test_case[\\\\\\\"actualOutput\\\\\\\"]\\\\n                                        )\\\\n                                    except json.JSONDecodeError:\\\\n                                        pass\\\\n                    st.json(display_data)\\\\n            except json.JSONDecodeError:\\\\n                # JSON 파싱 실패 시 일반 텍스트로 표시\\\\n                st.text(content)\\\\n        elif format == \\\\\\\"html\\\\\\\":\\\\n            # HTML은 iframe으로 표시\\\\n            # st.html(content, height=600, scrolling=True) # 이전 코드\\\\n            # HTML 문자열에 직접 스타일을 적용하여 높이와 스크롤 제어\\\\n            html_content_with_style = f\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            <div style=\\\\\\\"height: 600px; overflow-y: scroll;\\\\\\\">\\\\n                {content}\\\\n            </div>\\\\n            \\\\\\\"\\\\\\\"\\\\\\\"\\\\n            # st.html(html_content_with_style, height=610) # 이전 코드\\\\n            st.markdown(html_content_with_style, unsafe_allow_html=True)\\\\n        else:\\\\n            # 마크다운 또는 다른 형식은 마크다운으로 표시\\\\n            st.markdown(content, unsafe_allow_html=True)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    # 현재 파일의 경로\\\\n    file_path = os.path.abspath(__file__)\\\\n\\\\n    # 포트 환경변수 가져오기\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    # Streamlit 실행\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**통합 JSON 저장 위치**: {get_default_merged_data_dir()}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    st.sidebar.markdown(f\\\\\\\"**결과 저장 위치**: {results_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**로그 저장 위치**: {log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**reviewRequest 요청 저장 위치**: {request_dir}\\\\\\\")\\\\n    st.sidebar.markdown(f\\\\\\\"**프롬프트 저장 위치**: {prompt_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과/로그/리뷰요청/프롬프트 선택\\\\n```\\\", \\\"after_code_start_line_number\\\": 276, \\\"after_code_line_numbers\\\": [276, 277, 278, 279, 280, 281, 282, 283, 284, 285]}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"통합 JSON\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"응답 로그\\\\\\\",\\\\n            \\\\\\\"reviewRequest\\\\\\\",\\\\n            \\\\\\\"프롬프트\\\\\\\",\\\\n            \\\\\\\"review log\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 288, \\\"after_code_line_numbers\\\": [288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298]}, {\\\"hunk_idx\\\": \\\"3\\\", \\\"before_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n        files = get_merged_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 통합 JSON 데이터가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    elif view_type == \\\\\\\"프롬프트\\\\\\\":\\\\n        files = get_review_prompt_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 프롬프트가 없습니다.\\\\\\\")\\\\n            return\\\\n    elif view_type == \\\\\\\"review log\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 review log가 없습니다.\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n```\\\", \\\"after_code_start_line_number\\\": 325, \\\"after_code_line_numbers\\\": [325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338]}, {\\\"hunk_idx\\\": \\\"4\\\", \\\"before_code\\\": \\\"```python\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"mtime\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n        \\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\", \\\\\\\"파일명\\\\\\\", \\\\\\\"모델명\\\\\\\"], index=0\\\\n    )\\\\n\\\\n    # 정렬 적용\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"파일명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"name\\\\\\\"])\\\\n    elif sort_option == \\\\\\\"모델명\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"model\\\\\\\"])\\\\n\\\\n```\\\", \\\"after_code_start_line_number\\\": 349, \\\"after_code_line_numbers\\\": [349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361]}, {\\\"hunk_idx\\\": \\\"5\\\", \\\"before_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"통합 JSON\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## 통합 JSON 내용\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n                                except json.JSONDecodeError:\\\\n                                    pass  # 파싱 실패 시 원본 문자열 유지\\\\n                    st.json(json_data)\\\\n                elif view_type == \\\\\\\"review log\\\\\\\":\\\\n                    st.markdown(\\\\\\\"## review log\\\\\\\")\\\\n                    if \\\\\\\"prompt\\\\\\\" in json_data and isinstance(json_data[\\\\\\\"prompt\\\\\\\"], list):\\\\n                        for i, item in enumerate(json_data[\\\\\\\"prompt\\\\\\\"]):\\\\n                            if \\\\\\\"content\\\\\\\" in item and isinstance(item[\\\\\\\"content\\\\\\\"], str):\\\\n                                try:\\\\n                                    item[\\\\\\\"content\\\\\\\"] = json.loads(item[\\\\\\\"content\\\\\\\"])\\\\n```\\\", \\\"after_code_start_line_number\\\": 438, \\\"after_code_line_numbers\\\": [438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449]}]}\"}]",
    "actual_output": "{\"issues\": [], \"summary\": \"리뷰 로그 파일명 형식이 개선되었고, UI에서 '통합 JSON' 보기 유형이 'review log'로 변경되었습니다. UI의 파일 정렬 기준도 파일 수정 시간에서 파일명에 포함된 날짜 정보로 변경되었습니다.\", \"score\": 9.0, \"recommendations\": [\"reviewer/src/ui.py 파일의 `get_file_info` 함수에서 파일명으로부터 날짜와 모델명을 파싱하는 로직이 다소 복잡하고 다양한 형식에 대응하려 시도하고 있습니다. 예상되는 파일명 형식에 대한 명확한 문서화 또는 주석을 추가하여 코드 이해도를 높이는 것이 좋습니다. 또한, 다양한 파일명 형식에 대한 테스트 케이스를 작성하여 파싱 로직의 견고성을 확보하는 것을 고려해볼 수 있습니다.\"]}"
  }
]