[
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"파일 형식 결정 중 오류 발생: {e}\\\\\\\")\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        file_format = determine_file_format(file_path)\\\\n\\\\n        if file_format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"line_number\\\": 506}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"Design\", \"line_number\": 18, \"file\": \"reviewer/src/ui.py\", \"description\": \"`sys.path`를 직접 수정하는 것은 모듈 임포트 경로를 예측하기 어렵게 만들고, 패키지 관리 시스템(pip 등)과의 충돌을 유발할 수 있습니다. 이 변경은 `sys.path` 수정을 제거하여 더 표준적인 Python 모듈 임포트 방식을 따르게 합니다.\", \"suggestion\": \"이 변경은 좋은 방향입니다. 프로젝트가 패키지로 올바르게 설정되어 있다면, `sys.path` 수정 없이도 내부 모듈 임포트가 잘 작동할 것입니다.\", \"severity\": \"info\", \"original_code\": \"sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\"..\\\")))\", \"improved_code\": \"\"}, {\"type\": \"Style\", \"line_number\": 509, \"file\": \"reviewer/src/ui.py\", \"description\": \"`run_app` 함수 내에서 `os`와 `sys` 모듈을 다시 임포트하고 있습니다. 이 모듈들은 파일 상단에서 이미 임포트되었으므로 함수 내에서의 임포트는 불필요합니다.\", \"suggestion\": \"함수 내 불필요한 중복 임포트를 제거하여 코드를 더 깔끔하게 유지합니다. (이 변경에서 이미 제거됨)\", \"severity\": \"info\", \"original_code\": \"    import os\\n    import subprocess\\n    import sys\", \"improved_code\": \"    import subprocess\"}], \"summary\": \"이 변경사항은 `sys.path` 직접 수정을 제거하고 함수 내 불필요한 중복 임포트를 제거하여 코드의 구조와 스타일을 개선합니다. 이는 더 표준적이고 유지보수하기 쉬운 코드를 만듭니다.\", \"score\": 9.0, \"recommendations\": [\"표준적인 Python 패키징 및 임포트 방식을 계속 따르세요.\", \"불필요하거나 중복되는 코드를 정기적으로 검토하고 제거하세요.\"]}"
  }
]