[
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"파일 형식 결정 중 오류 발생: {e}\\\\\\\")\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        file_format = determine_file_format(file_path)\\\\n\\\\n        if file_format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n```\\\", \\\"line_number\\\": 13}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"original_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import subprocess\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n```\\\", \\\"line_number\\\": 506}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"Design\", \"line_number\": 18, \"file\": \"reviewer/src/ui.py\", \"description\": \"`sys.path`를 직접 수정하는 것은 모듈 임포트 경로를 예측하기 어렵게 만들고, 패키지 관리 시스템(pip 등)과의 충돌을 유발할 수 있습니다. 이 변경은 `sys.path` 수정을 제거하여 더 표준적인 Python 모듈 임포트 방식을 따르게 합니다.\", \"suggestion\": \"이 변경은 좋은 방향입니다. 프로젝트가 패키지로 올바르게 설정되어 있다면, `sys.path` 수정 없이도 내부 모듈 임포트가 잘 작동할 것입니다.\", \"severity\": \"info\", \"original_code\": \"sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\"..\\\")))\", \"improved_code\": \"\"}, {\"type\": \"Style\", \"line_number\": 509, \"file\": \"reviewer/src/ui.py\", \"description\": \"`run_app` 함수 내에서 `os`와 `sys` 모듈을 다시 임포트하고 있습니다. 이 모듈들은 파일 상단에서 이미 임포트되었으므로 함수 내에서의 임포트는 불필요합니다.\", \"suggestion\": \"함수 내 불필요한 중복 임포트를 제거하여 코드를 더 깔끔하게 유지합니다. (이 변경에서 이미 제거됨)\", \"severity\": \"info\", \"original_code\": \"    import os\\n    import subprocess\\n    import sys\", \"improved_code\": \"    import subprocess\"}], \"summary\": \"이 변경사항은 `sys.path` 직접 수정을 제거하고 함수 내 불필요한 중복 임포트를 제거하여 코드의 구조와 스타일을 개선합니다. 이는 더 표준적이고 유지보수하기 쉬운 코드를 만듭니다.\", \"score\": 9.0, \"recommendations\": [\"표준적인 Python 패키징 및 임포트 방식을 계속 따르세요.\", \"불필요하거나 중복되는 코드를 정기적으로 검토하고 제거하세요.\"]}"
  },
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 git diff를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (버그, 보안, 성능, 스타일, 설계 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호 (반드시 정확한 숫자로 지정, 알 수 없는 경우에만 null 사용)\\n- file: 문제가 있는 파일 이름 (반드시 정확한 파일 경로와 이름 사용, '파일-1'과 같은 임의의 이름 사용 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n각 이슈에 대해 다음 형식으로 리뷰 대상 코드와 개선된 코드 예시를 제공하세요:\\n\\n리뷰 대상 코드:\\n```\\n[문제가 있는 원본 코드 스니펫]\\n```\\n\\n개선된 코드:\\n```\\n[개선 제안이 반영된 코드 스니펫]\\n```\\n\\n이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n\\nissues의 파일명과 line_number는 반드시 정확하게 지정해야 합니다. 파일명은 실제 파일 경로와 이름을 사용하고, line_number는 프롬프트에 명시되어 있는 line_number를 그대로 표기해주면됩니다.\\n파일명이나 라인 번호는 '파일-1', '파일-2'와 같은 임의의 이름으로 대체하지 마세요.\\n\\n최종적으로 응답은 반드시 다음 JSON 형식으로 제공해야 합니다:\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"이슈 유형\\\",\\n      \\\"line_number\\\": 라인 번호\\n      \\\"file\\\": \\\"파일명\\\",\\n      \\\"description\\\": \\\"이슈 설명\\\",\\n      \\\"suggestion\\\": \\\"개선 제안\\\",\\n      \\\"severity\\\": \\\"심각도\\\",\\n      \\\"original_code\\\": \\\"원본 코드\\\",\\n      \\\"improved_code\\\": \\\"개선된 코드\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"전체 요약\\\",\\n  \\\"score\\\": 점수,\\n  \\\"recommendations\\\": [\\\"권장사항1\\\", \\\"권장사항2\\\"]\\n}\\n```\\n이슈가 없는 경우에도 빈 배열 \\\"issues\\\": []로 표시하고, 다른 모든 필드를 포함해야 합니다.\\n위 JSON 형식만 응답해야 합니다. 다른 텍스트나 설명은 포함하지 마세요. \"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/ui.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n리뷰 결과를 보여주는 Streamlit 웹 인터페이스 모듈\\\\n\\\\n이 모듈은 저장된 리뷰 결과를 Streamlit을 사용하여 웹 브라우저에 표시합니다.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport copy\\\\nimport json\\\\nimport logging\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime\\\\nfrom pathlib import Path\\\\nfrom typing import Any, Optional\\\\n\\\\nimport streamlit as st\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n# 로거 설정\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n# 상대 경로 임포트를 위한 경로 설정\\\\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \\\\\\\"..\\\\\\\")))\\\\nfrom reviewer.src.config import get_default_review_log_dir\\\\nfrom reviewer.src.utils.review_formatter import ReviewFormatter\\\\n\\\\n\\\\ndef get_default_llm_eval_data_dir() -> Path:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터가 저장된 data 디렉토리 경로를 반환합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    project_root = Path(__file__).resolve().parent.parent.parent\\\\n    return project_root / \\\\\\\"llm_eval\\\\\\\" / \\\\\\\"results\\\\\\\"\\\\n\\\\n\\\\ndef get_llm_eval_data_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 데이터 디렉토리에서 모든 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    llm_eval_data_dir = get_default_llm_eval_data_dir()\\\\n    if not llm_eval_data_dir.exists():\\\\n        return []\\\\n\\\\n    llm_eval_files = list(llm_eval_data_dir.glob(\\\\\\\"*\\\\\\\"))\\\\n    llm_eval_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return llm_eval_files\\\\n\\\\n\\\\ndef get_review_log_files() -> list[Path]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 로그 디렉토리에서 모든 리뷰 로그 파일을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    log_dir = get_default_review_log_dir()\\\\n    if not log_dir.exists():\\\\n        return []\\\\n\\\\n    log_files = list(log_dir.glob(\\\\\\\"*.json\\\\\\\"))\\\\n    log_files.sort(key=lambda f: f.stat().st_mtime, reverse=True)\\\\n    return log_files\\\\n\\\\n\\\\ndef parse_date_from_filename(filename: str) -> Optional[datetime]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 날짜 정보를 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    # YYYYMMDD_HHMMSS 형식 검색\\\\n    if len(parts) >= 2:\\\\n        # 접두사에 날짜가 있는 경우: YYYYMMDD_HHMMSS_...\\\\n        if (\\\\n            parts[0].isdigit()\\\\n            and len(parts[0]) == 8\\\\n            and parts[1].isdigit()\\\\n            and len(parts[1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[0]}_{parts[1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 접미사에 날짜가 있는 경우: ..._YYYYMMDD_HHMMSS\\\\n        if (\\\\n            parts[-2].isdigit()\\\\n            and len(parts[-2]) == 8\\\\n            and parts[-1].isdigit()\\\\n            and len(parts[-1]) == 6\\\\n        ):\\\\n            try:\\\\n                return datetime.strptime(f\\\\\\\"{parts[-2]}_{parts[-1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n            except ValueError:\\\\n                pass\\\\n\\\\n        # 중간에 날짜가 있는 경우\\\\n        for i in range(len(parts) - 1):\\\\n            if (\\\\n                parts[i].isdigit()\\\\n                and len(parts[i]) == 8\\\\n                and parts[i + 1].isdigit()\\\\n                and len(parts[i + 1]) == 6\\\\n            ):\\\\n                try:\\\\n                    return datetime.strptime(\\\\n                        f\\\\\\\"{parts[i]}_{parts[i + 1]}\\\\\\\", \\\\\\\"%Y%m%d_%H%M%S\\\\\\\"\\\\n                    )\\\\n                except ValueError:\\\\n                    pass\\\\n\\\\n    return None\\\\n\\\\n\\\\ndef extract_model_name_from_filename(filename: str, date_parts_count: int = 0) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일명에서 모델 이름을 추출합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parts = filename.split(\\\\\\\"_\\\\\\\")\\\\n\\\\n    if date_parts_count == 2 and len(parts) > 2:\\\\n        # 날짜 부분 제외한 나머지를 모델명으로 간주\\\\n        return \\\\\\\"_\\\\\\\".join(parts[2:])\\\\n    elif len(parts) > 0 and not parts[-1].isdigit():\\\\n        # 마지막 부분이 숫자가 아니면 모델명으로 간주\\\\n        return parts[-1]\\\\n\\\\n    return \\\\\\\"\\\\\\\"\\\\n\\\\n\\\\ndef determine_file_format(file_path: Path) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일의 형식을 결정합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    file_suffix = file_path.suffix.lstrip(\\\\\\\".\\\\\\\").lower()\\\\n\\\\n    if not file_suffix:\\\\n        # 확장자 없는 파일 처리\\\\n        try:\\\\n            # llm_eval 디렉토리 내 파일인지 확인\\\\n            llm_eval_dir = get_default_llm_eval_data_dir().resolve()\\\\n            file_parent = file_path.parent.resolve()\\\\n\\\\n            is_in_llm_eval_dir = str(file_parent).startswith(str(llm_eval_dir))\\\\n\\\\n            # 파일명에 날짜 형식이 있는지 확인\\\\n            parts = file_path.stem.split(\\\\\\\"_\\\\\\\")\\\\n            has_date_format = (\\\\n                len(parts) >= 2\\\\n                and parts[0].isdigit()\\\\n                and len(parts[0]) == 8\\\\n                and parts[1].isdigit()\\\\n                and len(parts[1]) == 6\\\\n            )\\\\n\\\\n            if is_in_llm_eval_dir or has_date_format:\\\\n                return \\\\\\\"json\\\\\\\"\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n        except Exception:\\\\n            return \\\\\\\"txt\\\\\\\"\\\\n\\\\n    return file_suffix if file_suffix in [\\\\\\\"json\\\\\\\", \\\\\\\"log\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"txt\\\\\\\"] else \\\\\\\"txt\\\\\\\"\\\\n\\\\n\\\\ndef get_file_info(file: Path) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    mtime = datetime.fromtimestamp(file.stat().st_mtime)\\\\n    size = file.stat().st_size\\\\n    size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n    # 날짜 추출\\\\n    date_candidate = parse_date_from_filename(file.stem)\\\\n    if date_candidate is None:\\\\n        date_candidate = mtime\\\\n        date_parts_count = 0\\\\n    else:\\\\n        date_parts_count = 2\\\\n\\\\n    # 모델명 추출\\\\n    model_name_candidate = extract_model_name_from_filename(file.stem, date_parts_count)\\\\n\\\\n    # 파일 형식 결정\\\\n    file_format = determine_file_format(file)\\\\n\\\\n    return {\\\\n        \\\\\\\"path\\\\\\\": file,\\\\n        \\\\\\\"name\\\\\\\": file.name,\\\\n        \\\\\\\"model\\\\\\\": model_name_candidate,\\\\n        \\\\\\\"date\\\\\\\": date_candidate,\\\\n        \\\\\\\"mtime\\\\\\\": mtime,\\\\n        \\\\\\\"size\\\\\\\": size,\\\\n        \\\\\\\"size_str\\\\\\\": size_str,\\\\n        \\\\\\\"format\\\\\\\": file_format,\\\\n    }\\\\n\\\\n\\\\ndef display_file_info(file_info: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보를 화면에 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    col1, col2, col3 = st.columns(3)\\\\n    with col1:\\\\n        st.markdown(f\\\\\\\"**파일명**: {file_info['name']}\\\\\\\")\\\\n    with col2:\\\\n        st.markdown(f\\\\\\\"**날짜**: {file_info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\")\\\\n    with col3:\\\\n        st.markdown(f\\\\\\\"**크기**: {file_info['size_str']}\\\\\\\")\\\\n\\\\n\\\\ndef parse_json_content(content: str) -> dict[str, Any]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 문자열을 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        return json.loads(content)\\\\n    except json.JSONDecodeError:\\\\n        return {}\\\\n\\\\n\\\\ndef parse_prompt_content(prompt_list: list) -> list:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"프롬프트 데이터의 content 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(prompt_list, list):\\\\n        return prompt_list\\\\n\\\\n    parsed_list = []\\\\n    for item in prompt_list:\\\\n        item_copy = copy.deepcopy(item)\\\\n        if (\\\\n            isinstance(item_copy, dict)\\\\n            and \\\\\\\"content\\\\\\\" in item_copy\\\\n            and isinstance(item_copy[\\\\\\\"content\\\\\\\"], str)\\\\n        ):\\\\n            try:\\\\n                item_copy[\\\\\\\"content\\\\\\\"] = json.loads(item_copy[\\\\\\\"content\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n        parsed_list.append(item_copy)\\\\n\\\\n    return parsed_list\\\\n\\\\n\\\\ndef display_json_field_in_expander(key: str, value: Any) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"JSON 필드를 접을 수 있는 expander로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not value:  # None이거나 빈 값\\\\n        with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n            st.write(\\\\\\\"내용 없음\\\\\\\")\\\\n        return\\\\n\\\\n    with st.expander(f\\\\\\\"{key} 내용 보기\\\\\\\", expanded=False):\\\\n        if key == \\\\\\\"prompt\\\\\\\" and isinstance(value, list):\\\\n            parsed_value = parse_prompt_content(value)\\\\n            st.json(parsed_value, expanded=True)\\\\n        else:\\\\n            st.json(value, expanded=True)\\\\n\\\\n\\\\ndef display_review_result_raw_json(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과의 원본 JSON을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## 원본 JSON 데이터\\\\\\\")\\\\n    data_to_display = copy.deepcopy(json_data)\\\\n\\\\n    # 주요 필드를 expander로 표시\\\\n    target_keys = [\\\\\\\"prompt\\\\\\\", \\\\\\\"review_request\\\\\\\", \\\\\\\"review_response\\\\\\\"]\\\\n    for key in target_keys:\\\\n        if key in data_to_display:\\\\n            display_json_field_in_expander(key, data_to_display.pop(key))\\\\n\\\\n    # 나머지 데이터 표시\\\\n    if data_to_display:\\\\n        st.markdown(\\\\\\\"---\\\\\\\")\\\\n        st.markdown(\\\\\\\"### 원본 데이터\\\\\\\")\\\\n        st.json(json_data, expanded=False)\\\\n\\\\n\\\\ndef filter_failed_test_cases(test_cases: list) -> tuple[list, int]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"실패한 테스트 케이스만 필터링합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return [], 0\\\\n\\\\n    filtered_cases = []\\\\n\\\\n    for tc in test_cases:\\\\n        if not isinstance(tc, dict) or tc.get(\\\\\\\"success\\\\\\\") is not False:\\\\n            continue\\\\n\\\\n        tc_copy = copy.deepcopy(tc)\\\\n\\\\n        # metricsData 내부에서 실패한 항목만 필터링\\\\n        if \\\\\\\"metricsData\\\\\\\" in tc_copy and isinstance(tc_copy[\\\\\\\"metricsData\\\\\\\"], list):\\\\n            filtered_metrics = [\\\\n                m\\\\n                for m in tc_copy[\\\\\\\"metricsData\\\\\\\"]\\\\n                if isinstance(m, dict) and m.get(\\\\\\\"success\\\\\\\") is False\\\\n            ]\\\\n            tc_copy[\\\\\\\"metricsData\\\\\\\"] = filtered_metrics or []\\\\n\\\\n        filtered_cases.append(tc_copy)\\\\n\\\\n    return filtered_cases, len(filtered_cases)\\\\n\\\\n\\\\ndef parse_test_case_inputs(test_cases: list) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"테스트 케이스의 입력 필드를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not isinstance(test_cases, list):\\\\n        return\\\\n\\\\n    for test_case in test_cases:\\\\n        if not isinstance(test_case, dict):\\\\n            continue\\\\n\\\\n        # input 필드 처리\\\\n        if \\\\\\\"input\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"input\\\\\\\"], str):\\\\n            try:\\\\n                parsed_input = json.loads(test_case[\\\\\\\"input\\\\\\\"])\\\\n                if isinstance(parsed_input, list):\\\\n                    parsed_input = parse_prompt_content(parsed_input)\\\\n                test_case[\\\\\\\"input\\\\\\\"] = parsed_input\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n        # actualOutput 필드 처리\\\\n        if \\\\\\\"actualOutput\\\\\\\" in test_case and isinstance(test_case[\\\\\\\"actualOutput\\\\\\\"], str):\\\\n            try:\\\\n                test_case[\\\\\\\"actualOutput\\\\\\\"] = json.loads(test_case[\\\\\\\"actualOutput\\\\\\\"])\\\\n            except json.JSONDecodeError:\\\\n                pass\\\\n\\\\n\\\\ndef display_llm_eval_results(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"llm_eval 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.markdown(\\\\\\\"## llm_eval 결과 내용\\\\\\\")\\\\n\\\\n    # 데이터 복사\\\\n    display_data = copy.deepcopy(json_data)\\\\n\\\\n    # 테스트 케이스 수 계산\\\\n    test_cases = (\\\\n        display_data.get(\\\\\\\"testCases\\\\\\\", []) if isinstance(display_data, dict) else []\\\\n    )\\\\n    num_total_cases = len(test_cases) if isinstance(test_cases, list) else 0\\\\n\\\\n    # 필터링 컨트롤\\\\n    col_checkbox, col_count = st.columns([0.8, 0.2])\\\\n    with col_checkbox:\\\\n        filter_failed_tests = st.checkbox(\\\\n            \\\\\\\"실패한 테스트 케이스만 보기 (success=false)\\\\\\\",\\\\n            key=\\\\\\\"llm_eval_filter_checkbox\\\\\\\",\\\\n        )\\\\n\\\\n    # 필터링 적용\\\\n    num_displayed_cases = num_total_cases\\\\n    if (\\\\n        filter_failed_tests\\\\n        and isinstance(display_data, dict)\\\\n        and \\\\\\\"testCases\\\\\\\" in display_data\\\\n    ):\\\\n        filtered_cases, num_displayed_cases = filter_failed_test_cases(\\\\n            display_data[\\\\\\\"testCases\\\\\\\"]\\\\n        )\\\\n        display_data[\\\\\\\"testCases\\\\\\\"] = filtered_cases\\\\n        count_caption_text = (\\\\n            f\\\\\\\"(표시: {num_displayed_cases} / 총: {num_total_cases}건, 실패만)\\\\\\\"\\\\n        )\\\\n    else:\\\\n        count_caption_text = f\\\\\\\"(총 {num_total_cases}건)\\\\\\\"\\\\n\\\\n    with col_count:\\\\n        st.caption(count_caption_text)\\\\n\\\\n    # 입력 필드 파싱\\\\n    if isinstance(display_data, dict) and \\\\\\\"testCases\\\\\\\" in display_data:\\\\n        parse_test_case_inputs(display_data[\\\\\\\"testCases\\\\\\\"])\\\\n\\\\n    # 결과 표시\\\\n    st.json(display_data, expanded=False)\\\\n\\\\n\\\\ndef display_review_result(json_data: dict[str, Any]) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML로 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if \\\\\\\"review_response\\\\\\\" not in json_data or not json_data[\\\\\\\"review_response\\\\\\\"]:\\\\n        st.warning(\\\\\\\"리뷰 응답 데이터가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\ndef load_and_display_file_content(file_path: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 내용을 로드하고 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            content = f.read()\\\\n\\\\n        format = determine_file_format(file_path)\\\\n\\\\n        if format == \\\\\\\"json\\\\\\\":\\\\n            json_data = parse_json_content(content)\\\\n            if not json_data:\\\\n                st.error(\\\\\\\"유효하지 않은 JSON 형식입니다.\\\\\\\")\\\\n                st.text(content)\\\\n                return\\\\n\\\\n            view_type = st.session_state.get(\\\\\\\"view_type\\\\\\\")\\\\n\\\\n            if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n                if \\\\\\\"show_raw_json\\\\\\\" not in st.session_state:\\\\n                    st.session_state.show_raw_json = False\\\\n\\\\n                show_raw_json = st.checkbox(\\\\n                    \\\\\\\"원본 JSON 데이터 보기\\\\\\\", key=\\\\\\\"show_raw_json\\\\\\\"\\\\n                )\\\\n\\\\n                if show_raw_json:\\\\n                    display_review_result_raw_json(json_data)\\\\n                else:\\\\n                    display_review_result(json_data)\\\\n\\\\n            elif view_type == \\\\\\\"llm_eval 결과\\\\\\\":\\\\n                display_llm_eval_results(json_data)\\\\n        else:\\\\n            # 텍스트 파일은 그대로 표시\\\\n            st.text(content)\\\\n\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"파일을 읽는 중 오류가 발생했습니다: {str(e)}\\\\\\\")\\\\n\\\\n\\\\ndef sort_file_infos(\\\\n    file_infos: list[dict[str, Any]], sort_option: str\\\\n) -> list[dict[str, Any]]:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"파일 정보 목록을 정렬합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if sort_option == \\\\\\\"최신순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"], reverse=True)\\\\n    elif sort_option == \\\\\\\"오래된순\\\\\\\":\\\\n        file_infos.sort(key=lambda x: x[\\\\\\\"date\\\\\\\"])\\\\n    return file_infos\\\\n\\\\n\\\\ndef app():\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱 메인 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    st.set_page_config(\\\\n        page_title=\\\\\\\"Reviewer - 코드 리뷰 결과\\\\\\\",\\\\n        page_icon=\\\\\\\"📝\\\\\\\",\\\\n        layout=\\\\\\\"wide\\\\\\\",\\\\n        initial_sidebar_state=\\\\\\\"expanded\\\\\\\",\\\\n    )\\\\n\\\\n    st.title(\\\\\\\"코드 리뷰 결과\\\\\\\")\\\\n\\\\n    # 결과 디렉토리 표시\\\\n    review_log_dir = get_default_review_log_dir()\\\\n    st.sidebar.markdown(f\\\\\\\"**리뷰 로그 저장 위치**: {review_log_dir}\\\\\\\")\\\\n    st.sidebar.markdown(\\\\n        f\\\\\\\"**llm_eval 결과 저장 위치**: {get_default_llm_eval_data_dir()}\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 선택\\\\n    view_type = st.sidebar.selectbox(\\\\n        \\\\\\\"보기 유형:\\\\\\\",\\\\n        [\\\\n            \\\\\\\"리뷰 결과\\\\\\\",\\\\n            \\\\\\\"llm_eval 결과\\\\\\\",\\\\n        ],\\\\n        index=0,\\\\n    )\\\\n\\\\n    # 뷰 타입 세션 저장\\\\n    st.session_state.view_type = view_type\\\\n\\\\n    # 파일 목록 가져오기\\\\n    if view_type == \\\\\\\"리뷰 결과\\\\\\\":\\\\n        files = get_review_log_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 리뷰 로그가 없습니다.\\\\\\\")\\\\n            st.markdown(\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            ### 리뷰 생성 방법\\\\n            \\\\n            터미널에서 다음 명령어를 실행하여 코드 리뷰를 생성하세요:\\\\n            ```bash\\\\n            reviewer review\\\\n            ```\\\\n            \\\\n            자세한 사용법은 README.md 파일을 참조하세요.\\\\n            \\\\\\\"\\\\\\\"\\\\\\\")\\\\n            return\\\\n    else:  # llm_eval 결과\\\\n        files = get_llm_eval_data_files()\\\\n        if not files:\\\\n            st.info(\\\\\\\"저장된 llm_eval 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # 파일 목록 정보 생성\\\\n    file_infos = [get_file_info(f) for f in files]\\\\n\\\\n    # 사이드바에 파일 목록 표시\\\\n    st.sidebar.markdown(f\\\\\\\"## {view_type} 목록\\\\\\\")\\\\n\\\\n    # 정렬 옵션\\\\n    sort_option = st.sidebar.selectbox(\\\\\\\"정렬 기준:\\\\\\\", [\\\\\\\"최신순\\\\\\\", \\\\\\\"오래된순\\\\\\\"], index=0)\\\\n\\\\n    # 정렬 적용\\\\n    file_infos = sort_file_infos(file_infos, sort_option)\\\\n\\\\n    # 선택 가능한 파일 옵션 생성\\\\n    file_options = {\\\\n        f\\\\\\\"{info['name']} ({info['date'].strftime('%Y-%m-%d %H:%M')}\\\\\\\": info\\\\n        for info in file_infos\\\\n    }\\\\n\\\\n    # 파일 선택 위젯\\\\n    selected_file_name = st.sidebar.selectbox(\\\\n        \\\\\\\"파일 선택:\\\\\\\", list(file_options.keys()), index=0\\\\n    )\\\\n\\\\n    # 선택된 파일 정보와 내용 표시\\\\n    selected_file_info = file_options[selected_file_name]\\\\n    display_file_info(selected_file_info)\\\\n    load_and_display_file_content(selected_file_info[\\\\\\\"path\\\\\\\"])\\\\n\\\\n\\\\ndef run_app() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Streamlit 앱을 실행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    import os\\\\n    import subprocess\\\\n    import sys\\\\n\\\\n    file_path = os.path.abspath(__file__)\\\\n    port = os.environ.get(\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\", \\\\\\\"8501\\\\\\\")\\\\n\\\\n    cmd = [\\\\n        sys.executable,\\\\n        \\\\\\\"-m\\\\\\\",\\\\n        \\\\\\\"streamlit\\\\\\\",\\\\n        \\\\\\\"run\\\\\\\",\\\\n        file_path,\\\\n        \\\\\\\"--server.headless\\\\\\\",\\\\n        \\\\\\\"true\\\\\\\",\\\\n        \\\\\\\"--browser.serverAddress\\\\\\\",\\\\n        \\\\\\\"localhost\\\\\\\",\\\\n        \\\\\\\"--server.port\\\\\\\",\\\\n        port,\\\\n    ]\\\\n\\\\n    subprocess.run(cmd)\\\\n\\\\n\\\\n# Streamlit 앱으로 직접 실행될 경우\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    app()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_html(review_response)\\\\n        st.html(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n        return\\\\n\\\\n    try:\\\\n        review_response = ReviewResponse.model_validate(json_data[\\\\\\\"review_response\\\\\\\"])\\\\n        formatter = ReviewFormatter()\\\\n        html_content = formatter.to_markdown(review_response)\\\\n        st.markdown(html_content)\\\\n    except Exception as e:\\\\n        st.error(f\\\\\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\\\\\")\\\\n        st.json(json_data[\\\\\\\"review_response\\\\\\\"], expanded=False)\\\\n\\\\n\\\\n```\\\", \\\"line_number\\\": 364}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/review_formatter.py\\\", \\\"file_content\\\": \\\"\\\\\\\"\\\\\\\"\\\\\\\"ReviewFormatter: 리뷰 결과를 다양한 형식으로 변환하는 로직을 포함한 모듈.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nimport html\\\\n\\\\nfrom reviewer.src.utils.token.models import ReviewResponse\\\\n\\\\n\\\\nclass ReviewFormatter:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 다양한 형식으로 변환하는 클래스\\\\\\\\n\\\\n    이 클래스는 리뷰 응답을 마크다운, HTML 등 다양한 출력 형식으로 변환하는 기능을 제공합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def format(self, review: ReviewResponse, output_format: str = \\\\\\\"markdown\\\\\\\") -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 지정된 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n            output_format: 출력 형식 (markdown, html)\\\\n\\\\n        Returns:\\\\n            str: 변환된 리뷰 결과\\\\n\\\\n        Raises:\\\\n            ValueError: 지원하지 않는 출력 형식인 경우\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if output_format == \\\\\\\"markdown\\\\\\\":\\\\n            return self.to_markdown(review)\\\\n        elif output_format == \\\\\\\"html\\\\\\\":\\\\n            return self.to_html(review)\\\\n        else:\\\\n            raise ValueError(f\\\\\\\"지원하지 않는 출력 형식: {output_format}\\\\\\\")\\\\n\\\\n    @staticmethod\\\\n    def to_markdown(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 마크다운 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: 마크다운 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        md_lines = [\\\\\\\"# 코드 리뷰 결과\\\\\\\\n\\\\\\\"]\\\\n\\\\n        # 요약 및 점수\\\\n        md_lines.append(\\\\\\\"## 요약\\\\\\\\n\\\\\\\")\\\\n        md_lines.append(f\\\\\\\"{review.summary}\\\\\\\\n\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            md_lines.append(f\\\\\\\"**점수**: {review.score}/10\\\\\\\\n\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            md_lines.append(\\\\\\\"## 발견된 이슈\\\\\\\\n\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                md_lines.append(f\\\\\\\"### {i}. {severity_emoji} {issue.type}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"**파일**: `{issue.file}`\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", **라인**: {issue.line_number}\\\\\\\"\\\\n                    md_lines.append(f\\\\\\\"{file_info}\\\\\\\\n\\\\\\\")\\\\n\\\\n                md_lines.append(f\\\\\\\"**설명**: {issue.description}\\\\\\\\n\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    md_lines.append(f\\\\\\\"**제안**: {issue.suggestion}\\\\\\\\n\\\\\\\")\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**리뷰 대상 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.original_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    md_lines.append(\\\\n                        \\\\\\\"**개선된 코드**:\\\\\\\\n```\\\\\\\\n\\\\\\\" + issue.improved_code + \\\\\\\"\\\\\\\\n```\\\\\\\\n\\\\\\\"\\\\n                    )\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            md_lines.append(\\\\\\\"## 권장사항\\\\\\\\n\\\\\\\")\\\\n            for i, rec in enumerate(review.recommendations, 1):\\\\n                md_lines.append(f\\\\\\\"{i}. {rec}\\\\\\\\n\\\\\\\")\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(md_lines)\\\\n\\\\n    @staticmethod\\\\n    def to_html(review: ReviewResponse) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 HTML 형식으로 변환합니다.\\\\n\\\\n        Args:\\\\n            review: 리뷰 응답 객체\\\\n\\\\n        Returns:\\\\n            str: HTML 형식의 리뷰 결과\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        html_lines = [\\\\n            \\\\\\\"<!DOCTYPE html>\\\\\\\",\\\\n            \\\\\\\"<html>\\\\\\\",\\\\n            \\\\\\\"<head>\\\\\\\",\\\\n            \\\\\\\"<meta charset='UTF-8'>\\\\\\\",\\\\n            \\\\\\\"<title>코드 리뷰 결과</title>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info {  }\\\\\\\",\\\\n            \\\\\\\".warning {  }\\\\\\\",\\\\n            \\\\\\\".error {  }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"</head>\\\\\\\",\\\\n            \\\\\\\"<body>\\\\\\\",\\\\n            \\\\\\\"<h1>코드 리뷰 결과</h1>\\\\\\\",\\\\n        ]\\\\n\\\\n        # 요약 및 점수\\\\n        html_lines.append(\\\\\\\"<h2>요약</h2>\\\\\\\")\\\\n        html_lines.append(f\\\\\\\"<p>{review.summary}</p>\\\\\\\")\\\\n\\\\n        if review.score is not None:\\\\n            html_lines.append(f\\\\\\\"<p><strong>점수</strong>: {review.score}/10</p>\\\\\\\")\\\\n\\\\n        # 이슈 목록\\\\n        if review.issues:\\\\n            html_lines.append(\\\\\\\"<h2>발견된 이슈</h2>\\\\\\\")\\\\n\\\\n            for i, issue in enumerate(review.issues, 1):\\\\n                severity_emoji = {\\\\\\\"info\\\\\\\": \\\\\\\"ℹ️\\\\\\\", \\\\\\\"warning\\\\\\\": \\\\\\\"⚠️\\\\\\\", \\\\\\\"error\\\\\\\": \\\\\\\"🛑\\\\\\\"}.get(\\\\n                    issue.severity, \\\\\\\"ℹ️\\\\\\\"\\\\n                )\\\\n\\\\n                html_lines.append(f\\\\\\\"<div class='issue {issue.severity}'>\\\\\\\")\\\\n                html_lines.append(f\\\\\\\"<h3>{i}. {severity_emoji} {issue.type}</h3>\\\\\\\")\\\\n\\\\n                if issue.file:\\\\n                    file_info = f\\\\\\\"<strong>파일</strong>: <span class='file-info'>{issue.file}</span>\\\\\\\"\\\\n                    if issue.line_number:\\\\n                        file_info += f\\\\\\\", <strong>라인</strong>: {issue.line_number}\\\\\\\"\\\\n                    html_lines.append(f\\\\\\\"<p>{file_info}</p>\\\\\\\")\\\\n\\\\n                html_lines.append(f\\\\\\\"<p><strong>설명</strong>: {issue.description}</p>\\\\\\\")\\\\n\\\\n                if issue.suggestion:\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<p><strong>제안</strong>: {issue.suggestion}</p>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 리뷰 대상 코드 추가\\\\n                if issue.original_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>리뷰 대상 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.original_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                # 개선된 코드 추가\\\\n                if issue.improved_code:\\\\n                    html_lines.append(\\\\\\\"<p><strong>개선된 코드</strong>:</p>\\\\\\\")\\\\n                    html_lines.append(\\\\n                        f\\\\\\\"<pre><code>{html.escape(issue.improved_code)}</code></pre>\\\\\\\"\\\\n                    )\\\\n\\\\n                html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        # 권장사항\\\\n        if review.recommendations:\\\\n            html_lines.append(\\\\\\\"<h2>권장사항</h2>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<div class='recommendations'>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"<ol>\\\\\\\")\\\\n            for rec in review.recommendations:\\\\n                html_lines.append(f\\\\\\\"<li>{rec}</li>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</ol>\\\\\\\")\\\\n            html_lines.append(\\\\\\\"</div>\\\\\\\")\\\\n\\\\n        html_lines.extend([\\\\\\\"</body>\\\\\\\", \\\\\\\"</html>\\\\\\\"])\\\\n\\\\n        return \\\\\\\"\\\\\\\\n\\\\\\\".join(html_lines)\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"original_code\\\": \\\"```python\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info { border-left-color: #2196F3; }\\\\\\\",\\\\n            \\\\\\\".warning { border-left-color: #FF9800; }\\\\\\\",\\\\n            \\\\\\\".error { border-left-color: #F44336; }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n```\\\", \\\"modified_code\\\": \\\"```python\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\\\\\",\\\\n            \\\\\\\"h1 { color: #333; }\\\\\\\",\\\\n            \\\\\\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\\\\\",\\\\n            \\\\\\\"h3 { color: #555; }\\\\\\\",\\\\n            \\\\\\\".issue { padding: 10px; margin-bottom: 15px; }\\\\\\\",\\\\n            \\\\\\\".info {  }\\\\\\\",\\\\n            \\\\\\\".warning {  }\\\\\\\",\\\\n            \\\\\\\".error {  }\\\\\\\",\\\\n            \\\\\\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\\\\\",\\\\n            \\\\\\\".recommendations { padding: 10px; border-radius: 5px; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n            \\\\\\\"<style>\\\\\\\",\\\\n            \\\\\\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\\\\\",\\\\n            \\\\\\\"code { font-family: 'Courier New', Courier, monospace; }\\\\\\\",\\\\n            \\\\\\\"</style>\\\\\\\",\\\\n```\\\", \\\"line_number\\\": 109}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"스타일\", \"line_number\": 109, \"file\": \"reviewer/src/utils/review_formatter.py\", \"description\": \"HTML 보고서에서 이슈 심각도(info, warning, error) 및 권장사항 섹션에 대한 주요 시각적 스타일(배경색, 테두리 색상)이 제거되었습니다. 이전에는 각 심각도에 따라 다른 색상의 왼쪽 테두리가 있었고, 이슈 및 권장사항 섹션에는 배경색이 적용되어 가독성을 높였습니다. 이러한 스타일 제거로 인해 사용자가 이슈의 중요도를 한눈에 파악하거나 특정 섹션을 구분하기 어려워졌습니다.\", \"suggestion\": \"HTML 보고서의 가독성 향상을 위해 제거된 스타일(`.issue`의 배경색 및 왼쪽 테두리, `.info`, `.warning`, `.error`의 `border-left-color`, `.recommendations`의 배경색)을 복원하는 것을 권장합니다. 이를 통해 사용자가 정보를 더 쉽게 식별하고 이해할 수 있습니다. 원래 스타일로 되돌리면 시각적 명확성이 향상됩니다.\", \"severity\": \"warning\", \"original_code\": \"```python\\n            \\\"<style>\\\",\\n            \\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\",\\n            \\\"h1 { color: #333; }\\\",\\n            \\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\",\\n            \\\"h3 { color: #555; }\\\",\\n            \\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\",\\n            \\\".info { border-left-color: #2196F3; }\\\",\\n            \\\".warning { border-left-color: #FF9800; }\\\",\\n            \\\".error { border-left-color: #F44336; }\\\",\\n            \\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\",\\n            \\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\",\\n            \\\"</style>\\\",\\n            \\\"<style>\\\",\\n            \\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\",\\n            \\\"code { font-family: 'Courier New', Courier, monospace; }\\\",\\n            \\\"</style>\\\",\\n```\", \"improved_code\": \"```python\\n            \\\"<style>\\\",\\n            \\\"body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\\",\\n            \\\"h1 { color: #333; }\\\",\\n            \\\"h2 { color: #444; border-bottom: 1px solid #eee; padding-bottom: 5px; }\\\",\\n            \\\"h3 { color: #555; }\\\",\\n            \\\".issue { background-color: #f9f9f9; border-left: 4px solid #ddd; padding: 10px; margin-bottom: 15px; }\\\", // 스타일 복원\\n            \\\".info { border-left-color: #2196F3; }\\\", // 스타일 복원\\n            \\\".warning { border-left-color: #FF9800; }\\\", // 스타일 복원\\n            \\\".error { border-left-color: #F44336; }\\\", // 스타일 복원\\n            \\\".file-info { font-family: monospace; background-color: #eee; padding: 3px 5px; border-radius: 3px; }\\\",\\n            \\\".recommendations { background-color: #e8f5e9; padding: 10px; border-radius: 5px; }\\\", // 스타일 복원\\n            \\\"</style>\\\",\\n            \\\"<style>\\\",\\n            \\\"pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }\\\",\\n            \\\"code { font-family: 'Courier New', Courier, monospace; }\\\",\\n            \\\"</style>\\\",\\n```\"}, {\"type\": \"설계\", \"line_number\": 364, \"file\": \"reviewer/src/ui.py\", \"description\": \"`display_review_result` 함수에서 리뷰 결과를 기존 HTML(`st.html`) 방식 대신 마크다운(`st.markdown`)으로 표시하도록 변경되었습니다. 이 변경은 `ReviewFormatter.to_markdown` 메서드를 사용하며, 결과적으로 UI에 표시되는 리뷰 내용의 형식이 변경됩니다.\", \"suggestion\": \"마크다운으로의 변경은 일반적으로 내용을 더 간결하게 표시할 수 있지만, HTML이 제공하던 세밀한 스타일링이나 복잡한 구조 표현에는 한계가 있을 수 있습니다. 이 변경이 의도된 기능 개선의 일부이고 마크다운으로 충분한 정보 전달 및 가독성이 확보된다면 문제가 없습니다. 다만, 이전에 HTML 렌더링을 통해 제공되던 특정 시각적 이점(예: `review_formatter.py`에서 변경된 스타일링과 연관된 부분)이 중요했다면, 해당 기능이 의도치 않게 손실될 수 있으므로 검토가 필요합니다. 변경의 영향 범위를 고려하고, 사용자 경험에 부정적인 영향이 없는지 확인하는 것이 좋습니다.\", \"severity\": \"info\", \"original_code\": \"```python\\n        return\\n\\n    try:\\n        review_response = ReviewResponse.model_validate(json_data[\\\"review_response\\\"])\\n        formatter = ReviewFormatter()\\n        html_content = formatter.to_html(review_response)\\n        st.html(html_content)\\n    except Exception as e:\\n        st.error(f\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\")\\n        st.json(json_data[\\\"review_response\\\"], expanded=False)\\n\\n\\n```\", \"improved_code\": \"```python\\n        return\\n\\n    try:\\n        review_response = ReviewResponse.model_validate(json_data[\\\"review_response\\\"])\\n        formatter = ReviewFormatter()\\n        html_content = formatter.to_markdown(review_response)\\n        st.markdown(html_content)\\n    except Exception as e:\\n        st.error(f\\\"리뷰 응답 데이터 처리 중 오류 발생: {e}\\\")\\n        st.json(json_data[\\\"review_response\\\"], expanded=False)\\n\\n\\n```\"}], \"summary\": \"코드 변경 사항은 주로 두 가지입니다: 1) `reviewer/src/ui.py`에서 리뷰 결과를 표시하는 방식이 HTML에서 마크다운으로 변경되었습니다. 2) `reviewer/src/utils/review_formatter.py`에서 HTML 형식으로 변환 시 적용되던 일부 CSS 스타일(이슈 심각도별 색상 구분, 섹션 배경색 등)이 제거되어 HTML 출력물의 시각적 표현이 단순화되었습니다. 전반적으로 UI 표시 방식 변경과 그에 따른 포맷터의 HTML 스타일 조정이 이루어졌습니다.\", \"score\": 7.0, \"recommendations\": [\"HTML 보고서 스타일 복원 또는 개선: `review_formatter.py`에서 제거된 HTML 스타일(특히 이슈 심각도별 시각적 구분 및 섹션 배경색)을 복원하거나, 마크다운 출력에서도 유사한 시각적 단서를 제공할 방법을 고려하여 사용자 가독성을 높이는 것이 좋습니다.\", \"UI 변경 영향 검토: `ui.py`에서 리뷰 결과 표시 방식을 HTML에서 마크다운으로 변경한 것의 영향을 종합적으로 검토하세요. 마크다운이 모든 경우에 충분한 표현력을 제공하는지, 기존 HTML 방식이 제공하던 장점 중 유지할 필요가 있는 것은 없는지 확인이 필요합니다.\", \"일관성 있는 사용자 경험 제공: 만약 HTML 출력이 여전히 지원되는 기능이라면, 스타일 단순화로 인해 정보 전달력이 저하되지 않도록 주의해야 합니다. 마크다운과 HTML 출력 간의 사용자 경험 일관성도 고려할 필요가 있습니다.\"]}"
  }
]