[
  {
    "input": "[{\"role\": \"system\", \"content\": \"당신은 숙련된 코드 리뷰어입니다. 제공된 입력(JSON) 데이터를 분석하여 코드 품질, 버그, 보안 문제, 성능 이슈 등 주요 문제점을 종합적으로 평가하고, 개선 방향에 대해 자유롭게 의견을 제시하세요.\\n\\n중요: 모든 응답은 반드시 한국어로 작성해야 합니다. 영어나 다른 언어로 응답하지 마세요.\\n----------------------\\n### 입력(JSON) 구조\\n```json\\n{\\n  \\\"file_name\\\":   string,             // 변경이 발생한 파일 경로, 응답 JSON의 issues 객체 내 file 필드에 이 값을 사용해야 합니다.\\n  \\\"file_content\\\": string,            // 사용자가 **수정 후** 저장한 파일의 전체 내용, 변경된 코드 주변의 전체적인 맥락을 파악하는 데 참고용\\n  \\\"formatted_hunks\\\": [ // Git diff 정보를 구조화한 배열\\n    {\\n      \\\"hunk_idx\\\":     string,  // (무시 가능) 내부 식별자\\n      \\\"line_number\\\":  int,     // after_code가 file_content 내에서 시작하는 라인 번호\\n      \\\"before_code\\\":  string,  // **수정 전** 코드\\n      \\\"after_code\\\":   string   // **수정 후** 코드 — ⟵ 리뷰 대상\\n      // 그 밖의 필드는 있어도 무시해도 됩니다.\\n    },\\n    ...\\n  ]\\n}\\n```\\n\\n규칙 \\n- 반드시 **after_code 위주**로 분석‧리뷰하세요. before_code와 file_content는 참고 컨텍스트로만 활용합니다.\\n- 만약 before_code, file_content에 제안 사항이 있다면 recommendations에 명시해주세요.\\n----------------------\\n### 출력(JSON) 형식\\n각 이슈는 다음 정보를 포함해야 합니다:\\n- type: 이슈 유형 (반드시 bug, security, performance, style, design 중 하나)\\n- line_number: 문제가 있는 코드의 라인 번호, file_content 전체를 기준으로 하는 절대적인 라인 번호 (숫자, 알 수 없으면 null)\\n- file: 문제가 있는 파일 이름 (정확한 경로, 임의 이름 금지)\\n- description: 이슈에 대한 자세한 설명\\n- suggestion: 문제 해결을 위한 구체적인 제안\\n- severity: 이슈의 심각도 (info, warning, error 중 하나)\\n- target_code    : 리뷰 대상 코드 스니펫(after_code 중 문제 부분)\\n- suggested_code : 개선 제안이 반영된 코드 스니펫\\n\\n또한 다음 정보도 제공해야 합니다:\\n- summary: 전체 코드 변경에 대한 요약\\n- score: 코드 품질에 대한 0-10 사이의 점수\\n- recommendations: 전반적인 개선을 위한 권장사항 목록\\n\\n---------------------\\n### 출력(JSON) 예시\\n\\n```json\\n{\\n  \\\"issues\\\": [\\n    {\\n      \\\"type\\\": \\\"버그\\\",\\n      \\\"line_number\\\": 42,\\n      \\\"file\\\": \\\"src/app.py\\\",\\n      \\\"description\\\": \\\"NullPointerException 가능성이 있습니다.\\\",\\n      \\\"suggestion\\\": \\\"변수가 null인지 확인 후 사용하세요.\\\",\\n      \\\"severity\\\": \\\"error\\\",\\n      \\\"target_code\\\": \\\"if (user.isActive) { ... }\\\",\\n      \\\"suggested_code\\\": \\\"if (user != null && user.isActive) { ... }\\\"\\n    }\\n  ],\\n  \\\"summary\\\": \\\"로그인 로직 개선 및 예외 처리 강화 필요.\\\",\\n  \\\"score\\\": 7,\\n  \\\"recommendations\\\": [\\\"모든 입력값에 대한 null 체크 강화\\\", \\\"테스트 케이스 추가\\\"]\\n}\\n```\\n---------------------\\n## 규칙\\n1. 이슈 설명과 제안은 구체적이고 명확하게 작성하세요. 모호한 표현이나 일반적인 조언은 피하고, 코드의 특정 부분을 언급하며 실질적인 개선 방안을 제시하세요.\\n2. JSON 외 다른 형식의 출력(텍스트, 마크다운 등)을 절대 포함하지 마세요.\\n3. target_code와 suggested_code 값에는 순수한 코드 문자열만 포함합니다. 코드 스니펫 시작과 끝에 불필요한 빈 줄을 넣지 말고, 백틱(```)이나 기타 마크다운으로 감싸지 마세요.\\n4. 특별히 지적할 이슈가 없다면 \\\"issues\\\": [] 로 비워 두고, summary 에 “코드 변경 사항에서 특별한 이슈를 발견하지 못했습니다.”와 같이 명시하세요.\\n5. 리뷰 대상은 after_code 입니다. before_code와 file_content는 참고용입니다.\\n6. 파일명(file)은 주어진 값을 그대로 사용하세요.\\n7 line_number는 after_code 내 문제 발생 지점과 입력 formatted_hunks의 line_number를 조합하여 file_content 기준의 정확한 절대 라인 번호로 지정하세요\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/cli.py\\\", \\\"file_content\\\": \\\"import argparse\\\\nimport getpass\\\\nimport json\\\\nimport os\\\\nimport sys\\\\nfrom datetime import datetime, timedelta\\\\nfrom pathlib import Path\\\\n\\\\nfrom reviewer.src.available_models import get_default_model, get_supported_models\\\\nfrom reviewer.src.config import (\\\\n    get_api_key,\\\\n    get_default_results_dir,\\\\n    get_default_review_request_dir,\\\\n    set_api_key,\\\\n    set_default_results_dir,\\\\n)\\\\nfrom reviewer.src.diff_parser import parse_git_diff\\\\nfrom reviewer.src.llm_gateway.gateway_factory import GatewayFactory\\\\nfrom reviewer.src.review_processor import ReviewPostProcessor\\\\nfrom reviewer.src.ui import run_app\\\\nfrom reviewer.src.utils import run_git_diff\\\\nfrom reviewer.src.utils.logging import (\\\\n    DETAILED_LOG_FORMAT,\\\\n    LOG_LEVEL_INFO,\\\\n    get_logger,\\\\n    setup_logging,\\\\n)\\\\nfrom reviewer.src.utils.prompts.prompt_generator import PromptGenerator\\\\nfrom reviewer.src.utils.token.models import ReviewRequest\\\\n\\\\n# 로거 인스턴스 생성\\\\nlogger = get_logger(__name__)\\\\n\\\\n\\\\ndef parse_args() -> argparse.Namespace:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"명령줄 인수를 파싱합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"LLM 기반 코드 리뷰 도구\\\\\\\")\\\\n\\\\n    # 하위 명령어 파서 생성\\\\n    subparsers = parser.add_subparsers(dest=\\\\\\\"command\\\\\\\", help=\\\\\\\"명령어\\\\\\\")\\\\n\\\\n    # 리뷰 명령어 (기본 기능)\\\\n    review_parser = subparsers.add_parser(\\\\\\\"review\\\\\\\", help=\\\\\\\"코드 리뷰 수행\\\\\\\")\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--commit-range\\\\\\\", type=str, help=\\\\\\\"비교할 커밋 범위 (예: HEAD~1..HEAD)\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--output-format\\\\\\\",\\\\n        type=str,\\\\n        choices=[\\\\\\\"markdown\\\\\\\", \\\\\\\"html\\\\\\\", \\\\\\\"json\\\\\\\"],\\\\n        default=\\\\\\\"markdown\\\\\\\",\\\\n        help=\\\\\\\"출력 형식 (기본값: markdown)\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--review-focus\\\\\\\", type=str, help=\\\\\\\"리뷰 집중 영역 (예: '보안', '성능')\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--repo-path\\\\\\\",\\\\n        type=str,\\\\n        default=\\\\\\\".\\\\\\\",\\\\n        help=\\\\\\\"Git 저장소 경로 (기본값: 현재 디렉토리)\\\\\\\",\\\\n    )\\\\n\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--model\\\\\\\",\\\\n        type=str,\\\\n        choices=get_supported_models(),\\\\n        default=get_default_model(),\\\\n        help=f\\\\\\\"사용할 AI 모델 (기본값: {get_default_model()})\\\\\\\",\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--open-ui\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"리뷰 완료 후 UI로 결과 보기\\\\\\\"\\\\n    )\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-only\\\\\\\",\\\\n        action=\\\\\\\"store_true\\\\\\\",\\\\n        help=\\\\\\\"변경된 부분만 분석 (기본값: 파일 전체 컨텍스트 사용)\\\\\\\",\\\\n    )\\\\n\\\\n    # 설정 명령어\\\\n    config_parser = subparsers.add_parser(\\\\\\\"config\\\\\\\", help=\\\\\\\"설정 관리\\\\\\\")\\\\n    config_subparsers = config_parser.add_subparsers(\\\\n        dest=\\\\\\\"config_command\\\\\\\", help=\\\\\\\"설정 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # API 키 설정\\\\n    api_key_parser = config_subparsers.add_parser(\\\\\\\"api-key\\\\\\\", help=\\\\\\\"API 키 설정\\\\\\\")\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"provider\\\\\\\",\\\\n        choices=[\\\\\\\"openai\\\\\\\", \\\\\\\"claude\\\\\\\", \\\\\\\"google\\\\\\\"],\\\\n        default=\\\\\\\"openai\\\\\\\",\\\\n        nargs=\\\\\\\"?\\\\\\\",\\\\n        help=\\\\\\\"API 제공자 (기본값: openai)\\\\\\\",\\\\n    )\\\\n    api_key_parser.add_argument(\\\\n        \\\\\\\"key\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"API 키 (입력하지 않으면 대화형으로 요청)\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 디렉토리 설정\\\\n    results_dir_parser = config_subparsers.add_parser(\\\\n        \\\\\\\"results-dir\\\\\\\", help=\\\\\\\"결과 저장 디렉토리 설정\\\\\\\"\\\\n    )\\\\n    results_dir_parser.add_argument(\\\\n        \\\\\\\"path\\\\\\\", nargs=\\\\\\\"?\\\\\\\", help=\\\\\\\"저장 경로 (입력하지 않으면 현재 설정 표시)\\\\\\\"\\\\n    )\\\\n\\\\n    # 설정 목록 표시\\\\n    config_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"모든 설정 표시\\\\\\\")\\\\n\\\\n    # 결과 관리 명령어\\\\n    results_parser = subparsers.add_parser(\\\\\\\"results\\\\\\\", help=\\\\\\\"리뷰 결과 관리\\\\\\\")\\\\n    results_subparsers = results_parser.add_subparsers(\\\\n        dest=\\\\\\\"results_command\\\\\\\", help=\\\\\\\"결과 관리 명령어\\\\\\\"\\\\n    )\\\\n\\\\n    # 결과 목록 표시\\\\n    results_subparsers.add_parser(\\\\\\\"list\\\\\\\", help=\\\\\\\"최근 결과 목록 표시\\\\\\\")\\\\n\\\\n    # 특정 결과 표시\\\\n    show_parser = results_subparsers.add_parser(\\\\\\\"show\\\\\\\", help=\\\\\\\"특정 결과 표시\\\\\\\")\\\\n    show_parser.add_argument(\\\\\\\"result_id\\\\\\\", help=\\\\\\\"결과 파일명 또는 ID\\\\\\\")\\\\n\\\\n    # 오래된 결과 정리\\\\n    clean_parser = results_subparsers.add_parser(\\\\\\\"clean\\\\\\\", help=\\\\\\\"오래된 결과 정리\\\\\\\")\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--days\\\\\\\",\\\\n        type=int,\\\\n        default=30,\\\\n        help=\\\\\\\"이 기간(일)보다 오래된 결과를 삭제 (기본값: 30일)\\\\\\\",\\\\n    )\\\\n    clean_parser.add_argument(\\\\n        \\\\\\\"--dry-run\\\\\\\", action=\\\\\\\"store_true\\\\\\\", help=\\\\\\\"실제로 삭제하지 않고 삭제될 파일만 표시\\\\\\\"\\\\n    )\\\\n\\\\n    # UI 보기 명령어\\\\n    view_parser = subparsers.add_parser(\\\\\\\"view\\\\\\\", help=\\\\\\\"리뷰 결과를 UI로 보기\\\\\\\")\\\\n    view_parser.add_argument(\\\\n        \\\\\\\"--port\\\\\\\", type=int, default=8501, help=\\\\\\\"Streamlit 서버 포트 (기본값: 8501)\\\\\\\"\\\\n    )\\\\n\\\\n    args = parser.parse_args()\\\\n\\\\n    # 하위 명령어가 지정되지 않은 경우 기본으로 review 명령어 사용\\\\n    if not args.command:\\\\n        args.command = \\\\\\\"review\\\\\\\"\\\\n\\\\n    return args\\\\n\\\\n\\\\ndef get_diff_content(args: argparse.Namespace) -> str:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Git diff 내용을 가져옵니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n\\\\n\\\\ndef save_output(content: str, output_format: str, model: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과를 파일로 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 저장 디렉토리 설정\\\\n    results_dir = Path(get_default_results_dir())\\\\n\\\\n    # 테스트 환경에서는 현재 디렉토리의 review_results 폴더 사용\\\\n    if \\\\\\\"pytest\\\\\\\" in sys.modules:\\\\n        results_dir = Path.cwd() / \\\\\\\"review_results\\\\\\\"\\\\n\\\\n    # 디렉토리가 없으면 생성\\\\n    results_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 출력 파일명 생성\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    output_file = f\\\\\\\"review_{timestamp}_{model}\\\\\\\"\\\\n\\\\n    # 파일 확장자 추가\\\\n    output_path = results_dir / f\\\\\\\"{output_file}.{output_format}\\\\\\\"\\\\n\\\\n    # 결과 저장\\\\n    output_path.write_text(content, encoding=\\\\\\\"utf-8\\\\\\\")\\\\n    logger.info(f\\\\\\\"리뷰 결과가 {output_path}에 저장되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_api_key(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"API 키 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    provider = args.provider\\\\n\\\\n    # API 키가 명령줄에서 제공되지 않은 경우 대화형으로 요청\\\\n    if not hasattr(args, \\\\\\\"key\\\\\\\") or not args.key:\\\\n        # 현재 설정 표시\\\\n        try:\\\\n            current_key = get_api_key(provider)\\\\n            if current_key:\\\\n                masked_key = (\\\\n                    current_key[:4] + \\\\\\\"*\\\\\\\" * (len(current_key) - 8) + current_key[-4:]\\\\n                )\\\\n                logger.info(f\\\\\\\"현재 {provider.upper()} API 키: {masked_key}\\\\\\\")\\\\n        except ValueError:\\\\n            logger.info(f\\\\\\\"{provider.upper()} API 키가 설정되지 않았습니다.\\\\\\\")\\\\n\\\\n        # 새 키 입력 요청\\\\n        try:\\\\n            prompt_message = f\\\\\\\"{provider.upper()} API 키를 입력하세요 \\\\\\\"\\\\n            prompt_message += \\\\\\\"(입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n            api_key = getpass.getpass(prompt_message)\\\\n            if not api_key:\\\\n                logger.warning(\\\\\\\"API 키가 입력되지 않아 설정이 취소되었습니다.\\\\\\\")\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n    else:\\\\n        api_key = args.key\\\\n\\\\n    # API 키 저장\\\\n    if set_api_key(api_key, provider):\\\\n        logger.info(f\\\\\\\"{provider.upper()} API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(f\\\\\\\"{provider.upper()} API 키 저장에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_results_dir(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 저장 디렉토리 설정을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"path\\\\\\\") or not args.path:\\\\n        # 현재 설정 표시\\\\n        current_dir = get_default_results_dir()\\\\n        logger.info(f\\\\\\\"현재 결과 저장 디렉토리: {current_dir}\\\\\\\")\\\\n        return\\\\n\\\\n    # 새 경로 저장\\\\n    if set_default_results_dir(args.path):\\\\n        logger.info(f\\\\\\\"결과 저장 디렉토리가 {args.path}로 설정되었습니다.\\\\\\\")\\\\n    else:\\\\n        logger.error(\\\\\\\"결과 저장 디렉토리 설정에 실패했습니다.\\\\\\\")\\\\n\\\\n\\\\ndef config_list() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"모든 설정을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    logger.info(\\\\\\\"==== reviewer 설정 ====\\\\\\\")\\\\n\\\\n    # API 키\\\\n    openai_key = get_api_key(\\\\\\\"openai\\\\\\\")\\\\n    claude_key = get_api_key(\\\\\\\"claude\\\\\\\")\\\\n\\\\n    if openai_key:\\\\n        masked_key = openai_key[:4] + \\\\\\\"*\\\\\\\" * (len(openai_key) - 8) + openai_key[-4:]\\\\n        logger.info(f\\\\\\\"OpenAI API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"OpenAI API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    if claude_key:\\\\n        masked_key = claude_key[:4] + \\\\\\\"*\\\\\\\" * (len(claude_key) - 8) + claude_key[-4:]\\\\n        logger.info(f\\\\\\\"Claude API 키: {masked_key}\\\\\\\")\\\\n    else:\\\\n        logger.info(\\\\\\\"Claude API 키: 설정되지 않음\\\\\\\")\\\\n\\\\n    # 결과 저장 디렉토리\\\\n    logger.info(f\\\\\\\"결과 저장 디렉토리: {get_default_results_dir()}\\\\\\\")\\\\n\\\\n    # 기본 모델\\\\n    logger.info(f\\\\\\\"기본 모델: {get_default_model()}\\\\\\\")\\\\n\\\\n\\\\ndef handle_config_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"설정 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"config_command\\\\\\\") or not args.config_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 설정 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key [openai|claude|google] [KEY]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config results-dir [PATH]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config model [MODEL_NAME]\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config list\\\\\\\")\\\\n        return\\\\n\\\\n    if args.config_command == \\\\\\\"api-key\\\\\\\":\\\\n        config_api_key(args)\\\\n    elif args.config_command == \\\\\\\"results-dir\\\\\\\":\\\\n        config_results_dir(args)\\\\n    elif args.config_command == \\\\\\\"list\\\\\\\":\\\\n        config_list()\\\\n\\\\n\\\\ndef handle_results_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"결과 관리 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not hasattr(args, \\\\\\\"results_command\\\\\\\") or not args.results_command:\\\\n        # 명령어가 지정되지 않으면 도움말 표시\\\\n        logger.info(\\\\\\\"사용 가능한 결과 관리 명령어:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results list\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results show <result_id>\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer results clean [--days <days>] [--dry-run]\\\\\\\")\\\\n        return\\\\n\\\\n    # 결과 디렉토리 확인\\\\n    results_dir = get_default_results_dir()\\\\n    if not results_dir.exists():\\\\n        logger.warning(f\\\\\\\"결과 디렉토리({results_dir})가 존재하지 않습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    if args.results_command == \\\\\\\"list\\\\\\\":\\\\n        list_results(results_dir)\\\\n    elif args.results_command == \\\\\\\"show\\\\\\\":\\\\n        show_result(results_dir, args.result_id)\\\\n    elif args.results_command == \\\\\\\"clean\\\\\\\":\\\\n        clean_results(results_dir, args.days, args.dry_run)\\\\n\\\\n\\\\ndef list_results(results_dir: Path) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 결과 목록을 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    result_files = sorted(\\\\n        results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n    )\\\\n\\\\n    if not result_files:\\\\n        logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 결과 목록 (저장 위치: {results_dir}):\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n    logger.info(f\\\\\\\"{'ID':4} | {'날짜':16} | {'크기':8} | {'파일명'}\\\\\\\")\\\\n    logger.info(\\\\\\\"-\\\\\\\" * 80)\\\\n\\\\n    for i, file in enumerate(result_files, 1):\\\\n        # 파일 정보 가져오기\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        size = file.stat().st_size\\\\n        size_str = f\\\\\\\"{size / 1024:.1f}KB\\\\\\\" if size >= 1024 else f\\\\\\\"{size}B\\\\\\\"\\\\n\\\\n        logger.info(f\\\\\\\"{i:4} | {mtime:16} | {size_str:8} | {file.name}\\\\\\\")\\\\n\\\\n\\\\ndef show_result(results_dir: Path, result_id: str) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"특정 리뷰 결과를 표시합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 결과 ID가 숫자인 경우 (목록 인덱스)\\\\n    if result_id.isdigit():\\\\n        idx = int(result_id)\\\\n        result_files = sorted(\\\\n            results_dir.glob(\\\\\\\"*.*\\\\\\\"), key=lambda f: f.stat().st_mtime, reverse=True\\\\n        )\\\\n\\\\n        if not result_files:\\\\n            logger.info(\\\\\\\"저장된 리뷰 결과가 없습니다.\\\\\\\")\\\\n            return\\\\n\\\\n        if 1 <= idx <= len(result_files):\\\\n            file_path = result_files[idx - 1]\\\\n        else:\\\\n            logger.warning(\\\\n                f\\\\\\\"유효하지 않은 ID: {idx} (1-{len(result_files)} 사이 값을 입력하세요)\\\\\\\"\\\\n            )\\\\n            return\\\\n    else:\\\\n        # 파일명으로 직접 지정한 경우\\\\n        file_path = results_dir / result_id\\\\n        if not file_path.exists() and \\\\\\\".\\\\\\\" not in result_id:\\\\n            # 확장자가 없는 경우 추가로 확장자가 있는 파일 검색\\\\n            matching_files = sorted(results_dir.glob(f\\\\\\\"{result_id}.*\\\\\\\"))\\\\n            if matching_files:\\\\n                file_path = matching_files[0]\\\\n\\\\n    # 파일 존재 확인\\\\n    if not file_path.exists():\\\\n        logger.warning(f\\\\\\\"결과 파일을 찾을 수 없습니다: {result_id}\\\\\\\")\\\\n        return\\\\n\\\\n    # 파일 내용 표시\\\\n    logger.info(f\\\\\\\"=== {file_path.name} ===\\\\\\\")\\\\n    logger.info(\\\\\\\"\\\\\\\")\\\\n\\\\n    with open(file_path, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        content = f.read()\\\\n        # 여기서는 내용을 print로 유지 (콘솔 출력에 적합)\\\\n        print(content)\\\\n\\\\n\\\\ndef clean_results(results_dir: Path, days: int, dry_run: bool) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"오래된 리뷰 결과를 정리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if days <= 0:\\\\n        logger.warning(\\\\\\\"유효하지 않은 기간입니다. 1일 이상의 값을 지정하세요.\\\\\\\")\\\\n        return\\\\n\\\\n    # 현재 시간에서 지정된 일수를 뺀 타임스탬프 계산\\\\n    cutoff_time = datetime.now() - timedelta(days=days)\\\\n    cutoff_timestamp = cutoff_time.timestamp()\\\\n\\\\n    # 모든 결과 파일 가져오기\\\\n    result_files = sorted(results_dir.glob(\\\\\\\"*.*\\\\\\\"))\\\\n    old_files = [f for f in result_files if f.stat().st_mtime < cutoff_timestamp]\\\\n\\\\n    if not old_files:\\\\n        logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일이 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    logger.info(f\\\\\\\"{days}일보다 오래된 결과 파일 ({len(old_files)}개):\\\\\\\")\\\\n    for file in old_files:\\\\n        mtime = datetime.fromtimestamp(file.stat().st_mtime).strftime(\\\\\\\"%Y-%m-%d %H:%M\\\\\\\")\\\\n        logger.info(f\\\\\\\"  - {file.name} (수정일: {mtime})\\\\\\\")\\\\n\\\\n    if dry_run:\\\\n        logger.info(\\\\n            \\\\\\\"\\\\\\\\n이는 미리보기입니다. 실제로 삭제하려면 --dry-run 옵션을 제거하세요.\\\\\\\"\\\\n        )\\\\n        return\\\\n\\\\n    try:\\\\n        response = input(\\\\\\\"\\\\\\\\n위 파일들을 삭제하시겠습니까? (y/n): \\\\\\\")\\\\n        if response.lower() == \\\\\\\"y\\\\\\\":\\\\n            for file in old_files:\\\\n                file.unlink()\\\\n            logger.info(f\\\\\\\"{len(old_files)}개 파일이 삭제되었습니다.\\\\\\\")\\\\n        else:\\\\n            logger.info(\\\\\\\"작업이 취소되었습니다.\\\\\\\")\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n작업이 취소되었습니다.\\\\\\\")\\\\n\\\\n\\\\ndef save_review_request(review_request: ReviewRequest) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"리뷰 요청을 저장합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 저장 디렉토리 생성\\\\n    save_dir = get_default_review_request_dir()\\\\n    save_dir.mkdir(parents=True, exist_ok=True)\\\\n\\\\n    # 파일명 생성 (타임스탬프 포함)\\\\n    timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n    filename = f\\\\\\\"review_request_{timestamp}_{review_request.model}.json\\\\\\\"\\\\n    save_path = save_dir / filename\\\\n\\\\n    # JSON으로 저장\\\\n    with open(save_path, \\\\\\\"w\\\\\\\", encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n        json.dump(\\\\n            review_request.model_dump(mode=\\\\\\\"json\\\\\\\"), f, ensure_ascii=False, indent=2\\\\n        )\\\\n\\\\n    logger.info(f\\\\\\\"리뷰 요청이 저장되었습니다: {save_path}\\\\\\\")\\\\n\\\\n\\\\ndef review_code(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"코드 리뷰를 수행합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # API 키 확인\\\\n    api_key = get_api_key(\\\\\\\"openai\\\\\\\")  # 기본적으로 OpenAI 모델 사용\\\\n    if not api_key:\\\\n        logger.warning(\\\\\\\"API 키가 설정되지 않았습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 API 키를 설정하세요:\\\\\\\")\\\\n        logger.info(\\\\\\\"  reviewer config api-key openai\\\\\\\")\\\\n\\\\n        # 대화형으로 키 설정 제안\\\\n        try:\\\\n            response = input(\\\\\\\"지금 API 키를 설정하시겠습니까? (y/n): \\\\\\\")\\\\n            if response.lower() == \\\\\\\"y\\\\\\\":\\\\n                try:\\\\n                    new_api_key = getpass.getpass(\\\\n                        \\\\\\\"OpenAI API 키를 입력하세요 (입력이 화면에 표시되지 않습니다): \\\\\\\"\\\\n                    )\\\\n                    if new_api_key:\\\\n                        if set_api_key(new_api_key, \\\\\\\"openai\\\\\\\"):\\\\n                            logger.info(\\\\\\\"API 키가 성공적으로 저장되었습니다.\\\\\\\")\\\\n                            api_key = new_api_key\\\\n                        else:\\\\n                            logger.error(\\\\\\\"API 키 저장에 실패했습니다.\\\\\\\")\\\\n                            return\\\\n                    else:\\\\n                        logger.warning(\\\\\\\"API 키가 입력되지 않아 실행이 취소되었습니다.\\\\\\\")\\\\n                        return\\\\n                except KeyboardInterrupt:\\\\n                    logger.info(\\\\\\\"\\\\\\\\n설정이 취소되었습니다.\\\\\\\")\\\\n                    return\\\\n            else:\\\\n                return\\\\n        except KeyboardInterrupt:\\\\n            logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n            return\\\\n\\\\n    # Git diff 내용 가져오기\\\\n    diff_content = get_diff_content(args)\\\\n    if not diff_content:\\\\n        logger.warning(\\\\\\\"변경 사항이 없거나 diff를 가져올 수 없습니다.\\\\\\\")\\\\n        return\\\\n\\\\n    # diff 파싱 및 메타데이터 추가\\\\n    use_full_context = not args.diff_only\\\\n    diff_result = parse_git_diff(diff_content, use_full_context)\\\\n\\\\n    # 리뷰 요청 생성\\\\n    review_request = ReviewRequest(\\\\n        diff_content=diff_content,\\\\n        processed_diff=diff_result,\\\\n        file_paths=[file.filename for file in diff_result.files],\\\\n        review_focus=args.review_focus,\\\\n        use_full_context=use_full_context,\\\\n        model=args.model,\\\\n    )\\\\n\\\\n    # 리뷰 요청 저장\\\\n    save_review_request(review_request)\\\\n\\\\n    # LLM 게이트웨이 가져오기\\\\n    llm_gateway = GatewayFactory.create(model=review_request.model)\\\\n\\\\n    # 코드 리뷰 수행\\\\n    logger.info(f\\\\\\\"코드 리뷰 중... (모델: {review_request.model})\\\\\\\")\\\\n    review_prompt = PromptGenerator().create_code_review_prompt(review_request)\\\\n    review_response = llm_gateway.review_code(review_prompt)\\\\n\\\\n    # 리뷰 결과 처리\\\\n    processor = ReviewPostProcessor()\\\\n    output_content = processor.process_review(review_response, args.output_format)\\\\n\\\\n    # 결과 저장\\\\n    save_output(output_content, args.output_format, review_request.model)\\\\n\\\\n    # UI 자동 실행\\\\n    if args.open_ui:\\\\n        logger.info(\\\\\\\"리뷰 결과 UI를 시작합니다...\\\\\\\")\\\\n        handle_view_command(args)\\\\n\\\\n\\\\ndef handle_view_command(args: argparse.Namespace) -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"UI 보기 명령을 처리합니다.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        # port 속성이 없을 경우 기본값 8501 사용\\\\n        port = getattr(args, \\\\\\\"port\\\\\\\", 8501)\\\\n        logger.info(\\\\n            f\\\\\\\"Streamlit UI를 시작합니다. \\\\\\\"\\\\n            f\\\\\\\"브라우저에서 http://localhost:{port}으로 접속하세요...\\\\\\\"\\\\n        )\\\\n        # 포트 설정\\\\n        os.environ[\\\\\\\"STREAMLIT_SERVER_PORT\\\\\\\"] = str(port)\\\\n        # UI 실행\\\\n        run_app()\\\\n    except ImportError:\\\\n        logger.error(\\\\\\\"Streamlit 라이브러리가 설치되어 있지 않습니다.\\\\\\\")\\\\n        logger.info(\\\\\\\"다음 명령어로 설치하세요: pip install streamlit\\\\\\\")\\\\n        return\\\\n\\\\n\\\\ndef main() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"애플리케이션의 메인 진입점.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    # 로깅 설정 초기화\\\\n    setup_logging(level=LOG_LEVEL_INFO, log_format=DETAILED_LOG_FORMAT)\\\\n\\\\n    try:\\\\n        args = parse_args()\\\\n\\\\n        if args.command == \\\\\\\"review\\\\\\\":\\\\n            review_code(args)\\\\n        elif args.command == \\\\\\\"config\\\\\\\":\\\\n            handle_config_command(args)\\\\n        elif args.command == \\\\\\\"results\\\\\\\":\\\\n            handle_results_command(args)\\\\n        elif args.command == \\\\\\\"view\\\\\\\":\\\\n            handle_view_command(args)\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n프로그램이 사용자에 의해 중단되었습니다.\\\\\\\")\\\\n        sys.exit(1)\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\", exc_info=True)\\\\n        sys.exit(1)\\\\n\\\\n\\\\ndef main_cli() -> None:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"CLI 도구의 진입점 함수\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        main()\\\\n    except KeyboardInterrupt:\\\\n        logger.info(\\\\\\\"\\\\\\\\n실행이 취소되었습니다.\\\\\\\")\\\\n    except Exception as e:\\\\n        logger.error(f\\\\\\\"오류 발생: {str(e)}\\\\\\\")\\\\n        sys.exit(1)\\\\n\\\\n\\\\nif __name__ == \\\\\\\"__main__\\\\\\\":\\\\n    main_cli()\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n    review_parser.add_argument(\\\\n        \\\\\\\"--diff-file\\\\\\\", type=str, help=\\\\\\\"Git diff 파일 경로 (--commit-range 대신 사용)\\\\\\\"\\\\n    )\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n\\\\n```\\\", \\\"line_number\\\": 46}, {\\\"hunk_idx\\\": \\\"2\\\", \\\"before_code\\\": \\\"```python\\\\n    if args.diff_file:\\\\n        # 파일에서 diff 내용 읽기\\\\n        with open(args.diff_file, encoding=\\\\\\\"utf-8\\\\\\\") as f:\\\\n            return f.read()\\\\n    else:\\\\n        # Git 명령으로 diff 내용 가져오기\\\\n        repo_path = Path(args.repo_path)\\\\n        if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n            raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n        return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\n    # Git 명령으로 diff 내용 가져오기\\\\n    repo_path = Path(args.repo_path)\\\\n    if not repo_path.exists() or not (repo_path / \\\\\\\".git\\\\\\\").exists():\\\\n        raise ValueError(f\\\\\\\"오류: 유효한 Git 저장소 경로를 지정하세요: {repo_path}\\\\\\\")\\\\n    return run_git_diff(str(repo_path), args.commit_range)\\\\n```\\\", \\\"line_number\\\": 152}]}\"}, {\"role\": \"user\", \"content\": \"{\\\"file_name\\\": \\\"reviewer/src/utils/token/__init__.py\\\", \\\"file_content\\\": \\\"from .models import ReviewIssue, ReviewRequest, ReviewResponse\\\\nfrom .token_utils import TokenUtils\\\\n\\\\n__all__ = [\\\\n    \\\\\\\"TokenUtils\\\\\\\",\\\\n    \\\\\\\"ReviewRequest\\\\\\\",\\\\n    \\\\\\\"ReviewIssue\\\\\\\",\\\\n    \\\\\\\"ReviewResponse\\\\\\\",\\\\n]\\\\n\\\", \\\"formatted_hunks\\\": [{\\\"hunk_idx\\\": \\\"1\\\", \\\"before_code\\\": \\\"```python\\\\n\\\\n\\\\n# 지연 임포트를 위한 래퍼 클래스\\\\nclass _TokenUtilsWrapper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\\n\\\\n    이 클래스는 TokenUtils의 모든 메서드에 대한 접근을 제공하지만,\\\\n    실제로 TokenUtils가 필요할 때만 임포트합니다.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __getattr__(self, name):\\\\n        from .token_utils import TokenUtils\\\\n\\\\n        return getattr(TokenUtils, name)\\\\n\\\\n\\\\n# TokenUtils 대신 래퍼 인스턴스 제공\\\\nTokenUtils = _TokenUtilsWrapper()\\\\n```\\\", \\\"after_code\\\": \\\"```python\\\\nfrom .token_utils import TokenUtils\\\\n```\\\", \\\"line_number\\\": 0}]}\"}]",
    "actual_output": "{\"issues\": [{\"type\": \"performance\", \"line_number\": 2, \"file\": \"reviewer/src/utils/token/__init__.py\", \"description\": \"기존에 제공되던 지연 임포트 래퍼(_TokenUtilsWrapper)가 제거되어 TokenUtils가 모듈 import 시점에 즉시 로딩됩니다. 이로 인해 초기 로딩 시간이 늘어나거나, 순환 의존성 문제가 발생할 수 있습니다.\", \"suggestion\": \"필요 시 지연 임포트를 유지하여 모듈 로딩 성능을 최적화하고, 기존 호환성을 보장하세요. 아래와 같은 wrapper 방식을 재도입할 수 있습니다.\", \"severity\": \"warning\", \"target_code\": \"from .token_utils import TokenUtils\", \"suggested_code\": \"class _TokenUtilsWrapper:\\n    \\\"\\\"\\\"TokenUtils 클래스에 대한 지연 임포트 래퍼.\\\"\\\"\\\"\\n    def __getattr__(self, name):\\n        from .token_utils import TokenUtils\\n        return getattr(TokenUtils, name)\\n\\nTokenUtils = _TokenUtilsWrapper()\"}], \"summary\": \"지연 임포트 래퍼가 제거되어 TokenUtils의 로딩 시점이 변경되었습니다. 모듈 로딩 성능 및 순환 의존성 여부를 검토하세요.\", \"score\": 8.0, \"recommendations\": [\"모듈 초기화 시점의 성능 측정을 통해 직접 import와 lazy import 방식을 비교하세요.\", \"순환 의존성이 발생하지 않는지 프로젝트 전체를 검토하세요.\", \"변경 사항을 문서화하여 다른 개발자가 의도를 이해할 수 있도록 하세요.\"]}"
  }
]